1. 락프리, SRWLOCK 성능 비교
- 캐시는, 캐시 내의 값이 달라지면 다른 코어의 캐시를 무효화시킨다(캐시 무효화)

- ex) A와 B가 int a라는 값을 동시에 캐싱하는 중이었는데, A가 a의 값을 10으로 변경하면 B에게 a값이 변경되었다는 프로토콜을 보낸다. 이후, B가 변수 a에 접근하려고 할 경우 Cache miss가 발생하며 메인메모리에서 새로 데이터를 캐싱해온다.

- 락프리는 기본적으로 n개의 스레드가 경쟁해서 최소 1명이 승리하는 구조이다. 그리고 패배한 스레드들은 즉시 다시 CAS를 시도한다.

- 락프리의 CAS는 한 번 통과할 때 마다 값이 변경된다. 즉, CAS통과 시 마다 캐시 무효화가 발생한다는 뜻이다.

- 반면, SRWLOCK은 내가 건 락을 포기하기 전 까지는 다른 스레드가 공유자원에 접근할 수 없다.

- 때문에, 락을 건 후 내부에서 값을 10000번 변경해도 캐시무효화가 발생하지 않는다. 즉, 내가 락을 풀고 다른 스레드가 그 공유자원에 접근했을 때, 캐시 무효화가 발생한다.

- 즉, SRWLOCK은 락프리보다 캐시 무효화 발생 수가 적다. 때문에 락프리보다 빨라질 수 있다.

- 그럼, 모든 락이 락프리보다 빨라질 수 있는가? Critical Section도 락프리보다 빠를까?

- 그건 그렇지 않다. 
- 일단 SRWLOCK은 락 소유주를 체크하지 않는다.(대신 데드락 가능성을 가지고 있다)
- 락 객체도 포인터 크기(64비트는 8바이트)이며, 락 진입 시도 포인터의 비트값을 변경하는것이 전부이다. Critical Section이 해야 하는 것에 비하면 굉장히 가벼운 작업이다.
- 이런 내용들 때문에 Critical Section은 SRWLOCK보다 무거우며, 인터락보다 느려질 수 있다.

- 실제로 비교해보면 [Critical Section < 인터락 < SRWLOCK] 의 순서대로 빠르다. 물론 이는 상황에 따라 다르다.

- 결론 : 락프리는 CAS마다 캐시 무효화가 발생하고, SRWLOCK은 락을 푼 후, 다른 스레드가 공유자원에 접근할 때 캐시무효화가 발생한다.
- 결론 2 : 위의 결론대로라면 무조건 락이 빠를것 같지만, 락 자체의 무거움 때문에 SRWLOCK같이 가벼운 락일 경우에만 인터락을 뛰어넘을 가능성이 있다.
- 결론 3 : 락프리는 그냥 락이 없다뿐이지 빠른것은 아니다. 상황에 따라 사용해야 한다. 실제로... 락프리 큐를 쓰는것 보다 큐에 SRWLOCK을 잘 묶어서 사용하는것이 훨씬 빠를것이다.