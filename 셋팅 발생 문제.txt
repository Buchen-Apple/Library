1. replication 관련해서, sync_binlog가 너무 낮으면, 성능이 안나온다.
create.php 테스트 할 때, 이걸 1로하니까 TPS 100을 못넘음. 
현재는 150으로 수정
-----> 이건 4번 문제때문으로 확인됨.. 4번 적용하니까 sync_binlog 값이 1이라도 속도 잘 나옴.



2. 힙 침범(이벤트 뷰어 확인 결과)가 발생하면서 아파치가 재시작되는 상황.
확인 결과 php 버전 문제. 7.2 스레드 세이프 버전 사용결과 해결됨.



3. php에서 mysql connect나 fsockopen 시 에러가 발생할 수 있음. 에러 메시지는 다양함.
이 경우, 보통 포트 부족 문제. 동적포트를 열어준다.
근데, 포트 여는것 만으로 해결 안될수도 있음
이 경우에는, 레지스터에 Time_Wait시간 조절하도록 추가한다.

!! 주의사항 !!
msdn에 보면 timewait 범위가 30초부터라고 되어 있는데, 그 이하도 가능한듯 하다.
30으로 하면 여젼히 위의 문제 발생하지만, 5로 하니까 발생 안함.




4. mysql이 cpu를 100%점유하는 현상 발생.
Create.php를 하다가 발생한 문제.
이것저것 시도해봤으나, 문제는 innodb_flush_log_at_trx_commit설정 문제였음.

innodb_flush_log_at_trx_commit는 트랜잭션 로그를 저장하는 타이밍에 대한 설정임.
- 0: 초당 1회씩 트랜잭션 로그 파일(innodb_log_file)에 기록 (1초마다 디스크 기록 및 커밋)
- 1: 트랜잭션 커밋 시 로그 파일과 데이터 파일에 기록 (새로 커밋될 때 마다 디스크에 기록 및 커밋)
- 2: 트랜잭션 커밋 시 로그 파일에만 기록, 매초 데이터 파일에 기록 (새로 커밋되면 즉시 커밋. 1초가 되면 디스크 기록)

기존에는 1이었고 0으로하니까 점유율이 낮아지면서 속도도 빨라짐





5. 문제는 발생하지 않았지만, 아파치에서는 Access_Log라는걸 남긴다.
이건, 유저가 아파치에 접속할 때 마다 로그를 남기는건데, 테스트환경에서는 엄청나게 많은 접속이 발생하기 때문에 로그를 쓰는데 성능을 잡아먹는다. 
괜히 로그 파일만 커지기 때문에 꺼두는게 좋음 (실제 서비스할때는 다시 고려해야함)



6. mysql의 InnoDB에서 가장 중요한 값은 innodb_log_buffer_size이다.
InnoDB에서는 인덱스와 행 등을 메모리에 올려두는데, 이 버퍼 사이즈만큼 올려두는 듯 하다.
보통, 램의 70~80%를 설정한다.
웹 서버와 같은 PC에 있다면 30%정도가 적당하다.



7. php에서 mysqli_connect사용 시, mysqli_connect('p:'. $db_host, ...) 식으로 사용하면 영구적 연결이 가능하다.
이 경우, disconnect는 엔진의 영역인 듯 하다. 
이걸 사용하면 연결에 대한 오버헤드를 줄일 수 있다.
하지만 MySQL server has gone away 
에러가 발생한다... 해결이 필요하다



8. MySQL server has gone away에러는, 백로그 큐가 작아서 발생한 문제로 확인되었음
mysql 서버로 붙는 쪽(클라)은 300개씩 막 들어가는데, mysql 서버는 백로그 큐가 100개 이렇게 밖에 안되기 때문에 병목현상이 발생한 것.
윈도우의 백로그 큐 사이즈를 증가시킨 후, my.ini에서 back_log 사이즈를 조절하니 괜찮아졌음



9. 8번에 이어서.... 8번을 해결했는데 MySQL server has gone away 가 뜨는 경우가 있음.
1) 아파치 재부팅, DB 재부팅
2) 아파치에서 php를 이용해 mysql에 지속연결
3) mysql 재부팅 (아파치에는 아직 연결이 남아있음)
4) 클라가 다시 연결을 시도하면 MySQL server has gone away가 뜬다.

원인 : mysql이 재부팅되면, mysql쪽에서는 연결되어있던 지속연결이 모두 해제되는데, php는 스크립트 언어이기 때문에 인식 못한다. 
php입장에서, 다시 지속연결을 시도할 때 보관해뒀던 지속연결 객체를 list에서 pop한 후 이 연결로 서버와 연결을 시도하는데
Mysql 입장에서는 재부팅 되었기 때문에 이미 연결이 모두 끊겼다. 그래서 php는 Mysql에 연결을 실패한 후, 클라이언트에게 MySQL server has gone away를 날린다.
즉, php측에서 서버와 연결 끊김을 인지하지 못하는 문제인 듯 하다.

해결책 : 그냥 당연히 발생하는것. mysql 재부팅하면 아파치도 같이 재부팅시킨다.



10. 아파치 cpu가 100% 다 먹는 문제가 발생했었다.
원인은 다양하겠지만.. 나같은 경우는 OPCache를 사용하지 않았기 때문이었음.
OPCache는 미리 컴파일 해 둔 php코드를 캐시해 두고 사용하는 것.
즉, php의 컴파일 시간의 오버헤드를 줄여준다.
이거 하고나서 cpu사용율이 50%로 줄었다.



11. Mysql이 있는 서버가 죽는 문제 발생. 
Mysql 바이너리 로그로 인해 드라이브가 가득 찬 상황이었음.
Binlog를 정기적으로 삭제하도록 해 해결.
---------------
binlog_expire_logs_seconds(이진 로그 생존 시간. 초단위. 이 시간이 지난 로그는 삭제) = befor 2592000(30일) --> After 3600(1시간)
max_binlog_size(이진 로그의 최대 크기) = befor 1G --> After 512M
---------------
Mysql의 바이너리 로그는 '로그 순환' 시 삭제된다.
로그 순환 시점 : Mysql 문서 확인 결과 (https://dev.mysql.com/doc/refman/8.0/en/server-logs.html), 기존의 이진로그가 가득 차서 새로운 이진 로그를 생성할 때를
로그 순환 시점이라고 한다. 
더 정확히 이야기하면 이진 로그는, 로그 사이즈가 max_binlog_size에 도달하면 새로 파일을 생성하며 로그 순환이 발생.
로그 순환 시점에, 기존의 파일 시간을 체크해 binlog_expire_logs_seconds시간만큼 지났다면(초 단위) 기존 파일 삭제



12. mysql의 wait_timeout과 interactive_timeout이 너무 적으면 send byte 어쩌고 하는 에러 발생
지속연결 사용 시, timeout으로 mysql과 php간의 연결이 끊어질 경우, 아파치가 인지를 못함.
이 때, 아파치에게 해당 연결을 요청하면 send byte 어쩌꼬 에러가 뜬다.
즉, 문제로 안봐도 됨.

찝찝해서, 일단은 wiat_timeout과 interactive_timeout의 시간을 엄청나게 길게 함.