// 스택으로 재귀 대신하기.

#include <stdio.h>
#include <windows.h>
#include "Stack.h"

#define HEIGHT_LEN 11
#define WIDTH_LEN 30

void Print();
void Change();

char cOriginal[HEIGHT_LEN][WIDTH_LEN] =
{
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0',' ','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', ' ', '0', '0', ' ', '0','0','0',' ','0','0','0','0',' ' ,'0' ,' ' ,'0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,' ' ,'0' ,'0' },
{ '0', ' ', '0', ' ', '0', '0', ' ', '0','0','0',' ','0','0','0','0',' ' ,'0' ,' ' ,'0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,' ' ,'0' ,'0' },
{ '0', '0', '0', ' ', '0', '0', ' ', '0','0','0',' ','0','0','0','0',' ' ,'0' ,' ' ,'0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,' ' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', ' ','0','0',' ','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },
{ '0', '0', '0', '0', '0', '0', '0', '0','0','0','0','0','0','0','0','0' ,'0' ,' ' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' ,'0' },

};

char cBuffer[HEIGHT_LEN][WIDTH_LEN];

Stack stack;

int main()
{
	StackInit(&stack);

	int i;
	int j;
	bool bSave = true;

	while (1)
	{
		for (i = 0; i < HEIGHT_LEN; ++i)
		{
			for (j = 0; j < WIDTH_LEN; ++j)
			{
				cBuffer[i][j] = cOriginal[i][j];
			}
		}

		Print();
		Sleep(1000);

		Change();
		Sleep(1000);
	}

	return 0;
}

void Print()
{
	int i;
	int j;
	system("cls");

	for (i = 0; i < HEIGHT_LEN; ++i)
	{
		for (j = 0; j < WIDTH_LEN; ++j)
		{
			printf("%c", cBuffer[i][j]);
		}
		fputs("\n", stdout);
	}
	Sleep(2);
}

void Change()
{
	int i = 5;
	int j = 5;
	bool PopSave = true;

	// 1. 초기값 세팅
	Push(&stack, i, j);

	while (1)
	{
		// 2. 현재 스택의 값이 *이거나 공백이면 팝
		if (cBuffer[i][j] == '*' || cBuffer[i][j] == ' ')
			PopSave = Pop(&stack, &i, &j);

		if(PopSave == false)
			break;

		// 3. 0이라면 *로 변경
		else if (cBuffer[i][j] == '0')
		{
			cBuffer[i][j] = '*';
			// 변경된 값을 다시 그린다.
			Print();
		}	

		// 4. 상,하,좌,우 체크
		while (1)
		{
			// 상 체크. 현재 좌표 기준, 위의 값이 '0' / 맵의 가장 위가 아니라면 위로 한칸 좌표 이동 후 해당 좌표 푸시
			if (cBuffer[i - 1][j] == '0' && i - 1 >= 0)
			{
				i--;
				Push(&stack, i, j);
			}

			// 하 체크. 현재 좌표 기준, 하의 값이 '0' / 맵의 가장 아래가 아니라면 아래로 한칸 좌표 이동 후 해당 좌표 푸시
			else if (cBuffer[i + 1][j] == '0' && i+1 < HEIGHT_LEN)
			{
				i++;
				Push(&stack, i, j);
			}

			// 좌 체크. 상동
			else if (cBuffer[i][j - 1] == '0' && j-1 >= 0)
			{
				j--;
				Push(&stack, i, j);
			}

			// 우 체크. 상동
			else if (cBuffer[i][j + 1] == '0' && j+1 <WIDTH_LEN)
			{
				j++;
				Push(&stack, i, j);
			}

			break;

		}
			
	}

}
