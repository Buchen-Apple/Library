통신 프로토콜
- 호스트와 라우터, 라우터와 라우터, 호스트와 호스트가 통신하기 위한 절차와 방법.

OSI 7계층
- 응용 계층
- 표면 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

TCP/IP 4계층
- 응용 계층 - 최종 목적지.
- 전송 계층 - 포트를 이용해 최종 통신 목적지에게 전달.
- 인터넷 계층 - 논리주소를 이용해 데이터를 목적지 호스트까지 전달.
- 네트워크 인터페이스 계층 - 물리 네트워크를 통한 실제 데이터 송수신 담당

TCP/IP 4계층을 지날 때 마다 무슨일이 발생하는가?
- TCP헤더(포트) / IP 헤더(IP) / 이더넷 헤더(MAC주소)를 붙인다.

TCP란?
- 연결 지향의 통신 프로토콜
- 데이터 경계가 없다.
- 신뢰있는 데이터 전송 보장

UDP란?
- 비연결 지향의 통신 프로토콜
- 데이터 경계가 있다.
- 신뢰없는 데이터 전송.

호스트란?
- IP주소를 이용해 통신하는 기기. 
- PC/서버/라우터 등..

라우터란?
- 서로 다른 네트워크에 속한 호스트간 데이터를 교환할 수 있게 하는 장비

소켓이란?
- 운영체제의 TCP/IP에서 생성한 데이터 구조체를 참조하기 위한 매개체
- 프로토콜, 목적지/출발지 IP, 목적지/출발지Port로 구분. 데이터 구조체 생성 시 논페이지드 메모리 영역을 먹는다.
- accept함수가 리턴하기 전에 백로그 큐를 보고 connect 패킷이 있으면 소켓을 만들어서 위 5개 정보 할당 후, 그 소켓에 접근할 수 있는 값을 리턴해준다.

백로그 큐
- 연결요청 대기 큐. listen함수 호출 시 설정 가능하며, SOMAXCONN(Socket Max Connect)로 하면 OS가 알아서 설정한다.
- 윈도우에서는 200이다.

루프백 주소
- 127.0.0.1으로 자기 자신을 의미하는 주소이며, 패킷이 PC 외부로 아예 나가지도 않는다.

TCP와 UDP의 차이점
- TCP는 연결형 / UDP는 비연결형
- TCP는 신뢰있는 전송 / UDP는 신뢰 없는 전송
- TCP는 1:1통신 / UDP는 1:1, 1:n 통신 둘다 제공
- TCP는 데이터 경계 없음 / UDP는 데이터 경계 있음

데이터 경계란
- 10바이트를 3번 보냈을때, 경계가 있을 경우(UDP) recv하는 쪽도 10바이트씩 3번 받아야 함
- 경계가 없을 경우, 네트워크 상황에 따라 recv한 번에 30바이트를 받아올 수도 있다.

유니캐스트
- 1:1전송

멀티캐스트
- 1:그룹 전송

애니캐스트
- 1: 그룹 전송. 가장 가까운 1명에게만 보내면, 그 1명이 자신이 속한 그룹의 나머지 유저에게 패킷 보냄
- IPv6에서만 지원

브로드 캐스트
- 1:특정 네트워크의 모든 개체
- 이론상으로는 외부 네트워크에도 가능하지만, 실제로는 라우터를 통과하지 못하기 때문에 내부 네트워크만 가능
- IP는 가장 큰 수. 192.0.0.0일 경우, 192.255.255.255. 192.168.0.0일 경우, 192.168.255.255
- IPv6은 지원하지 않음

ARP
- 목적지 IP를 이용해, 현재 이 데이터가 다음으로 가야할 장치를 알아온다. (브로드 캐스팅)
- 해당 ARP를 뿌리는 장치의 내부 네트워크에 대상이 있다면, 대상의 MAC주소를 알아온다.
- 없다면 gateway가 자신의 MAC주소를 응답해준다.
- L3 계층에서 하는 일이다.

ICMP(Internet Control Message Protocol)
- TCP기반 통신 중, 전송과정에 문제가 생기면 이 패킷에 의해 메시지가 송신 쪽으로 돌아온다.
- 즉 오류 생길 시 송신쪽으로 알려주는 용도

IGMP(Internet Group Management Protocol)
- 멀티캐스트에 사용되는 그룹에, 가입하거나 탈퇴할 때 사용되는 프로토콜

클라이언트-서버 모델이란?
- 서비스 요청자인 클라이언트와 서비스 제공자인 서버 간에 작업을 분리해주는 네트워크 아키텍처.
- 중앙집권 형태

P2P모델이란?
- 서버/클라이언트의 개념 없이 모든 피어들이 클라/서버역활을 동시에 수행.
- PureP2P, Hybrid P2P, SuperPeer 총 3개의 방식이 존재.

바이트 정렬
- 메모리에 데이터를 저장할 때의 바이트 순서.
- 리틀엔디안 : 최하위 바이트부터 저장 (컴퓨터 친화적)
- 빅 엔디안 : 최상위 바이트부터 저장 (인간 친화적).
- 네트워크 장비들은 대부분 빅엔디안을 사용하기 때문에, IP와 Port는 빅엔디안으로 전달해야 한다.

도메인
- 사람이 기억하기 힘든 IP를 문자로 기억할 수 있도록 변경한 식별자. IP와 대응된다.

도메인 이름 서버(DNS 서버)
- 도메인과 IP를 기억하는 서버

도메인 이름 시스템(DNS)의 작동 구조
- 재귀적 호출(Recursive Query) 절차.
- www.naver.com을 치는 순간 Local NS서버에게 www.naver.com의 IP를 아냐고 물어본다
- 해당 DNS서버는 자신이 가지고 있으면 바로 IP를 돌려준다.
- 없으면 루트 도메인에게 [www.naver.com은 어디있어?]라고 물어본다. ->루트는 [.com]의 DNS 서버를 알려준다.
- .com에게 www.naver.com을 아냐고 물어본다. -> .com은 [naver.com]의 DNS 서버를 알려준다.
- naver.com에게 [www.naver.com]을 아냐고 물어본다 -> naver.com은 IP를 돌려준다.

- IP를 알아온 Local NS는 Client에게 IP를 돌려준다. 그리고 클라는 해당 IP로 접속된다.
- 나머지는 그 웹서버의 영역....

DNS의 프로토콜
- UDP

- Local NS는 천천히 www.naver.com을 캐싱해두며, TTL(Time To Live)만큼 유지된다. TTL이 0이되면 레코드에서 삭제된다. 

소켓의 프로토콜이 설정되는 시점
- socket()함수로 소켓 생성 시

지역 IP와 지역 포트가 결정되는 시점
- bind()함수가 호출될 때

포트 상태가 LISTENING이 되는 시점
- listen()함수를 호출할 때

서버에 접속한 원격 IP와 원격 포트를 알 수 있는 시점
- accept라 리턴된 후 구조체 확인.

클라이언트 입장에서 IP와 Port가 결정되는 순간
- connect 함수 호출 시 지역,원격 Ip와 Port가 모두 결정
- 클라에서도 bind를 사용해 IP와 Port를 바인딩할 수 있다.

send함수 리턴 시점
- 소켓 송신버퍼에 데이터 복사 후 리턴. 실제 전송은 TCP에서 알아서 해준다.
- 블락 소켓 : 내가 보내고자 하는 바이트만큼 송신버퍼에 공간이 없으면 block
- 논블락 소켓 : 송신버퍼에 공간이 부족해도, 공간이 있기만 하면 그 만큼만 복사한 후 복사한 바이트 리턴. 송신버퍼의 여유사이즈가 정말 0이면 우드블럭

recv함수 리턴 시점
- 소켓 수신버퍼에서 데이터 복사받은 후 리턴.
- 블락 소켓 : 내가 100을 받고싶었는데 10만 있어도, 10만큼만 복사되며 10리턴. 수신버퍼에 데이터가 없을 경우 블락
- 논블락 소켓 : 위 동일. 하지만 수신버퍼에 데이터가 없을 경우 우드블럭

블락 소켓의 connect 함수의 리턴 시점
- 서버가 listen중이며, 백로그에 공간이 있다 : 백로그 큐에 들어간 후 성공 리턴 (accept를 안해도 백로그 큐에 들어가면 리턴)
- 서버가 listen중이며, 백로그가 가득 찼다 : 즉시 실패 리턴
- 서버가 listen중이 아니다 : 20초 대기하다가 리턴
- 서버의 방화벽이 닫혀있다 : 20초 대기하다가 리턴
- 서버로 쓸 PC가 꺼져있다 : 20초 대기하다가 리턴

논블락 소켓의 connect 절차
- 소켓 논블락 변경 후 connect 시도
- WSAEISCONN : 소켓이 이미 연결됨
- WSAEWOULDBLOCK : 연결 시도중임
- WSAEWOULDBLOCK일 경우, select의 쓰기셋,예외셋에 소켓 넣고 시간도 설정한 후 Select
- 쓰기셋에 반응이 오면 정상연결된것. 예외셋에 반응이 오면 뭔가 잘못된것

window size
- TCP에서, 상대의 수신 여유 공간이 얼마인지 알려주기 위함. 소켓 수신버퍼 사이즈를 의미
- TCP는 이 사이즈를 보고 패킷 보내는 크기?를 조절한다.
- 강제로 0으로 설정해도, 통신을 하다보면 서서히 늘어난다.

데이터 전송방식의 종료
- 고정길이 데이터 전송방식 : 송신자가 항상 고정된 길이의 데이터를 보낸다. 수신자도 고정된 길이를 받는다.
- 가변길이 데이터 전송 방식 : 송신자는, 데이터 가장 마지막에 '여기까지가 데이터다'라고 표시한다. 수신자는 마지막 표식이 나올때까지 읽는다.
- 고정길이 + 가변길이 전송 방식 : 고정 길이로 가변길이의 사이즈를 보내고, 뒤에 가변길이를 보낸다. 수신자는 고정길이를 읽은 후, 그 사이즈만큼 가변길이를 읽는다.
- 보낸 후 종료 : 송신자는 데이터를 보낸 후 종료한다. 수신자는 데이터를 읽다가 정상종료(recv 리턴값 0)가 될 때 까지 읽는다.

데이터 전송 시 고려사항
- 바이트 정렬, 구조체 멤버 맞춤 고려 (Byte 버퍼를 사용하면 고민할 필요 없음)

구조체 멤버 정렬을 사용하는 이유
- 주로 네트워크 송/수신 시 사용하며, 트래픽 자체가 돈이기 때문에 패킷 크기를 작게 하기 위해 사용한다.
- 같은 프로세스에서 사용하면 오히려 정렬 깨져서 더 느리거나 이상한 작동을 할 수도 있다.

TCP와 UDP의 공통점
- 포트 번호를 이용해 주소 지정
- 데이터 오류 체크 : UDP도 데이터 오류는 체크한다. 다만, 오류 발생 시 재전송 등을 안하고 그냥 패킷 버림.

서브넷 마스크
- 1개의 네트워크에 서브넷 마스크를 추가해 2개 이상의 네트워크로 만드는 방법
- IP주소의 낭비를 줄이기 위한것.
- 분리된 네트워크는 라우터를 통해서만 통신 가능

소켓 옵션
- 소켓 레벨, IP레벨, TCP레벨 총 3개의 옵션 설정 가능

소켓 옵션의 소켓 레벨
- 브로드 캐스트 작동 여부
- recv/send 버퍼 사이즈
- KeepAlive 작동 여부
- Linger 작동 여부
- recv/send 타임아웃 설정
- 소켓 재사용

소켓 옵션의 TCP 레벨
- Nagle 알고리즘 적용 여부 
- 기본은 작동중이며, 옵션으로 끌 수 있다.

네이글 알고리즘이란?
- 보낼 데이터가 있을 때마다 데이터를 보내는것이 아니라, 데이터가 MSS만큼 쌓이거나, 데이터에 대한 응답(ACK)가 도착하면 데이터를 보낸다.
- 장점 : 트래픽 감소.
- 단점 : 클라이언트 입장에서 응답성이 낮게 느껴질 수도 있다.

MSS
- Maximum segment Size의 약자이며, 실제 내가 보내고자 하는 패킷 사이즈(페이로드)
- 이더넷은 기본 1460

MTU
- Maximum Transmission Unit의 약자로, MSS, IP헤더크기, TCP헤더크기를 더한 값
- 라우터를 빠져나갈 때의 패킷 크기
- 이더넷에서는 1500(1460(MSS) + 20(IP헤더) + 20(TCP헤더)) 이다.

패킷 단편화
- 한 번에 보내야 하는 데이터가 MSS나 MTU보다 크다면, 패킷 단편화 발생
- 발생 시점 1 : 소켓 송신버퍼에서 TCP 계층으로 패킷을 내려보낼 때, MSS단위로 패킷 쪼개짐
- 발생 시점 2 : 1번 라우터 -> 2번 -> 3번 순으로 이동할 때, 최초 출발지 라우터(1번)는 MTU가 1500인데 중간지 라우터(2번)의 MTU가 1500보다 작을 경우, 패킷 쪼개짐. 라우팅 중 패킷이 쪼개질 경우, 받는 쪽(3번)의 라우터는 모든 패킷이 도착할 때 까지 기다리다가 도착하면 위로 올려보낸다.

TCP의 특징
- 흐름 제어 (슬라이딩 윈도우)
- 오류 제어 (재전송, 순서 보장)
- 혼잡 제어 (네이글, 슬로우스타트)

MSL
- Maximum segment Lifetime의 줄임말
- TCP 세그먼트가 네트워크에 존재하는 시간이며, TIME_WAIT의 간격을 결정함(2*MSL)

KeepAlive 사용 목적
- TCP는 논리적 연결이기 때문에, 데이터 통신이 없으면 상대가 다운되거나 전원이 끊어지는 등의 상황을 감지못한다.
- 이를 감지하기 위함.
- TCP에만 사용 가능

Linger란?
- closesocket함수의 리턴 시간 제어.
- TIME_WAIT 상태를 남기지 않기 위해서도 사용.
(TIME_WAIT상태 동안은 리소스를 계속 사용함과 동시에 포트도 사용 불가능 상태가 된다.)
- shutdown과 함께 적용 안됨
- TCP에만 사용 가능

Linger 작동 방법
- Off : closesocket함수 즉시 리턴. 남은 데이터는 백그라운드로 모두 보낸다. 기본 closesocket 작동법
- On / 시간 0 : closesocket함수 즉시 리턴. 상대에게 reset보냄. 송신버퍼 데이터 모두 삭제
- On / 시간 0이상 : 시간 동안 대기 후 closesocket 함수 리턴. 시간동안 데이터가 다 못갔으면 상대에게 reset. 남은 송신버퍼 데이터는 모두 삭제

TIME_WAIT이 안남으면 어떤 문제가? (아래 가정은 둘 다 클라가 먼저 연결을 끊었다는 가정)
- 지연 패킷 발생으로 인한 데이터 무결성 --> 이전 연결에 대한 패킷을 새로운 연결이 수용하게 된다.
- 원격 종단의 연결이 끊겼는지 확인해야 할 경우 --> SYN에 대해 RST를 보낸다. 
- 새로운 연결이 끊긴다. --> 클라의 마지막 ack가 유실될 경우, 서버는 다시 FIN을 보내는데(ACK를 받기 위해) 그 FIN이 새로운 연결에게 간다면, 연결이 끊긴다.

TCP 통신 중, 송/수신 버퍼 사이즈를 변경할 경우 문제점
- TCP는 슬라이딩 윈도우로 통신하기 때문에, 사이즈가 변화하게 되면 데이터가 갑자기 몰려오거나 공간이 부족해지는 등의 알 수 없는 문제가 발생할 수 있다.

논블락 단점
- 높은 CPU 사용율

이상적인 소켓 입출력 모델
- 소켓함수 블로킹이 없어야 함
- 스레드 개수가 적당한 수준으로 유지
- 코드 실행(CPU 명령 수행)과 입출력 작업 동시진행
- 유저모드 / 커널모드 전환 횟수 최소화

소켓 입출력 모델의 종류
- Select
- WSAAsyncSelect
- WSAEventSelect
- Overlapped
- IOCP

Select 모델
- 동기 입출력
- 단일스레드 전용 모델
- 소켓 함수 호출 성공시점을 미리 알 수 있다.
- 읽기 셋 : accpet(접속한 클라가 있을 경우), Recv(받은 데이터가 있을 경우), Recv(TCP연결이 종료된 경우)
- 쓰기 셋 : Send(송신 버퍼 여유공간이 있을 경우)
- 예외 셋 : Recv(OOB 데이터가 도착한 경우)
- 한 번에 최대 FD_SETSIZE(64)만큼의 소켓 처리 가능

Select 모델 논블락 Connect
- 일단 connect 시도 후, 쓰기셋과 예외셋에 connect 소켓을 넣은 후 Select를 한다.
- 쓰기 셋 : connect 성공
- 예외 셋 : connect 실패

Select 모델 에러 발생 시점
- Select로 이상한 소켓을 전달하면 에러가 발생한다. (소켓 셋에 3개 다 NULL을 넣거나 소켓이 아닌걸 넣을 경우)
- 이 외에는 에러 발생한 적 없음

WSAASyncSelect 모델
- 동기 입출력으로 단일스레드로도 여러 소켓을 처리 할 수 있다.
- 함수 호출 성공 시점을 윈도우 메시지 형태로 받는다.

WSAASyncSelect 모델 작동법
- 관심있는 작업(Recv/Send/Accept 등..)을 등록해두면 커널이 윈도우 메시지 형태로 결과를 알려준다.

WSAASyncSelect 모델 유의점
- 메시지 발생 시, 적절한 함수를 호출하지 않으면 다음번에는 같은 윈도우 메시지가 발생하지 않음.

WSAEventSelect 모델
- 동기 입출력이며, 단일스레드로도 여러 소켓 처리 가능
- 함수 호출 시점을 Event를 통해 알 수 있다.

WSAEventSelect 모델 작동법
- 관심있는 이벤트(Recv/Send/Accept 등..)를 등록해두면, 가능 상태일 때 이벤트를 signaled 상태로 변경.

WSAEventSelect 모델 유의점
- 이벤트 발생 시, 적절한 함수를 호출하지 않으면 다음번에는 같은 이벤트가 발생하지 않음.
- WSAWaitForMultipleEvent에서 최대로 대기 가능한 이벤트는 64개이다.

WSAAsyncSelect /  WSAEventSelect 모델에서 FD_WRITE가 뜨는 상황
- 보낼 수 없다가 보낼 수 있는 상황이 될 때.
- Connect 성공 시. 이 때는, FD_CONNECT가 먼저 뜨고, 뒤 이어 FD_WRITE도 뜬다.
- send()함수에서 WSAEWOULDBLOCK이 뜬 후. (우드블럭이 뜬건 송신버퍼가 꽉찼다는건데, 꽉찼다가 빈 상태가 됐으니 당연히 떠야함)

동기 입출력과 비동기 입출력
- 동기 입출력 : 함수 리턴시점 == 작업 완료 시점
- 비동기 입출력 : 함수 리턴시점 != 작업 완료 시점

블락과 논블락
- 블락 : 함수 리턴조건 불만족 시 스레드 블락.
- 논블락 : 함수 리턴조건 불만족 시에도 함수 즉시 리턴. 함수 리턴되면서 WSAEWOULDBLOCK 발생

논블락과 비동기의 차이점
- 논블락 : 블락 걸릴 시점에 WSAEWOULDBLOCK이 발생하며, 사용자가 다시 I/O를 요청해야 함.
- 비동기 : 블락 걸릴 시점에 WSA_IO_PENDING이 발생해 비동기로 처리되기 때문에, 커널이 I/O를 완료한 후 알려준다.

WSARecv 작동 방법
- 소켓 수신버퍼에 받은 데이터가 0 : I/O 펜딩을 리턴하면서 커널 스레드가 I/O작업을 해준다. 메모리락 걸린다.
- 소켓 수신버퍼에 받은 데이터가 1이라도 있음 : 그 데이터를 유저 버퍼에 복사한 후 0리턴. 그리고 워커스레드에 반응 옴.

WSASend 작동 방법
- 소켓 송신버퍼에 여유공간이 충분하지 않음 : 100을 보내고 싶은데 여유 공간이 90. 혹은 여유공간 0. I/O펜딩을 리턴하면서 커널스레드가 I/O해줌. 메모리락.
- 소켓 송신버퍼에 여유공간이 충분하다 : 데이터를 송신버퍼에 복사한 후 0 리턴. 그리고 워커스레드에 반응 옴.

중첩 IO의 의미
- 기존의 I/O가 완료되지 않아도 새로운 I/O를 중첩해서 요청할 수 있다는 것.

Overlapped I/O모델(1) 작동법
- 이벤트를 사용하는 비동기 입출력
- 요청한 비동기 작업 완료 후 운영체제가 작업 완료 후 Event를 신호상태로 변경한다.
- 한 번에 64개까지 밖에 사용 못함.
- 운영체제가 작업 완료  응용프로그램으로 알려주는것이 핵심!!
- 이전 모델들은 모두, 함수 호출 성공시점을 알려줬을 뿐 작업을 요청하고 완료를 알려준 것이 아님!!

모든 Overlapped I/O 모델 사용 이유
- 데이터를 보내고 받는 작업을 효율적으로 처리하기 위함.

WSASend / WSARecv의 특징
- Scatter(스켓터)와 Gather(게터)를 지원한다.
- 이는, 모아 보내거나(Gather) 흩뜨려 받을 수 있다(Scatter)는 의미.

비동기 입출력 작동법
- WSASend나 WSARecv를 호출했을 때, 수신버퍼에 데이터가 있거나 송신버퍼 사이즈가 있을 경우 동기처럼 작동한다. (소켓 송/수신버퍼에 데이터 복사 후 리턴)
- 위 상황이 아니면, 유저모드 메모리에 락 걸고 해당 메모리 주소 저장 후(8바이트) 에러 리턴. 에러는 I/O pending 이다

메모리 락 (페이지 락)
- Overlapped(1)모델, APC를 사용하는 Overlapped모델, IOCP는 송신버퍼가 가득 차거나, 수신버퍼에 데이터가 0일 경우 응용 프로그램의 버퍼에 락을 건 후 이 메모리 영역에 직접 접근한다.
- 페이지 락에 걸린 페이지는, 디스크로 파일 아웃 되지 않는다.
- 이걸 메모리 락이라 한다.
- 락 걸때, 해당 메모리만 거는게 아니라, 해당 메모리가 있는 페이지 전체를 락 건다.
- 이 메모리락이 과해지면 WSANOBUF가 발생한다.

메모리 락으로 인한 장점
- 유저 영역과 커널 영역 복사 불필요
- 모든 전환없이 입출력 작업이 진행.

Overlapped I/O모델(2) 작동법
- APC 큐를 사용하는 비동기 입출력 모델
- 요청한 비동기 입출력 작업이 끝나면 운영체제는, 관련 내용을 APC큐에 저장한다.
- 그리고, CompletionToutine 함수를 등록한 스레드가 alertable wait 상태가 되면 APC큐에 저장된 내용을 기준으로, 등록한 완료 루틴이 실행된다.
- 완료루틴은 WSARecv / WSASend에 등록한다.
- 소켓 제한 없이 사용 가능

APC 큐
- alertable wait 상태가 될 시 실행할 완료루틴과 매개변수 정보가 들어간다.
- 커널 모드에 존재한다.
- 넣는것은 누구든 넣을 수 있지만, 실제 해당 큐에 내용을 체크해 실행하는 것은 스레드 자기 자신만 가능

alertable wait 상태
- 알람 가능한 상태라는 의미이며, APC큐에 있는 내용을 처리 가능한 시점을 의미한다.
- SleepEX, WaitForSingleObjectEx 등 각종 EX함수로 가능.
- 예를 들어 SleepEX(1000, TRUE)로 하면 1초동안 alertable wait 상태가 되며, 이 상태일 때는 APC큐에 처리할 것이 있으면 처리한다. 처리할 것이 없으면 1초동안 잠만 잔다. 
- 예를 들어 0.9초가 되는 시점에 APC큐에 데이터가 들어온다면, 0.1초동안 완료 루틴을 실행하다가 SleepEX()가 리턴된다.

시리얼 모델
- 일반 send/recv를 사용하는 구조

컨커런트 모델
- 연결 1개에 스레드 1개 생성

IOCP
- 연결 1개에 이미 생성된 스레드 n개가 대응

IOCP란?
- 비동기 입출력을 제공하며, 입출력 결과와 결과 처리 스레드를 가지고 있는 구조.

IOCP 장점
- 합리적인 스레드 풀링 : 기존 컨커런트 모델은 연결 1개당 스레드 1개를 제작. IOCP는 지정한 수 만큼의 스레드를 만들어 많은 연결을 처리. 컨커런트 모델에 비해 스레드 수가 적으므로 컨텍스트 스위칭 부담이 적다.
- wait thread queue는 스택 구조로 관리 : 캐시히트 가능성 증가, 기존에 사용했던 페이지가 물리메모리에 존재할 가능성.

IOCP에 함수 등록 방법
- GQCS 함수 호출 시 해당 스레드는 IOCP 결과 처리 스레드로 등록되며, 대기 스레드 큐에 들어간다.

GQCS의 리턴값
- FALSE일 경우 : Overlapped구조체가 NULL이면 IOCP 내부 에러
- 하지만, 리턴값을 받아도 할게 없다. 

컨커런트 모델 / 시리얼 모델
- 컨커런트 모델 : 아파치와 같은 구조. 접속 1개에 스레드 1개 생성
- 시리얼 모델 : 스레드 1개가 모든 접속을 처리하는 구조. Select 등...

IOCP와 APC큐의 차이점
- 생성/파괴 : IOCP는 직접생성 후 직접 파괴. APC큐는 자동으로 생성되고 자동으로 파괴
- 접근 제약 : IOCP는 누구나 접근 가능. APC큐는 자기 자신 스레드만 확인 가능
- 비동기 입출력 처리 방법 : APC큐는 alertable wait 상태에서 처리. IOCP는 GQCS에서 처리.

비동기 입출력 모델의 이름
- Overlapped1은 이벤트 모델
- Overlapped2는 얼러터블 모델
- IOCP는 IOCP

RTO(Retransmition Time out)
- 패킷을 한번 보낸 후 이 시간이 가기 시작하며, 이 시간이 다 되면 패킷을 재전송한다.
- RTT를 기준으로 측정된다.

RTT(Round Trip Time)
- 패킷 하나를 주고 받는 시간
- 내가 패킷을 Send한 후 그것에 대한 응답이 Recv되기까지 시간

서버 부하분산 방법
- L4기계를 이용 : L4머신 자체가 부하분산을 해준다.
- 네임서버 사용 : 네임서버를 이용해, 서버 부하분산. 라운드 로빈 방식

네임서버를 이용해 스테이트풀 서버를 부하분산 할 수 있을까?
- 불가능
- 예를 들어, 주몽서버를 관리하는 물리서버가 4대라고 해보자. 이 때, 1번서버에 접속한 유저 A와 4번 서버에 접속한 유저 B가 같이 플레이해야한다면? 메모리에 있는 정보를 1번서버와 4번서버가 공유해야하는데 어떻게?
- DB기반 서버면 가능하다.

NAT란?
- 사설 아이피와 공인 아이피를 변환하는 기능
- 라우터에서 해준다.

NAT의 목적은?
- 공인 IP는 고갈될 수 있다.
- 이를 대비해 다수의 사설 IP가 1개의 공인 IP를 사용하도록 한다.

NAT 테이블이란?
- 내부 IP, Port와 공인IP, 라우터의 IP, Port가 맵핑된 테이블
- 내부에서 밖으로 나갈 때 추가된다.

IP 패킷 재조립
- NAT 기능이 IP 패킷을 재조립한다. 사설 IP를 공인 IP로 바꾸기 위함이다
- 라우터가 하는게 아니고, NAT 기능에서 하는것이다. 단지, 라우터에 NAT 기능이 있으니 그게 가능한 것 뿐

CancelIOEx를 하는 이유
- 서버쪽에서 먼저 연결을 끊을 경우
- shutdown으로 끊을 경우 : 4way handshake를 시작하는 서버가 FIN을 보내면 FIN_WAIT_1이 된다.
- 근데, 이 FIN이 소실되거나 네트워크 과부하로 늦게 도착하는 상황이다.
- 그 와중에 클라가 closesocket으로 종료한다. 그리고 다시 접속한다.
- 서버 입장에서, 해당 유저는 아직 종료 안됐기 때문에(FIN_WAIT_1 상태) 또 중복로그인으로 처리된다.

CancelIOEx 사용법
- Linger(0,0)를 걸고 CancelIOEx를 하면 reset을 보내고, 바로 포트가 CLOSE가 되기 때문에 FIN_WAIT_1등이 남을 일이 없다.

샤딩
- 수평 파티셔닝
- 스케일 아웃 기술 중 하나
- 트랜잭션, 조인 불가능
- PK 고유

스테이트 풀과 스테이트 리스
- 스테이트 풀 : 상태를 서버 메모리에 가지고 있음
- 스테이트 리스 : 상태를 DB나 파일 등에 가지고 있음. 

스테이트 리스의 특징
- 스케일 아웃 가능
- 부하가 DB에 몰림
- 주로 웹.