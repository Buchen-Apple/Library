호스트란?
- 응용프로그램을 수행하는 주체. 

라우터란?
- 서로 다른 네트워크에 속한 호스트간 데이터를 교환할 수 있게 하는 장비

통신 프로토콜
- 호스트와 라우터, 라우터와 라우터, 호스트와 호스트가 통신하기 위한 절차와 방법.

OSI 7계층
- 응용 계층
- 표면 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

TCP/IP 4계층
- 응용 계층 - 최종 목적지.
- 전송 계층 - 포트를 이용해 최종 통신 목적지에게 전달.
- 인터넷 계층 - 논리주소를 이용해 데이터를 목적지 호스트까지 전달.
- 네트워크 인터페이스 계층 - 물리 네트워크를 통한 실제 데이터 송수신 담당

TCP/IP 4계층을 지날 때 마다 무슨일이 발생하는가?
- TCP헤더(포트) / IP 헤더(IP) / 이더넷 헤더(MAC주소)를 붙인다.

IOCP란?
- 비동기 입출력을 제공하며, IOCP 큐와 GQCS로 등록한 스레드들을 이용해 I/O를 해주는 모델.

IP주소란?
- 각 통신 장치에, 부여되는 주소. Ipv4와 Ipv6가 존재한다.

포트란?
- 통신의 종착점을 나타내는 식별자. 한 번에 하나만 열 수 있다.
- 1개의 프로세스가 2개의 포트를 열 수도 있다.

소켓이란?
- 운영체제의 TCP/IP에서 생성한 데이터 구조체를 참조하기 위한 매개체
- 프로토콜, 목적지/출발지 IP, 목적지/출발지Port로 구분. 데이터 구조체 생성 시 논페이지드 메모리 영역을 먹는다.
- accept함수가 리턴하기 전에 백로그 큐를 보고 connect 패킷이 있으면 소켓을 만들어서 위 5개 정보 할당 후, 그 소켓에 접근할 수 있는 값을 리턴해준다.

백로그 큐
- 연결요청 대기 큐. listen함수 호출 시 설정 가능하며, SOMAXCONN(Socket Max Connect)로 하면 OS가 알아서 설정한다.
- 윈도우에서는 200이다.

루프백 주소
- 127.0.0.1으로 자기 자신을 의미하는 주소이며, 패킷이 PC 외부로 아예 나가지도 않는다.

TCP와 UDP의 차이점
- TCP는 연결형 / UDP는 비연결형
- TCP는 신뢰있는 전송 / UDP는 신뢰 없는 전송
- TCP는 1:1통신 / UDP는 1:1, 1:n 통신 둘다 제공
- TCP는 데이터 경계 없음 / UDP는 데이터 경계 있음

데이터 경계란
- 10바이트를 3번 보냈을때, 경계가 있을 경우(UDP) recv하는 쪽도 10바이트씩 3번 받아야 함
- 경계가 없을 경우, 네트워크 상황에 따라 recv한 번에 30바이트를 받아올 수도 있다.

유니캐스트
- 1:1전송

멀티캐스트
- 1:그룹 전송

애니캐스트
- 1: 그룹 전송. 가장 가까운 일부 수신자에게만.

브로드 캐스트
- 1:특정 네트워크의 모든 개체
- 이론상으로는 외부 네트워크에도 가능하지만, 실제로는 라우터를 통과하지 못하기 때문에 내부 네트워크만 가능
- IP는 가장 큰 수. 192.0.0.0일 경우, 192.255.255.255. 192.168.0.0일 경우, 192.168.255.255

ARP
- 목적지 IP를 이용해, 현재 이 데이터가 다음으로 가야할 장치를 알아온다. (브로드 캐스팅)
- 해당 ARP를 뿌리는 장치의 내부 네트워크에 대상이 있다면, 대상의 MAC주소를 알아온다.
- 없다면 gateway가 자신의 MAC주소를 응답해준다.

ICMP
- TCP기반 통신 중, 전송과정에 문제가 생기면 이 패킷에 의해 메시지가 송신한 쪽으로 돌아온다.

IGMP
- 멀티캐스트에 사용되는 그룹에, 가입하거나 탈퇴할 때 사용되는 프로토콜

클라이언트-서버 모델이란?
- 서비스 요청자인 클라이언트와 서비스 제공자인 서버 간에 작업을 분리해주는 네트워크 아키텍처.
- 중앙집권 형태

P2P모델이란?
- 서버/클라이언트의 개념 없이 모든 피어들이 클라/서버역활을 동시에 수행.
- PureP2P, Hybrid P2P, SuperPeer 총 3개의 방식이 존재.

바이트 정렬
- 메모리에 데이터를 저장할 때의 바이트 순서.
- 리틀엔디안 : 최하위 바이트부터 저장 (컴퓨터 친화적)
- 빅 엔디안 : 최상위 바이트부터 저장 (인간 친화적).
- 네트워크 장비들은 대부분 빅엔디안을 사용하기 때문에, IP와 Port는 빅엔디안으로 전달해야 한다.

도메인
- 사람이 기억하기 힘든 IP를 문자로 기억할 수 있도록 변경한 식별자. IP와 대응된다.

도메인 이름 서버(DNS 서버)
- 도메인과 IP를 기억하는 서버

도메인 이름 시스템(DNS)의 작동 구조
- 재귀적 호출(Recursive Query) 절차.
- www.naver.com을 치는 순간 Local NS서버에게 www.naver.com의 IP를 아냐고 물어본다
- 해당 DNS서버는 자신이 가지고 있으면 바로 IP를 돌려준다.
- 없으면 루트 도메인에게 [www.naver.com은 어디있어?]라고 물어본다. ->루트는 [.com]의 DNS 서버를 알려준다.
- .com에게 www.naver.com을 아냐고 물어본다. -> .com은 [naver.com]의 DNS 서버를 알려준다.
- naver.com에게 [www.naver.com]을 아냐고 물어본다 -> naver.com은 IP를 돌려준다.

- IP를 알아온 Local NS는 Client에게 IP를 돌려준다. 그리고 클라는 해당 IP로 접속된다.
- 나머지는 그 웹서버의 영역....

- Local NS는 천천히 www.naver.com을 캐싱해두며, TTL(Time To Live)만큼 유지된다. TTL이 0이되면 레코드에서 삭제된다. 

소켓의 프로토콜이 설정되는 시점
- socket()함수로 소켓 생성 시

지역 IP와 지역 포트가 결정되는 시점
- bind()함수가 호출될 때

포트 상태가 LISTENING이 되는 시점
- listen()함수를 호출할 때

서버에 접속한 원격 IP와 원격 포트를 알 수 있는 시점
- accept라 리턴된 후 구조체 확인.

클라이언트 입장에서 IP와 Port가 결정되는 순간
- connect 함수 호출 시 지역,원격 Ip와 Port가 모두 결정
- 클라에서도 bind를 사용해 IP와 Port를 바인딩할 수 있다.

send함수 리턴 시점
- 소켓 송신버퍼에 데이터 복사 후 리턴. 실제 전송은 TCP에서 알아서 해준다.

커넥트 함수의 리턴 시점
- 서버가 listen중이며, 백로그에 공간이 있다 : 백로그 큐에 들어간 후 성공 리턴 (accept를 안해도 백로그 큐에 들어가면 리턴)
- 서버가 listen중이며, 백로그가 가득 찼다 : 즉시 실패 리턴
- 서버가 listen중이 아니다 : 20초 대기하다가 리턴
- 서버의 방화벽이 닫혀있다 : 20초 대기하다가 리턴
- 서버로 쓸 PC가 꺼져있다 : 20초 대기하다가 리턴

window size
- TCP에서, 상대의 수신 여유 공간이 얼마인지 알려주기 위함. 소켓 수신버퍼 사이즈를 의미
- TCP는 이 사이즈를 보고 패킷 보내는 크기?를 조절한다.
- 강제로 0으로 설정해도, 통신을 하다보면 서서히 늘어난다.

데이터 전송방식의 종료
- 고정길이 데이터 전송방식 : 송신자가 항상 고정된 길이의 데이터를 보낸다. 수신자도 고정된 길이를 받는다.
- 가변길이 데이터 전송 방식 : 송신자는, 데이터 가장 마지막에 '여기까지가 데이터다'라고 표시한다. 수신자는 마지막 표식이 나올때까지 읽는다.
- 고정길이 + 가변길이 전송 방식 : 고정 길이로 가변길이의 사이즈를 보내고, 뒤에 가변길이를 보낸다. 수신자는 고정길이를 읽은 후, 그 사이즈만큼 가변길이를 읽는다.
- 보낸 후 종료 : 송신자는 데이터를 보낸 후 종료한다. 수신자는 데이터를 읽다가 정상종료(recv 리턴값 0)가 될 때 까지 읽는다.

데이터 전송 시 고려사항
- 바이트 정렬, 구조체 멤버 맞춤 고려 (Byte 버퍼를 사용하면 고민할 필요 없음)

구조체 멤버 정렬을 사용하는 이유
- 주로 네트워크 송/수신 시 사용하며, 트래픽 자체가 돈이기 때문에 패킷 크기를 작게 하기 위해 사용한다.
- 같은 프로세스에서 사용하면 오히려 정렬 깨져서 더 느리거나 이상한 작동을 할 수도 있다.

MMU란?
- CPU에 있는 하드웨어. 물리 메모리와 가상 메모리를 맵핑시켜 준다. (Memory Mapping Unit)







