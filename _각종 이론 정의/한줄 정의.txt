호스트란?
- 응용프로그램을 수행하는 주체. 

라우터란?
- 서로 다른 네트워크에 속한 호스트간 데이터를 교환할 수 있게 하는 장비

통신 프로토콜
- 호스트와 라우터, 라우터와 라우터, 호스트와 호스트가 통신하기 위한 절차와 방법.

OSI 7계층
- 응용 계층
- 표면 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

TCP/IP 4계층
- 응용 계층 - 최종 목적지.
- 전송 계층 - 포트를 이용해 최종 통신 목적지에게 전달.
- 인터넷 계층 - 논리주소를 이용해 데이터를 목적지 호스트까지 전달.
- 네트워크 인터페이스 계층 - 물리 네트워크를 통한 실제 데이터 송수신 담당

TCP/IP 4계층을 지날 때 마다 무슨일이 발생하는가?
- TCP헤더(포트) / IP 헤더(IP) / 이더넷 헤더(MAC주소)를 붙인다.

TCP란?
- 연결 지향의 통신 프로토콜
- 데이터 경계가 없다.
- 신뢰있는 데이터 전송 보장

UDP란?
- 비연결 지향의 통신 프로토콜
- 데이터 경계가 있다.
- 신뢰없는 데이터 전송.

IP주소란?
- 각 통신 장치에, 부여되는 주소. Ipv4와 Ipv6가 존재한다.

포트란?
- 통신의 종착점을 나타내는 식별자. 한 번에 하나만 열 수 있다.
- 1개의 프로세스가 2개의 포트를 열 수도 있다.

소켓이란?
- 운영체제의 TCP/IP에서 생성한 데이터 구조체를 참조하기 위한 매개체
- 프로토콜, 목적지/출발지 IP, 목적지/출발지Port로 구분. 데이터 구조체 생성 시 논페이지드 메모리 영역을 먹는다.
- accept함수가 리턴하기 전에 백로그 큐를 보고 connect 패킷이 있으면 소켓을 만들어서 위 5개 정보 할당 후, 그 소켓에 접근할 수 있는 값을 리턴해준다.

백로그 큐
- 연결요청 대기 큐. listen함수 호출 시 설정 가능하며, SOMAXCONN(Socket Max Connect)로 하면 OS가 알아서 설정한다.
- 윈도우에서는 200이다.

루프백 주소
- 127.0.0.1으로 자기 자신을 의미하는 주소이며, 패킷이 PC 외부로 아예 나가지도 않는다.

TCP와 UDP의 차이점
- TCP는 연결형 / UDP는 비연결형
- TCP는 신뢰있는 전송 / UDP는 신뢰 없는 전송
- TCP는 1:1통신 / UDP는 1:1, 1:n 통신 둘다 제공
- TCP는 데이터 경계 없음 / UDP는 데이터 경계 있음

데이터 경계란
- 10바이트를 3번 보냈을때, 경계가 있을 경우(UDP) recv하는 쪽도 10바이트씩 3번 받아야 함
- 경계가 없을 경우, 네트워크 상황에 따라 recv한 번에 30바이트를 받아올 수도 있다.

유니캐스트
- 1:1전송

멀티캐스트
- 1:그룹 전송

애니캐스트
- 1: 그룹 전송. 가장 가까운 1명에게만 보내면, 그 1명이 자신이 속한 그룹의 나머지 유저에게 패킷 보냄
- IPv6에서만 지원

브로드 캐스트
- 1:특정 네트워크의 모든 개체
- 이론상으로는 외부 네트워크에도 가능하지만, 실제로는 라우터를 통과하지 못하기 때문에 내부 네트워크만 가능
- IP는 가장 큰 수. 192.0.0.0일 경우, 192.255.255.255. 192.168.0.0일 경우, 192.168.255.255
- IPv6은 지원하지 않음

ARP
- 목적지 IP를 이용해, 현재 이 데이터가 다음으로 가야할 장치를 알아온다. (브로드 캐스팅)
- 해당 ARP를 뿌리는 장치의 내부 네트워크에 대상이 있다면, 대상의 MAC주소를 알아온다.
- 없다면 gateway가 자신의 MAC주소를 응답해준다.

ICMP(Internet Control Message Protocol)
- TCP기반 통신 중, 전송과정에 문제가 생기면 이 패킷에 의해 메시지가 송신 쪽으로 돌아온다.
- 즉 오류 생길 시 송신쪽으로 알려주는 용도

IGMP(Internet Group Management Protocol)
- 멀티캐스트에 사용되는 그룹에, 가입하거나 탈퇴할 때 사용되는 프로토콜

클라이언트-서버 모델이란?
- 서비스 요청자인 클라이언트와 서비스 제공자인 서버 간에 작업을 분리해주는 네트워크 아키텍처.
- 중앙집권 형태

P2P모델이란?
- 서버/클라이언트의 개념 없이 모든 피어들이 클라/서버역활을 동시에 수행.
- PureP2P, Hybrid P2P, SuperPeer 총 3개의 방식이 존재.

바이트 정렬
- 메모리에 데이터를 저장할 때의 바이트 순서.
- 리틀엔디안 : 최하위 바이트부터 저장 (컴퓨터 친화적)
- 빅 엔디안 : 최상위 바이트부터 저장 (인간 친화적).
- 네트워크 장비들은 대부분 빅엔디안을 사용하기 때문에, IP와 Port는 빅엔디안으로 전달해야 한다.

도메인
- 사람이 기억하기 힘든 IP를 문자로 기억할 수 있도록 변경한 식별자. IP와 대응된다.

도메인 이름 서버(DNS 서버)
- 도메인과 IP를 기억하는 서버

도메인 이름 시스템(DNS)의 작동 구조
- 재귀적 호출(Recursive Query) 절차.
- www.naver.com을 치는 순간 Local NS서버에게 www.naver.com의 IP를 아냐고 물어본다
- 해당 DNS서버는 자신이 가지고 있으면 바로 IP를 돌려준다.
- 없으면 루트 도메인에게 [www.naver.com은 어디있어?]라고 물어본다. ->루트는 [.com]의 DNS 서버를 알려준다.
- .com에게 www.naver.com을 아냐고 물어본다. -> .com은 [naver.com]의 DNS 서버를 알려준다.
- naver.com에게 [www.naver.com]을 아냐고 물어본다 -> naver.com은 IP를 돌려준다.

- IP를 알아온 Local NS는 Client에게 IP를 돌려준다. 그리고 클라는 해당 IP로 접속된다.
- 나머지는 그 웹서버의 영역....

- Local NS는 천천히 www.naver.com을 캐싱해두며, TTL(Time To Live)만큼 유지된다. TTL이 0이되면 레코드에서 삭제된다. 

소켓의 프로토콜이 설정되는 시점
- socket()함수로 소켓 생성 시

지역 IP와 지역 포트가 결정되는 시점
- bind()함수가 호출될 때

포트 상태가 LISTENING이 되는 시점
- listen()함수를 호출할 때

서버에 접속한 원격 IP와 원격 포트를 알 수 있는 시점
- accept라 리턴된 후 구조체 확인.

클라이언트 입장에서 IP와 Port가 결정되는 순간
- connect 함수 호출 시 지역,원격 Ip와 Port가 모두 결정
- 클라에서도 bind를 사용해 IP와 Port를 바인딩할 수 있다.

send함수 리턴 시점
- 소켓 송신버퍼에 데이터 복사 후 리턴. 실제 전송은 TCP에서 알아서 해준다.

커넥트 함수의 리턴 시점
- 서버가 listen중이며, 백로그에 공간이 있다 : 백로그 큐에 들어간 후 성공 리턴 (accept를 안해도 백로그 큐에 들어가면 리턴)
- 서버가 listen중이며, 백로그가 가득 찼다 : 즉시 실패 리턴
- 서버가 listen중이 아니다 : 20초 대기하다가 리턴
- 서버의 방화벽이 닫혀있다 : 20초 대기하다가 리턴
- 서버로 쓸 PC가 꺼져있다 : 20초 대기하다가 리턴

window size
- TCP에서, 상대의 수신 여유 공간이 얼마인지 알려주기 위함. 소켓 수신버퍼 사이즈를 의미
- TCP는 이 사이즈를 보고 패킷 보내는 크기?를 조절한다.
- 강제로 0으로 설정해도, 통신을 하다보면 서서히 늘어난다.

데이터 전송방식의 종료
- 고정길이 데이터 전송방식 : 송신자가 항상 고정된 길이의 데이터를 보낸다. 수신자도 고정된 길이를 받는다.
- 가변길이 데이터 전송 방식 : 송신자는, 데이터 가장 마지막에 '여기까지가 데이터다'라고 표시한다. 수신자는 마지막 표식이 나올때까지 읽는다.
- 고정길이 + 가변길이 전송 방식 : 고정 길이로 가변길이의 사이즈를 보내고, 뒤에 가변길이를 보낸다. 수신자는 고정길이를 읽은 후, 그 사이즈만큼 가변길이를 읽는다.
- 보낸 후 종료 : 송신자는 데이터를 보낸 후 종료한다. 수신자는 데이터를 읽다가 정상종료(recv 리턴값 0)가 될 때 까지 읽는다.

데이터 전송 시 고려사항
- 바이트 정렬, 구조체 멤버 맞춤 고려 (Byte 버퍼를 사용하면 고민할 필요 없음)

구조체 멤버 정렬을 사용하는 이유
- 주로 네트워크 송/수신 시 사용하며, 트래픽 자체가 돈이기 때문에 패킷 크기를 작게 하기 위해 사용한다.
- 같은 프로세스에서 사용하면 오히려 정렬 깨져서 더 느리거나 이상한 작동을 할 수도 있다.

TCP와 UDP의 공통점
- 포트 번호를 이용해 주소 지정
- 데이터 오류 체크 : UDP도 데이터 오류는 체크한다. 다만, 오류 발생 시 재전송 등을 안하고 그냥 패킷 버림.

서브넷 마스크
- 1개의 네트워크에 서브넷 마스크를 추가해 2개 이상의 네트워크로 만드는 방법
- IP주소의 낭비를 줄이기 위한것.
- 분리된 네트워크는 라우터를 통해서만 통신 가능

소켓 옵션
- 소켓 레벨, IP레벨, TCP레벨 총 3개의 옵션 설정 가능

소켓 옵션의 소켓 레벨
- 브로드 캐스트 작동 여부
- recv/send 버퍼 사이즈
- KeepAlive 작동 여부
- Linger 작동 여부
- recv/send 타임아웃 설정
- 소켓 재사용

소켓 옵션의 TCP 레벨
- Nagle 알고리즘 적용 여부 
- 기본은 작동중이며, 옵션으로 끌 수 있다.

네이글 알고리즘이란?
- 보낼 데이터가 있을 때마다 데이터를 보내는것이 아니라, 데이터가 MSS만큼 쌓이거나, 데이터에 대한 응답(ACK)가 도착하면 데이터를 보낸다.
- 장점 : 트래픽 감소.
- 단점 : 클라이언트 입장에서 응답성이 낮게 느껴질 수도 있다.

MSS
- Maximum segment Size의 약자이며, 실제 내가 보내고자 하는 패킷 사이즈(페이로드)
- 이더넷은 기본 1460

MTU
- Maximum Transmission Unit의 약자로, MSS, IP헤더크기, TCP헤더크기를 더한 값
- 라우터를 빠져나갈 때의 패킷 크기
- 이더넷에서는 1500(1460(MSS) + 20(IP헤더) + 20(TCP헤더)) 이다.

패킷 단편화
- 한 번에 보내야 하는 데이터가 MSS나 MTU보다 크다면, 패킷 단편화 발생
- 발생 시점 1 : 소켓 송신버퍼에서 TCP 계층으로 패킷을 내려보낼 때, MSS단위로 패킷 쪼개짐
- 발생 시점 2 : 1번 라우터 -> 2번 -> 3번 순으로 이동할 때, 최초 출발지 라우터(1번)는 MTU가 1500인데 중간지 라우터(2번)의 MTU가 1500보다 작을 경우, 패킷 쪼개짐. 라우팅 중 패킷이 쪼개질 경우, 받는 쪽(3번)의 라우터는 모든 패킷이 도착할 때 까지 기다리다가 도착하면 위로 올려보낸다.

TCP의 특징
- 흐름 제어 (슬라이딩 윈도우)
- 오류 제어 (재전송, 순서 보장)
- 혼잡 제어 (네이글, 슬로우스타트)

MSL
- Maximum segment Lifetime의 줄임말
- TCP 세그먼트가 네트워크에 존재하는 시간이며, TIME_WAIT의 간격을 결정함(2*MSL)

KeepAlive 사용 목적
- TCP는 논리적 연결이기 때문에, 데이터 연결이 없으면 상대가 다운되거나 전원이 끊어지는 등의 상황을 감지못한다.
- 이를 감지하기 위함.
- TCP에만 사용 가능

Linger란?
- closesocket함수의 리턴 시간 제어.
- TIME_WAIT 상태를 남기지 않기 위해서도 사용.
(TIME_WAIT상태 동안은 리소스를 계속 사용함과 동시에 포트도 사용 불가능 상태가 된다.)
- shutdown과 함께 적용 안됨
- TCP에만 사용 가능

Linger 작동 방법
- Off : closesocket함수 즉시 리턴. 남은 데이터는 백그라운드로 모두 보낸다. 기본 closesocket 작동법
- On / 시간 0 : closesocket함수 즉시 리턴. 상대에게 reset보냄. 송신버퍼 데이터 모두 삭제
- On / 시간 0이상 : 시간 동안 대기 후 closesocket 함수 리턴. 시간동안 데이터가 다 못갔으면 상대에게 reset. 남은 송신버퍼 데이터는 모두 삭제

TIME_WAIT이 안남으면 어떤 문제가?
- TIME_WAIT으로 바로 포트를 재사용 할 수 있으면, 기존에 레이턴시 등으로 아직 오지 못했던 패킷이 새로운 유저에게 갈 가능성.
- 이걸 방지

TCP의 특징
- 흐름제어 (슬라이딩 윈도우)
- 혼잡제어 (네이글, 슬로우스타터)
- 오류제어 (재전송, 순서보장)

TCP 통신 중, 송/수신 버퍼 사이즈를 변경할 경우 문제점
- TCP는 슬라이딩 윈도우로 통신하기 때문에, 사이즈가 변화하게 되면 데이터가 갑자기 몰려오거나 공간이 부족해지는 등의 알 수 없는 문제가 발생할 수 있다.

논블락 단점
- 높은 CPU 사용율

이상적인 소켓 입출력 모델
- 소켓함수 블로킹이 없어야 함
- 스레드 개수가 적당한 수준으로 유지
- 코드 실행(CPU 명령 수행)과 입출력 작업 동시진행
- 유저모드 / 커널모드 전환 횟수 최소화

소켓 입출력 모델의 종류
- Select
- WSAAsyncSelect
- WSAEventSelect
- Overlapped
- IOCP

Select 모델
- 동기 입출력
- 단일스레드 전용 모델
- 소켓 함수 호출 성공시점을 미리 알 수 있다.
- 읽기 셋 : accpet(접속한 클라가 있을 경우), Recv(받은 데이터가 있을 경우), Recv(TCP연결이 종료된 경우)
- 쓰기 셋 : Send(송신 버퍼 여유공간이 있을 경우)
- 예외 셋 : Recv(OOB 데이터가 도착한 경우)
- 한 번에 최대 FD_SETSIZE(64)만큼의 소켓 처리 가능

Select 모델 논블락 Connect
- 일단 connect 시도 후, 쓰기셋과 예외셋에 connect 소켓을 넣은 후 Select를 한다.
- 쓰기 셋 : connect 성공
- 예외 셋 : connect 실패

Select 모델 에러 발생 시점
- Select로 이상한 소켓을 전달하면 에러가 발생한다. (소켓 셋에 3개 다 NULL을 넣거나 소켓이 아닌걸 넣을 경우)
- 이 외에는 에러 발생한 적 없음

WSAASyncSelect 모델
- 비동기 입출력으로 단일스레드로도 여러 소켓을 처리 할 수 있다.
- 함수 호출 성공 시점을 윈도우 메시지 형태로 받는다.

WSAASyncSelect 모델 작동법
- 관심있는 작업(Recv/Send/Accept 등..)을 등록해두면 커널이 윈도우 메시지 형태로 결과를 알려준다.

WSAASyncSelect 모델 유의점
- 메시지 발생 시, 적절한 함수를 호출하지 않으면 다음번에는 같은 윈도우 메시지가 발생하지 않음.

WSAEventSelect 모델
- 동기 입출력이며, 단일스레드로도 여러 소켓 처리 가능
- 함수 호출 시점을 Event를 통해 알 수 있다.

WSAEventSelect 모델 작동법
- 관심있는 이벤트(Recv/Send/Accept 등..)를 등록해두면, 가능 상태일 때 이벤트를 signaled 상태로 변경.

WSAEventSelect 모델 유의점
- 이벤트 발생 시, 적절한 함수를 호출하지 않으면 다음번에는 같은 이벤트가 발생하지 않음.
- WSAWaitForMultipleEvent에서 최대로 대기 가능한 이벤트는 64개이다.

WSAAsyncSelect /  WSAEventSelect 모델에서 FD_WRITE가 뜨는 상황
- 보낼 수 없다가 보낼 수 있는 상황이 될 때.
- Connect 성공 시. 이 때는, FD_CONNECT가 먼저 뜨고, 뒤 이어 FD_WRITE도 뜬다.
- send()함수에서 WSAEWOULDBLOCK이 뜬 후. (우드블럭이 뜬건 송신버퍼가 꽉찼다는건데, 꽉찼다가 빈 상태가 됐으니 당연히 떠야함)

동기 입출력과 비동기 입출력
- 동기 입출력 : 함수 리턴시점 == 요청 작업 완료 시점
- 비동기 입출력 : 함수 리턴시점 != 요청 작업 완료 시점

블락과 논블락
- 블락 : 함수 리턴조건 불만족 시 스레드 블락.
- 논블락 : 함수 리턴조건 불만족 시에도 함수 즉시 리턴. 함수 리턴되면서 WSAEWOULDBLOCK 발생


중첩 IO의 의미
- 기존의 I/O가 완료되지 않아도 새로운 I/O를 중첩해서 요청할 수 있다는 것.

Overlapped I/O모델(1) 작동법
- 비동기 입출력
- 이벤트를 사용하며, 요청한 비동기 작업 완료 후 운영체제가 작업 완료 후 Event를 신호상태로 변경한다.
- 운영체제가 작업 완료  응용프로그램으로 알려주는것이 핵심!!
- 이전 모델들은 모두, 함수 호출 성공시점을 알려줬을 뿐 작업을 요청하고 완료를 알려준 것이 아님!!

Overlapped I/O모델(1) 사용 이유
- 데이터를 보내고 받는 작업을 효율적으로 처리하기 위함.

WSASend / WSARecv의 특징
- Scatter(스켓터)와 Gather(게터)를 지원한다.
- 이는, 모아 보내거나(Gather) 흩뜨려 받을 수 있다(Scatter)는 의미.

비동기 입출력 작동법
- WSASend나 WSARecv를 호출했을 때, 수신버퍼에 데이터가 있거나 송신버퍼 사이즈가 있을 경우 동기처럼 작동한다. (소켓 송/수신버퍼에 데이터 복사 후 리턴)
- 위 상황이 아니면, 유저모드 메모리에 락 걸고 해당 메모리 주소 저장 후(8바이트) 에러 리턴. 에러는 I/O pending 이다


Overlapped I/O모델(2) 작동법
- APC 큐를 사용하는 비동기 입출력 모델
- 요청한 비동기 입출력 작업이 끝나면 운영체제는, 관련 내용을 APC큐에 저장한다.
- 그리고, CompletionToutine 함수를 등록한 스레드가 alertable wait 상태가 되면 APC큐에 저장된 내용을 기준으로, 등록한 완료 루틴이 실행된다.
- 완료루틴은 WSARecv / WSASend에 등록한다.

APC 큐
- 커널 모드에 존재한다.
- 넣는것은 누구든 넣을 수 있지만, 실제 해당 큐에 내용을 체크해 실행하는 것은 스레드 자기 자신만 가능

alertable wait 상태
- 알람 가능한 상태라는 의미이며, APC큐에 있는 내용을 처리 가능한 시점을 의미한다.
- SleepEX, WaitForSingleObjectEx 등 각종 EX함수로 가능.
- 예를 들어 SleepEX(1000, TRUE)로 하면 1초동안 alertable wait 상태가 되며, 이 상태일 때는 APC큐에 처리할 것이 있으면 처리한다. 처리할 것이 없으면 1초동안 잠만 잔다. 
- 예를 들어 0.9초가 되는 시점에 APC큐에 데이터가 들어온다면, 0.1초동안 완료 루틴을 실행하다가 SleepEX()가 리턴된다.


IOCP란?
- 비동기 입출력을 제공하며, 입출력 결과와 결과 처리 스레드를 가지고 있는 구조.
- 내부에는 [장치 큐 / 결과 큐 / 대기 스레드 큐 / 사용중 스레드 큐 / 잠시멈춤 스레드 큐] 총 5가지로 이루어진다.
- IOCP 생성 시, 위 5개의 큐가 만들어진다.

IOCP 장점
- 비동기 입출력과 함께 합리적인 스레드 풀링을 제공한다.

IOCP에 함수 등록 방법
- GQCS 함수 호출 시 해당 스레드는 IOCP 결과 처리 스레드로 등록되며, 대기 스레드 큐에 들어간다.

GQCS의 리턴값
- FALSE일 경우 : Overlapped구조체가 NULL이면 IOCP 내부 에러
- FALSE일 경우 리턴값을 받아도 할게 없다. 

컨커런트 모델 / 시리얼 모델
- 컨커런트 모델 : 아파치와 같은 구조. 접속 1개에 스레드 1개 생성
- 시리얼 모델 : 스레드 1개가 모든 접속을 처리하는 구조. Select 등...


GUI 응용 프로그램의 특징
- 메시지 구동 구조(이벤트 드리븐 구조)
- 커널에서 관리하는 시스템 메시지 큐가 존재하며, 운영체제는 이 큐에 쌓이는 이벤트 내용을 응용프로그램 각자가 할당받는 응용 프로그램 메시지 큐에 전달한다.

메시지 핸들러
- 메시지를 받았을 때 동적을 결정하는 코드

윈도우 프로시저란?
- 메시지 핸들러의 집합
- 메시지 처리코드를 담고 있는 사용자 정의 함수
- 콜백 함수

콜백 함수란?
- 내가 호출하지 않고 운영체제가 호출해주는 함수.

메시지 루프
- Winmain에 존재하는 메시지 처리 루프. 총 3개의 함수로 구성
- GetMessage : 시스템 메시지 큐에서 운영체제 메시지 큐로 메시지를 읽어들임. WM_QUIT일 경우 false 리턴
- TranslateMessage : GetMessage로 읽은 메시지가 키보드 입력메시지일 경우, 가공해서 프로그램에서 사용할 수 있도록 한다.
- DispatchMessage : GetMessage로 읽은 메시지를 윈도우 프로시저로 전달한다.



헤더와 CPP 분리 이유
- 헤더와 CPP가 1개의 파일에 있으면, 해당 파일을 include할 때 오래 걸린다 ---> 컴파일 시간 증가
- 헤더의 인터페이스만 제공해 사용자로 하여금 CPP를 몰라도 되도록 한다.


프로세스란?
- 코드,데이터,리소스를 파일에서 읽어들여 주소공간에 올려둔 일종의 컨테이너

스레드란?
- 프로세스가 할당받은 자원을 사용하는 실행의 단위.
- 실제로 CPU에게 시간을 할당받아 프로세스 주소공간에 있는 코드를 실행하고 데이터를 사용.

스택이란
- 함수 호출 시 생성되는 지역변수와 매개변수가 저장되는 공간

힙 이란
- 동적 메모리 할당을 위한 공간.

스레드의 실행상태
- CPU 레지스터와 메모리 스택을 의미한다.

프로세스와 스레드의 차이점은?
- 위 2개를 이야기한다.

컨텍스트 스위칭이란?
- 현재 CPU가 실행중인 스레드를 멈추고 다른 스레드가 일을 할 수 있도록 전환하는 작업.
- 기존 스레드의 레지스터와 새로 올릴 스레드의 레지스터를 교환한다.
- 레지스터만 교환된다!! 

Sleep(0)와 switchToThread의 공통점
- 현재 나의 타임슬라이스를 포기한 후 다른 스레드에게 남은 시간을 양도한다 
- 15.6m/s중 10m/s만 쓴 후에 위 함수를 호출하면 남은 5.6m/s를 다른 스레드가 일한다

Sleep(0)와 switchToThread의 차이점
- switchToThread는 자신이 실행중이던 프로세서의 ready상태 스레드 중 하나에게 양보한다. ready스레드가 아무도 없다면 자신이 다시 올라온다.
- Sleep(0)은 자신이 실행중이던 프로세서 외 다른 프로세서의 스레드 중 ready상태의 스레드 하나를 골라 양보한다.
만약, 모든 프로세서에 ready중인 스레드가 하나도 없으면 자신이 다시 올라온다.
- 과거의 Sleep(0)은 자신보다 우선순위가 높거나 같은 스레드가(자신이 3이면 0~3까지) ready에 있을 경우 양보했으며, 없을 경우 자기 자신이 다시 올라왔다.

스레드 생성 시 주의점
- _beginthreadex()를 사용해야한다.
- 왜냐하면 기존의 CreateThread는 C런타임 라이브러리 사용 시 스레드 safe하지 않기 때문이다.
- _beginthreadex()를 사용하면 tid 데이터 블록이 생성된다. 이 블록이 C런타임 라이브러리를 안전하게 사용할 수 있도록 해준다.

스레드 종료 방법
- 스레드 함수가 리턴
- ExitThread()함수 호출	-	비정상
- TerminateThread()함수 호출	- 비정상

스레드 종료 방법 중 정상적인것은?
- 스레드 자신이 종료하는것이 좋음.
- 왜냐하면, class의 소멸자는 스코프 종료 시점에 코드가 박히기 때문에, 스레드를 강제로 종료하면 해당 코드를 실행하지 않고 나간다. 그러면 어떻게 작동할지 모름
- 그리고 동적할당한 메모리도 보통 return 전에 해제할텐데 누수도 난다.

스레드 우선순위란?
- 스케쥴러가 CPU로 올릴 스레드를 선택하는 기준. 우선순위가 높은 스레드가 먼저 선택된다.
- 프로세스 우선순위(우선순위 클래스) : 프로세스의 속성이며, 이 프로세스의 스레드는 모두 우선순위 클래스가 같음
- 스레드 우선순위(우선순위 레벨) : 스레드 속성.
- 이 2개를 합쳐 기본 우선순위가 결정된다.

기아현상이란? (starvation)
- 계속 높은 우선순위의 스레드만 CPU를 할당받아 우선순위가 낮은 스레드는 일을 하지 못하는 상황
- 이를 방지하기 위해, OS는 오랜시간 CPU시간을 할당받지 못한 스레드의 우선순위를 서서히 끌어올린다.

컴파일 최적화기능은?
- 컴파일러가 최적의 속도를 낼 수 있도록 합리적으로 기계어를 만들어내는 기능
- 단점은, 내가 원하는대로 작동하지 않을 수도 있다.
- Debug모드에서는 적용되지 않는다.

volatile이란?
- 컴파일에게 이 변수만큼은 최적화 하지 말라는 명령
- 레지스터에 있는 값에 바로 접근하는게 아니라 실제 물리메모리에서 값을 가져오도록 한다. (레지스터를 쓰긴 함)

DLL 맵핑
- 기본적으로 DLL은 자신이 맵핑되고 싶은 가상메모리 주소가 있다. (예를 들어 0x10000)
- 프로세스 A에서는 가상메모리 0x10000이랑 물리메모리의 어딘가와 맵핑이 되었다.
- 근데 프로세스 B가 동일한 DLL을 가상메모리 0x10000과 맵핑하기 싶은데 이미 누군가가 0x10000을 사용 중일 경우, 프로세스 B를 위해 해당 DLL이 다시 물리메모리로 올라오며, 그 물리메모리와 0x10000이 아닌 다른 가상주소와 맵핑된다.

MMU란?
- CPU에 있는 하드웨어. 물리 메모리와 가상 메모리를 맵핑시켜 준다. (Memory Mapping Unit)