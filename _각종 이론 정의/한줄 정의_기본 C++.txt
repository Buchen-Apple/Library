함수 오버로딩
- 동일한 이름의 함수를 매개변수가 다르게 선언한 것
- C++은 함수의 이름과 매개변수를 같이 보고 함수를 찾는다. 반환형은 전혀 관련 없다.

매개변수 디폴트 값
- 함수의 선언/정의를 분리했을 시 함수의 선언에만 위치해야 함. 정의부에 위치하면 에러
- 변수에 값을 전달하지 않으면 컴파일러가 지정된 값을 대신 넣어준다.

부분적 디폴트 값
- 함수의 일부 매개변수만 디폴트값 지정 가능. 
- 오른쪽 부터 정의되어야 함(컴파일러가 왼쪽부터 값을 채우기 때문에)

const를 이용한 함수 오버로딩
- 함수 이름 / 매개변수가 완전히 동일할 때, const가 붙으면 다른함수로 취급한다.

인라인 함수
- 컴파일 타임에 처리 (매크로는 전처리 시점에 처리)
- 매크로함수에 비해 정의하기 쉬움.
- inline을 해도 컴파일러가 무시하기도 함. 반대로 컴파일러가 인라인 시키기도 함

인라인 함수의 단점
- 매크로 함수는, 다양한 자료형을 1개로 표현 가능
- 인라인은, 자료형 종속
- 템플릿을 사용하면, 자료형 종속적이지 않게 가능

컴파일 최적화
- 컴파일 최적화를 끄면, 컴파일러는 인라인 함수를 사용하지 않는다.

이름 공간(namespace)의 장점
- 함수 이름, 변수 이름 중복에서 자유로워진다.

이름공간 적용 범위
- 지역변수와 적용범위 동일.
- { } 를 벗어나면 적용되지 않음. 전역으로 하면 전체적용됨

이름공간 별칭 지정
- AAA::BBB::CCC::num1 = 20 << 이걸 namespace ABC=AAA::BBB::CCC;로 하면 ABC::num1=20 으로 접근 가능

범위지정 연산자(::) 또하나 역활
- 전역변수/지역변수의 이름이 동일할 때, 지역변수만 접근 가능.
- 범위지정 연산자를 사용하면 전역변수 접근 가능
- ::val 을 하면 전역의 val에 접근

true/false와 TRUE/FALSE의 차이
- true/false는 참과 거짓을 표시하는 키워드
- TRUE/FALSE는 참과 거짓을 표시하는 정수
- true/false는 sizeof하면 1, TRUE/FALSE는 sizeof하면 4(정수 상수는 기본적으로 int형)

참조자
- 메모리공간에 붙은 또 하나의 이름
- 새로 선언하는 변수 앞에 &가 오면 참조자가 된다.
- int &a = num1;과 같이 사용.

참조자 특징
- 선언과 동시에 누군가를 참조해야 함. 선언 후 나중에 참조하기 이런거 없음
- 기존에 존재하는 메모리 공간에 이름을 붙인다. 때문에 변수에만 사용 가능 (상수 사용 불가. NULL도 상수이기 때문에 불가)
- 참조자 수 제한 없음
- 참조자를 대상으로 참조자 선언 가능

배열의 요소를 참조자로 가리키기
- int arr[3]에서 arr[0]과 같은 요소는 일반 변수이기 때문에 그냥 가리키면 된다.
- int &ref = arr[0];

배열을 참조자로 가리키기
- 배열의 요소가 아니라 배열 자체를 참조자로 가리키기 위해서는, 길이를 같이 전달해야 한다.
- 1차원 배열은 [int arr[3];       int (&ref)[3] = arr;]
- 2차원 배열은 [int arr[3][10];	  int (&ref)[3][10] = arr;] 처럼 가로 세로를 모두 전달해야 함

포인터를 참조자로 가리키기
- int *ptr = &num;	 int *(&pref) = ptr; << 이건 int* &ref = ptr처럼 괄호 없어도 됨.
- int **pptr = &ptr;   int **(&ppref) = pptr; << 마찬가지. 괄호 없어도 됨.

함수 매개인자로 참조자를 쓸 수 있는 이유
- 매개변수는 함수가 호출되어야 초기화 되기 때문에.

참조자를 받는 call-by-reference의 문제점
- 코드 분석이 힘들다
- int num=24; func(num); cout <<num;을 하면 C에서는 무조건 24
- 그럼 C++에서는? func의 매개변수가 참조자 일 수도 있기 때문에, 내부에서 값이 바뀔 수도 있다. 때문에 코드 분석 힘듬

참조자 call-by-reference를 어느정도 해결하는 방법
- 완벽한 해결은 불가능. 완벽하게 해결하려면 참조자 매개변수를 안써야함.
- const 키워드를 이용하면, 함수의 선언부만 봐도 [아 이 값은 변동 없는 값이구나]라는걸 어느정도 전달 가능

매개변수도 참조자, 반환형도 참조형일 경우
- 함수는, 매개변수로 받은 참조자를 이용해 값을 ++한 후 참조자 리턴.
- 리턴값을 받는쪽에서, 참조자로 받으면, 동일한 변수를 가리킬 수 있다. [int& num2 = func(num)]
- 리턴값을 받는 쪽에서, 일반 변수로 받으면 값만 저장된다. [int num2 = func(num) <<num은 1이었고 내부에서 1 증가. 그럼 num2는 2가 되고, num과는 아예 다른 변수가 된다)

잘못된 참조 반환
- 함수 내부에서 선언한 지역변수 num을, 참조자로 리턴하고 호출한 쪽에서 그걸 인자로 받는다면?
- 함수 종료 시점에 지역변수 num은 소멸되기 때문에, 밖에서는 이상한 공간을 참조할 수 있다.
- 참고로 위 상황에 컴파일러는 '경고 메시지'를 발생시키기 '오류 메시지'를 발생시키지 않음. 즉 컴파일 가능

리터럴 상수, 임시객체, 임수 변수 소멸 시점
- 리터럴이나 임시객체나 임수변수 등도 연산을 위해서는 메모리에 올라가야한다. 그래서 공간이 할당된다(data 영역)
- 코드 다음행으로 넘어가면 소멸된다.
- 하지만, 다음행으로 넘어가기 전에 누군가가 가리킨다면, 소멸되지 않는다.

const 참조자
- const 변수를 참조할 수 있다.  [const int aa=10; const int& ref = aa; ]
- 상수도 참조할 수 있다. [const int& ref = 10]
- 객체를 const 참조자로 참조할 경우, const 함수만 호출 가능하다.

const 객체
- const 멤버함수만 호출 가능
- const 멤버변수는 애초에 선언과 동시에 초기화되어야 하기 때문에 해당사항 없음. public const 변수라고 해도, 이미 생성될때는 값이 초기화되어있어야 함.

const 참조자는 NULL은 가리킬 수 있고 nullptr은 안된다.

임시 변수가 필요한 이유
- 편의성
- func(const int& ref1);	func(1) <<<이게 가능하다.

malloc&free / new&delete의 차이점
- 생성자/소멸자 호출 여부

일반 new와 배열 new의 차이점
- 배열 new로 객체를 생성할 경우, 메모리 앞에 생성한 객체의 수를 저장해둔다.
- 그리고 나중에 배열 delete로 해제할 경우 그 수만큼 돌면서 소멸자가 호출된다.

C의 헤더를 C++ 스타일로 선언해야 하는 이유
- C++로 오면서 새로 추가된 문법(함수 오버로딩 등..)등을 사용해 개선된 형태로 라이브러리가 정의되어 있음

클래스 안에 enum
- 해당 클래스에서만 유효하다.

구조체/클래스 내부의 함수 인라인
- 멤버함수는 자동으로 인라인 처리된다. 
- 컴파일 최적화를 끄면 인라인 처리 안된다.

멤버 함수의 선언부 정의부 분리
- 선언부는 클래스 내부에, 정의부는 클래스 외부에 둔다.
- 하지만, 이렇게 분리되면 멤버 함수의 inline이 풀린다.
- 이 때는 정의부에 명시적으로 inline 명령어를 적으면 inline 처리된다.

클래스와 구조체의 차이점
- 키워드 차이
- 구조체는 기본 public / 클래스는 기본 private

클래스의 선언
- 클래스의 멤버변수와 멤버함수의 선언부가 모여있는 부분
- 컴파일 정보로 사용된다.
- 보통 헤더파일

클래스의 정의
- 클래스의 멤버함수 정의부가 모여있는 부분
- 보통 .cpp

인라인 함수는 헤더파일에 같이 넣어야 한다.
- 인라인 함수는 컴파일 타임에 호출부를 몸체로 변환하기 때문에.

객체지향 프로그래밍이란?(OOP. Object-Oriented Programming)
- 현실에 존재하는 사물과 그 행동을 실체화 시키는 프로그래밍

객체란?
- 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성
- 데이터와 기능으로 구성된다.
- 실제 생성자까지 호출되어야, 객체라 한다. 클래스 자체는 객체가 아니다.

객체 대화 방법
- 하나의 객체가 다른 객체에서 메시지를 전달하는 방법
- Message Passing(메시지 패싱)이라 한다.
- 결국엔 함수 호출이다.

const 함수
- 함수 내부에서, 멤버 변수에 저장된 값을 변경하지 않겠다는 것.( 매개변수, 지역변수도 아니며, '멤버변수' 이다. 잘 기억하자.)
- 클래스 내부에 멤버함수로 [int aaa() const {...}] 와 같은 형태로 선언
- const 함수 내부에서는, const함수만 호출 가능

객체지향의 속성
- 정보은닉 : 제한된 접근
- 캡슐화 : 관련있는것을 1개 클래스로 묶는다. 기본적으로 정보은닉 포함.
- 상속 : 코드 재사용, 코드 확장성
- 추상화 : 모델링
- 다형성 : 같은 타입이지만 실행결과가 다름

정보 은닉이란?
- 클래스 내부에, 제한된 방법으로 접근하도록 하는 것.
- 제한된 방법을 위해 엑세스 함수(Access function)을 정의한다. 해당 함수는 클래스의 멤버변수에 접근할 수 있다.
- 필요 이유 : 무분별하게 접근하면 내부의 데이터를 이상하게 변조할 수 있다.
- 목표 : 안전성 증가

캡슐화란?
- 관련있는 함수와 변수를 하나의 클래스 안에 묶는것
- 예로 코감기약. 내부에 코막힘 클래스/기침 클래스/ 가래 클래스를 1개의 코감기약 클래스로 만듬. 코감기약이 3개의 클래스를 멤버로 가지고 있음
- 필요 이유 : 코감기약을 순서대로 먹어야 할 경우, 모든 프로그래머는 그 순서를 알고있어야 함. 하지만 코감기약 클래스로 캡슐화를 하면 [코감기약 먹기] 함수만 호출해 안전하게 약먹기 가능
- 목표 : 안전성 증가

생성자
- 객체 생성 시 1번만 호출되는 함수
- 클래스의 이름과 함수이름이 동일
- 반환형 없음.
- 오버로딩 가능

객체 생성 시 주의점
- Test abc() <<이거 불가능
- 함수 선언문과 중복되기 때문이다.
- Test* abc = new Test() << 동적할당 할 때는 ()를 붙여서 사용하기 가능.

멤버 이니셜라이저
- 멤버변수로 선언된 객체의 생성자 호출에 사용

멤버 이니셜라이저의 장점
- cosnt 멤버변수 초기화 가능 
-> 이니셜라이저로 초기화되는 멤버는 선언과 동시에 초기화가 이루어진다. (바이너리 코드가 그렇게 됨)

- 성능 증가
-> 생성자 몸체에서 생성하면 생성한 객체에 대입한다. 2줄 [int a; a = 10]. 
-> 이니셜 라이저를 이용하면 선언과 동시에 초기화. 1줄 [int a=10;]

- 멤버변수로 참조자 사용 가능. 참조자도 선언과 동시에 초기화되어야 한다.

객체 생성 과정
- 메모리 공간 할당 
- 멤버 이니셜 라이저를 이용한 초기화 << 이니셜라이저가 선언되었을 경우
- 생성자 몸체부분 실행 << 무조건 실행. 생성자 없으면 디폴트 생성자 호출

객체 소멸 과정
- 소멸자 몸체 실행
- 메모리 공간 해제

const 상수 / const 변수
- 같은 의미.

디폴트 생성자
- 클래스 내부에 생성자가 하나도 없을때, 컴파일러가 자동으로 기본생성자를 만들어준다.
- 이를 디폴트 생성자라 한다.
- 생성자가 하나라도 있으면 안만들어줌

소멸자
- 객체 소멸시 자동 호출
- 반환형 없음.
- 오버로딩/디폴트값 설정 불가능

디폴트 소멸자
- 소멸자가 없을 경우, 기본적으로 추가되는 소멸자

객체 배열
- 객체를 담을 수 있는 배열 (저장 대상 : 객체)
- Test abc[10], Test *abc = new Test[10];
- 여전히 생성자가 호출되지만, 기본 생성자만 호출 가능하다 (인자를 전달하지 못하기 때문에)
- 기본 생성자가 없으면 컴파일 오류.

객체 배열 초기화 방법
- 객체마다 초기화 값이 동일하다면 기본생성자에서 하면 된다.
- 하지만 객체마다 다르다면, 생성 후 직접 초기화해야 한다.

객체 포인터 배열
- 객체의 포인터를 담을 수 있는 배열.  (저장 대상 : 객체 포인터)
- Test *abc[10]; 와 같이 선언

this 포인터
- 객체 자기 자신의 주소값.
- 주소값과 자료형이 정해지 있지 않은 포인터

this 포인터 사용 불가한 상황
- 멤버 이니셜라이저에서는 this 포인터 사용 불가능
- 대신, 멤버 이니셜라이저는 [Test(int num1, int num2)   : num1(num1), num2(num2)] 일 때, 괄호 안을 매개변수로 / 괄호 밖을 멤버변수로 자동 인식한다. 
- 즉, this->num1(num1), this->num2(num2) 인 것 처럼 인식한다(실제 이렇지는 않다)

Self-Reference
- Test& abc() { return *this }를 하면 자기 자신의 참조값 리턴 가능
- this는 포인터이고 가리키는 값은 나 자신이기 때문에 *this는 나 자신이다. 근데 반환형이 참조형이기 때문에 나 자신의 참조값이 리턴된다.

복사 생성자
- 객체를 인자로 받는 생성자
- 인자가 꼭 자기 자신일 필요는 없으며, 다른 객체도 인자로 받을 수 있다.
- Test(const &Test ref) {...} 와 같은 형태로 선언. 참조자 꼭 붙여야 한다!

복사 생성자에 참조자를 꼭 붙여야 하는 이유
- const는 필수는 아니다. 하지만 참조자는 필수이다.
- 이걸 안붙이면 무한루프에 빠진다.
- 복사생성자 호출 -> 매개변수 생성 시 인자로 넘어가는 객체의 복사 -> 생성자, 복사생성자 호출 -> 그 복사생성자 안에서 또다시 객체 복사 -> 복사생성자 호출 -> ... 무한반복 ...
- 참고로 복사생성자 매개변수로 &를 안하면 컴파일 에러 발생

디폴트 복사생성자
- 복사 생성자를 정의하지 않으면, 디폴트 복사생성자가 삽입된다.
- 디폴트 기본생성자는 하는게 없지만, 디폴트 복사 생성자는 멤버대 멤버 복사가 발생한다. 

explicit 키워드
- 자동 형변환을 막는다. 주로, 객체 생성 시 자동으로 형변환되는 것을 막는다.
- explicit Test(int n) {...} << 이렇게 하면 Test aa = 3 이게 불가능하다. explicit을 빼면 가능하다.

얕은 복사
- 멤버대 멤버 복사. 디폴트 생성자의 작동 방식을 의미

얕은 복사의 문제점
- 메모리 동적할당을 했을 시, 멤버대 멤버 복사는 한 공간을 각각 클래스가 가리킨다 (총 2개의 변수가 가리킴)
- 이 때, 하나의 클래스가 소멸되면서 소멸자에서 동적해제를 하면, 나머지 1개는 동적해제 된 공간을 가리킬 수 있다.

깊은 복사
- 새로 생성되는 객체가 직접 동적할당 후 메모리를 복사한다. 즉, 2개의 변수가 각각 다른 메모리를 가리키도록 한다.
- 멤버 뿐만 아니라 포인터가 가리키는 대상까지 복사.

복사 생성자 호출 시점 (총 3가지)
- 기존에 생성된 객체를 이용해 새로운 객체를 초기화
- Call-by-Value 방식의 함수 호출과정에서 객체를 인자로 전달
- 참조형/포인터가 아닌 객체를 반환

임시객체
- 객체 반환 시점에 임시로 만들어지는 객체. 임시변수와 동일한 개념인데 객체인것 뿐
- 임시 객체의 '참조 값'이 반환된다. 
- 때문에 누군가가 참조할 수 있다.

임시객체 생성 방법
- Test(10) << 이렇게하고 아무도 안받으면 그냥 임시객체.

임시객체 소멸 시점
- 코드 다음줄로 이동 시 소멸된다.
- 하지만, 코드 다음줄로 넘어가기전에 누군가가 가리킨다면(참조한다면) 소멸되지 않는다.

새로 생성되는 객체에게 임시객체를 대입할 경우
- Test ref = Test(10);
- 이 때, ref의 복사생성자 호출 안됨. 임시객체에 ref라는 이름을 붙이게 된다.
- 즉, Test(10)의 생성자만 호출되며 이때 리턴되는 임시객체에 ref라는 이름을 붙임

임시객체를 참조자로 가리키기
- Test& ref = Test(10); << 이거 불가능
- const Test& ref = Test(10) << 이렇게 해야 가능
- 왜냐하면, 참조자는 상수를 가리킬 수 있으며, 상수를 가리키는 참조자는 const 참조자.

friend 선언
- 나의 private/protected에 접근할 수 있게 해준다.
- 어디 영역이든 위치할 수 있다. (private / protected / public)
- class friend 선언 / 함수 friend선언이 가능하다.

함수의 friend 선언
- 해당 함수를 통해 클래스의 private/protected로 접근 가능
- 함수 원형 선언이 포함되어 있다.
- 클래스 friend도 원형 선언도 마찬가지.

static 멤버변수 (클래스 변수)
- 클래스당 1개만 존재하는 변수. 객체당 1개 아님!
- 객체 생성 여부와 관계 없이 메모리에 할당됨.
- 개체 외부에 존재하지만, 객체에서 접근할 권한만 존재

static 멤버변수 초기화 방법
- 클래스 외부에 int Test::변수이름 = 0처럼 초기화되어야 함.
- 만약 클래스 생성자에서 초기화하면, 객체가 생성될 때 마다 해당 값으로 초기화 발생..

static 멤버변수 다른 접근
- 스코프 연산자(::)를 이용해 접근 가능. Test::이름 <<으로 접근
- public으로 선언되어 있을 경우이다.

static 멤버함수
- static 멤버변수와 동일한 속성 (클래스 별 1개 / 사실 객체멤버 아님 / 생성 여부와 관계없이 존재)
- 내부에서는 static 멤버변수과 static 멤버함수 호출만 가능하다.

static 함수에서 static 멤버변수만 접근 가능한 이유
- 일반 멤버변수에 접근할 경우, 아직 초기화되지 않은 변수에 접근할 가능성

Mutable
- const 함수 내에서의 값 변경을 허용
- 변수 앞에 붙인다. (mutable int a)
- const의 기능을 제거할 수 있다. 조심히 사용하자.

컨트롤 클래스(핸들러 클래스)
- 기능의 처리를 담당하는 클래스
- 객체지향에서 반드시 존재하는 클래스

상속이란?
- 부모의 특성을 자식에게 물려주고, 자식이 자신만의 특성을 더해 새로운 클래스를 생성하는 방법.
- 코드 재활용, 코드 유연성, 코드 확장성

부모 객체 초기화
- 자식은 부모를 초기화해야 하는 의무가 있음

부모 생성자 호출 방법
- 명시적 호출 시 멤버 이니셜라이저 사용
- 명시적으로 호출하지 않을 시 부모의 기본 생성자가 호출된다. <<이게 되기 위해서는 부모의 기본생성자가 존재해야 함. 없으면 기본 문법 에러난다 (디폴트 생성자 포함)

자식 객체 생성 과정
- 메모리 할당
- 부모 클래스 초기화(생성자 호출) << :a(10), Test() 처럼 멤버 이니셜라이저에 부모 클래스 호출구문이 뒤에있어도, 무조건 부모 생성자 먼저 호출된다. 
- 멤버 이니셜라이저 호출
- 자식의 생성자 몸체 진행

부모가 먼저 초기화되는 이유
- 부모가 초기화 되어있지 않다면, 자식의 생성자 몸체를 실행하면서 부모의 멤버변수 등에 접근할 때 문제 발생 가능성.

자식 객체 소멸 과정 (생성의 역순)
- 자식의 소멸자 몸체 진행
- 부모의 소멸자 몸체 진행
- 메모리 해제

자식 입장에서 부모의 private
- 자식은 부모의 private 변수에 접근 불가.
- 상속은 된다. 다만 접근 불가능할 뿐

상속의 형태
- public << protected << private 순으로 접근범위가 높음
- public 상속 : public보다 접근 범위가 낮은 변수를 public으로 상속 (결국 부모의 있는 그대로 상속)
- protected 상속 : protected보다 접근 범위가 낮은 변수를 protected로 상속 (public은 protected가 됨)
- private 상속 : private보다 접근 범위가 낮은 변수를 private으로 상속 (public / protected 변수가 private이 됨)

상속의 형태 특이점
- 어떤 상속이든, 부모의 private은 [접근 불가]로 상속된다.
- private이 아니라 접근 불가이다.  자식은 부모에게 접근할 수 없기 때문이다(정보은닉)

상속의 조건
- IS-A 관계 : A는 일종의 B이다
- HAS-A 관계 : 소유 관계
- 상속은 IS-A 관계의 표현을 위한 수단.

UML (Unified Modeling Language)
- 통합 모델 언어. 다이어그램같은 것.








가상함수 테이블 생성 시점
- 컴파일 타임

가상함수 테이블 작동 매커니즘
- 함수 포인터 사용
- 내부적으로는 콜백 함수 매커니즘.

this 콜
- 멤버함수나 멤버변수에 접근할 때 사용되는 함수호출규약
- this를 ecx에 담고 그걸 호출.
- 기본적으로는 __stdcall이다.
- 하지만, 가변인자를 사용하는 함수 호출은 __cdecl을 따른다.

Test c; c + 10; <<이걸 성립시키기 위해서는?
- Test에 int를 인자로 받는 생성자가 존재해야 함
- double을 계산하고 싶어도 마찬가지

explicit 키워드
- 묵시적 형변환을 막는다.
- Test c; c+10을 막기도 하며, Test c = 3이 Test c(30)으로 변하는것도 막는다(Test c(30)만 되도록 한다)
- 애초에 C++스타일은 Test c(30)이다. =를 이용한 대입은 C++스타일이 아니다.

객체 대입 업캐스팅
- Super{}가 있고, 상속받는 Sub : public Super{}가 있다.
- 이때, 이미 생성된 Sub객체를 새로 생성하는 Super에 대입 가능? [Sub aa; Super bb = aa;] 아니 불가능.

객체 대입 업캐스팅 해결
- static_cast를 사용하면 가능 [Super bb = static_cast<Super>(aa);]
- dynamic_cast를 사용하면, 포인터만 가능 [Super* cc = dynamic_cast<Super*>(&aa);]

C와 완전히 동일한 캐스팅은?
- Reinterpret Cast

C++ 형변환 시 주의점
- 업 캐스팅은 언제나 안전. 다운 캐스팅은 언제나 위험

static cast와 dynamic cast의 차이점
- static cast는 컴파일 타임에 형변환 체크
- dynamic cast는 컴파일 타임에 형변환 체크

안전한 다운 캐스팅을 하려면?
- Dynamic_Cast를 사용
- 이유 : 클래스 생성 시, virtual table에 RTTI(런타임 타입 인포)가 저장된다. 때문에 런타임에 캐스팅을 체크하는 dynamic cast를 사용하면 RTTI를 확인해 안전한 캐스팅 가능
- 이유 : Dymamic_Cast는 런타임에 클래스 가상함수 테이블을 참조해 Type을 확인하기 때문에 안전한 다운캐스팅 가능

Dynamic cast에 참조형 vs 포인터 차이점
- 잘못된 형변환일 시
- 참조형 : bad_cast 예외 발생
- 포인터 : null 반환

