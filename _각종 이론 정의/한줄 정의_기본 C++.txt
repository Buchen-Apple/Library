함수 오버로딩
- 동일한 이름의 함수를 매개변수가 다르게 선언한 것
- C++은 함수의 이름과 매개변수를 같이 보고 함수를 찾는다. 반환형은 전혀 관련 없다.

매개변수 디폴트 값
- 함수의 선언/정의를 분리했을 시 함수의 선언에만 위치해야 함. 정의부에 위치하면 에러
- 변수에 값을 전달하지 않으면 컴파일러가 지정된 값을 대신 넣어준다.

부분적 디폴트 값
- 함수의 일부 매개변수만 디폴트값 지정 가능. 
- 오른쪽 부터 정의되어야 함(컴파일러가 왼쪽부터 값을 채우기 때문에)

const를 이용한 함수 오버로딩
- 함수 이름 / 매개변수가 완전히 동일할 때, const가 붙으면 다른함수로 취급한다.

인라인 함수
- 컴파일 타임에 처리 (매크로는 전처리 시점에 처리)
- 매크로함수에 비해 정의하기 쉬움.
- inline을 해도 컴파일러가 무시하기도 함. 반대로 컴파일러가 인라인 시키기도 함

인라인 함수의 단점
- 매크로 함수는, 다양한 자료형을 1개로 표현 가능
- 인라인은, 자료형 종속
- 템플릿을 사용하면, 자료형 종속적이지 않게 가능

컴파일 최적화
- 컴파일 최적화를 끄면, 컴파일러는 인라인 함수를 사용하지 않는다.

이름 공간(namespace)의 장점
- 함수 이름, 변수 이름 중복에서 자유로워진다.

이름공간 적용 범위
- 지역변수와 적용범위 동일.
- { } 를 벗어나면 적용되지 않음. 전역으로 하면 전체적용됨

이름공간 별칭 지정
- AAA::BBB::CCC::num1 = 20 << 이걸 namespace ABC=AAA::BBB::CCC;로 하면 ABC::num1=20 으로 접근 가능

범위지정 연산자(::) 또하나 역활
- 전역변수/지역변수의 이름이 동일할 때, 지역변수만 접근 가능.
- 범위지정 연산자를 사용하면 전역변수 접근 가능
- ::val 을 하면 전역의 val에 접근

true/false와 TRUE/FALSE의 차이
- true/false는 참과 거짓을 표시하는 키워드
- TRUE/FALSE는 참과 거짓을 표시하는 정수
- true/false는 sizeof하면 1, TRUE/FALSE는 sizeof하면 4(정수 상수는 기본적으로 int형)

참조자
- 메모리공간에 붙은 또 하나의 이름
- 새로 선언하는 변수 앞에 &가 오면 참조자가 된다.
- int &a = num1;과 같이 사용.

참조자 특징
- 선언과 동시에 누군가를 참조해야 함. 선언 후 나중에 참조하기 이런거 없음
- 기존에 존재하는 메모리 공간에 이름을 붙인다. 때문에 변수에만 사용 가능 (상수 사용 불가. NULL도 상수이기 때문에 불가)
- 참조자 수 제한 없음
- 참조자를 대상으로 참조자 선언 가능

배열의 요소를 참조자로 가리키기
- int arr[3]에서 arr[0]과 같은 요소는 일반 변수이기 때문에 그냥 가리키면 된다.
- int &ref = arr[0];

배열을 참조자로 가리키기
- 배열의 요소가 아니라 배열 자체를 참조자로 가리키기 위해서는, 길이를 같이 전달해야 한다.
- 1차원 배열은 [int arr[3];       int (&ref)[3] = arr;]
- 2차원 배열은 [int arr[3][10];	  int (&ref)[3][10] = arr;] 처럼 가로 세로를 모두 전달해야 함

포인터를 참조자로 가리키기
- int *ptr = &num;	 int *(&pref) = ptr; << 이건 int* &ref = ptr처럼 괄호 없어도 됨.
- int **pptr = &ptr;   int **(&ppref) = pptr; << 마찬가지. 괄호 없어도 됨.

함수 매개인자로 참조자를 쓸 수 있는 이유
- 매개변수는 함수가 호출되어야 초기화 되기 때문에.

참조자를 받는 call-by-reference의 문제점
- 코드 분석이 힘들다
- int num=24; func(num); cout <<num;을 하면 C에서는 무조건 24
- 그럼 C++에서는? func의 매개변수가 참조자 일 수도 있기 때문에, 내부에서 값이 바뀔 수도 있다. 때문에 코드 분석 힘듬

참조자 call-by-reference를 어느정도 해결하는 방법
- 완벽한 해결은 불가능. 완벽하게 해결하려면 참조자 매개변수를 안써야함.
- const 키워드를 이용하면, 함수의 선언부만 봐도 [아 이 값은 변동 없는 값이구나]라는걸 어느정도 전달 가능

매개변수도 참조자, 반환형도 참조형일 경우
- 함수는, 매개변수로 받은 참조자를 이용해 값을 ++한 후 참조자 리턴.
- 리턴값을 받는쪽에서, 참조자로 받으면, 동일한 변수를 가리킬 수 있다. [int& num2 = func(num)]
- 리턴값을 받는 쪽에서, 일반 변수로 받으면 값만 저장된다. [int num2 = func(num) <<num은 1이었고 내부에서 1 증가. 그럼 num2는 2가 되고, num과는 아예 다른 변수가 된다)

잘못된 참조 반환
- 함수 내부에서 선언한 지역변수 num을, 참조자로 리턴하고 호출한 쪽에서 그걸 인자로 받는다면?
- 함수 종료 시점에 지역변수 num은 소멸되기 때문에, 밖에서는 이상한 공간을 참조할 수 있다.
- 참고로 위 상황에 컴파일러는 '경고 메시지'를 발생시키기 '오류 메시지'를 발생시키지 않음. 즉 컴파일 가능

리터럴 상수, 임시객체, 임수 변수 소멸 시점
- 리터럴이나 임시객체나 임수변수 등도 연산을 위해서는 메모리에 올라가야한다. 그래서 공간이 할당된다(data 영역)
- 코드 다음행으로 넘어가면 소멸된다.
- 하지만, 다음행으로 넘어가기 전에 누군가가 가리킨다면, 소멸되지 않는다.

const 참조자
- const 변수를 참조할 수 있다.  [const int aa=10; const int& ref = aa; ]
- 상수도 참조할 수 있다. [const int& ref = 10]
- 객체를 const 참조자로 참조할 경우, const 함수만 호출 가능하다.

const 객체
- const 멤버함수만 호출 가능
- const 멤버변수는 애초에 선언과 동시에 초기화되어야 하기 때문에 해당사항 없음. public const 변수라고 해도, 이미 생성될때는 값이 초기화되어있어야 함.

const 참조자는 NULL은 가리킬 수 있고 nullptr은 안된다.

임시 변수가 필요한 이유
- 편의성
- func(const int& ref1);	func(1) <<<이게 가능하다.

malloc&free / new&delete의 차이점
- 생성자/소멸자 호출 여부

일반 new와 배열 new의 차이점
- 배열 new로 객체를 생성할 경우, 메모리 앞에 생성한 객체의 수를 저장해둔다.
- 그리고 나중에 배열 delete로 해제할 경우 그 수만큼 돌면서 소멸자가 호출된다.

C의 헤더를 C++ 스타일로 선언해야 하는 이유
- C++로 오면서 새로 추가된 문법(함수 오버로딩 등..)등을 사용해 개선된 형태로 라이브러리가 정의되어 있음

클래스 안에 enum
- 해당 클래스에서만 유효하다.

구조체/클래스 내부의 함수 인라인
- 멤버함수는 자동으로 인라인 처리된다. 
- 컴파일 최적화를 끄면 인라인 처리 안된다.

멤버 함수의 선언부 정의부 분리
- 선언부는 클래스 내부에, 정의부는 클래스 외부에 둔다.
- 하지만, 이렇게 분리되면 멤버 함수의 inline이 풀린다.
- 이 때는 정의부에 명시적으로 inline 명령어를 적으면 inline 처리된다.

클래스와 구조체의 차이점
- 키워드 차이
- 구조체는 기본 public / 클래스는 기본 private

클래스의 선언
- 클래스의 멤버변수와 멤버함수의 선언부가 모여있는 부분
- 컴파일 정보로 사용된다.
- 보통 헤더파일

클래스의 정의
- 클래스의 멤버함수 정의부가 모여있는 부분
- 보통 .cpp

인라인 함수는 헤더파일에 같이 넣어야 한다.
- 인라인 함수는 컴파일 타임에 호출부를 몸체로 변환하기 때문에.

객체지향 프로그래밍이란?(OOP. Object-Oriented Programming)
- 현실에 존재하는 사물과 그 행동을 실체화 시키는 프로그래밍

객체란?
- 하나 이상의 상태 정보(데이터)와 하나 이상의 행동(기능)으로 구성
- 데이터와 기능으로 구성된다.
- 실제 생성자까지 호출되어야, 객체라 한다. 클래스 자체는 객체가 아니다.

객체 대화 방법
- 하나의 객체가 다른 객체에서 메시지를 전달하는 방법
- Message Passing(메시지 패싱)이라 한다.
- 결국엔 함수 호출이다.

const 함수
- 함수 내부에서, 멤버 변수에 저장된 값을 변경하지 않겠다는 것.( 매개변수, 지역변수도 아니며, '멤버변수' 이다. 잘 기억하자.)
- 클래스 내부에 멤버함수로 [int aaa() const {...}] 와 같은 형태로 선언
- const 함수 내부에서는, const함수만 호출 가능

객체지향의 4대 속성
- 추상화 : 객체들의 공통적인 특징을 뽑아내는 것.
- 캡슐화 : 관련있는것을 1개 클래스로 묶는다. 기본적으로 정보은닉 포함.
- 상속 : 코드 재사용, 코드 확장성, 코드 유연성
- 다형성 : 같은 타입이지만 실행결과가 다름

추상화란?
- 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 추출하는 것
- 절차지향에서는 struct가 그것이었다.

정보 은닉이란?
- 클래스 내부에, 제한된 방법으로 접근하도록 하는 것.
- 제한된 방법을 위해 엑세스 함수(Access function)을 정의한다. 해당 함수는 클래스의 멤버변수에 접근할 수 있다.
- 필요 이유 : 무분별하게 접근하면 내부의 데이터를 이상하게 변조할 수 있다.
- 목표 : 안전성 증가

캡슐화란?
- 관련있는 데이터와 기능을 하나의 클래스로 묶는것
- 예로 코감기약. 내부에 코막힘 클래스/기침 클래스/ 가래 클래스를 1개의 코감기약 클래스로 만듬. 코감기약이 3개의 클래스를 멤버로 가지고 있음
- 필요 이유 : 코감기약을 순서대로 먹어야 할 경우, 모든 프로그래머는 그 순서를 알고있어야 함. 하지만 코감기약 클래스로 캡슐화를 하면 [코감기약 먹기] 함수만 호출해 안전하게 약먹기 가능
- 목표 : 안전성 증가

생성자
- 객체 생성 시 1번만 호출되는 함수
- 클래스의 이름과 함수이름이 동일
- 반환형 없음.
- 오버로딩 가능

객체 생성 시 주의점
- Test abc() <<이거 불가능
- 함수 선언문과 중복되기 때문이다.
- Test* abc = new Test() << 동적할당 할 때는 ()를 붙여서 사용하기 가능.

멤버 이니셜라이저
- 멤버변수로 선언된 객체의 생성자 호출에 사용

멤버 이니셜라이저의 장점
- cosnt 멤버변수 초기화 가능 
-> 이니셜라이저로 초기화되는 멤버는 선언과 동시에 초기화가 이루어진다. (바이너리 코드가 그렇게 됨)

- 성능 증가
-> 생성자 몸체에서 생성하면 생성한 객체에 대입한다. 2줄 [int a; a = 10]. 
-> 이니셜 라이저를 이용하면 선언과 동시에 초기화. 1줄 [int a=10;]
-> 이것은, 멤버로 객체를 가지고 있을때도 마찬가지. 2줄로 하면 기본생성자,대입연산자 실행 / 1줄은 복사생성자만 실행

- 멤버변수로 참조자 사용 가능. 참조자도 선언과 동시에 초기화되어야 한다.

객체 생성 과정
- 메모리 공간 할당 
- 멤버 이니셜 라이저를 이용한 초기화 << 이니셜라이저가 선언되었을 경우
- 생성자 몸체부분 실행 << 무조건 실행. 생성자 없으면 디폴트 생성자 호출

객체 소멸 과정
- 소멸자 몸체 실행
- 메모리 공간 해제

const 상수 / const 변수
- 같은 의미.

디폴트 생성자
- 클래스 내부에 생성자가 하나도 없을때, 컴파일러가 자동으로 기본생성자를 만들어준다.
- 이를 디폴트 생성자라 한다.
- 생성자가 하나라도 있으면 안만들어줌

소멸자
- 객체 소멸시 자동 호출
- 반환형 없음.
- 오버로딩/디폴트값 설정 불가능

디폴트 소멸자
- 소멸자가 없을 경우, 기본적으로 추가되는 소멸자

객체 배열
- 객체를 담을 수 있는 배열 (저장 대상 : 객체)
- Test abc[10], Test *abc = new Test[10];
- 여전히 생성자가 호출되지만, 기본 생성자만 호출 가능하다 (인자를 전달하지 못하기 때문에)
- 기본 생성자가 없으면 컴파일 오류.

객체 배열 초기화 방법
- 객체마다 초기화 값이 동일하다면 기본생성자에서 하면 된다.
- 하지만 객체마다 다르다면, 생성 후 직접 초기화해야 한다.

객체 포인터 배열
- 객체의 포인터를 담을 수 있는 배열.  (저장 대상 : 객체 포인터)
- Test *abc[10]; 와 같이 선언

this 포인터
- 객체 자기 자신의 주소값.
- 주소값과 자료형이 정해지 있지 않은 포인터

this 포인터 사용 불가한 상황
- 멤버 이니셜라이저에서는 this 포인터 사용 불가능
- 대신, 멤버 이니셜라이저는 [Test(int num1, int num2)   : num1(num1), num2(num2)] 일 때, 괄호 안을 매개변수로 / 괄호 밖을 멤버변수로 자동 인식한다. 
- 즉, this->num1(num1), this->num2(num2) 인 것 처럼 인식한다(실제 이렇지는 않다)

Self-Reference
- Test& abc() { return *this }를 하면 자기 자신의 참조값 리턴 가능
- this는 포인터이고 가리키는 값은 나 자신이기 때문에 *this는 나 자신이다. 근데 반환형이 참조형이기 때문에 나 자신의 참조값이 리턴된다.

복사 생성자
- 객체를 인자로 받는 생성자
- 인자가 꼭 자기 자신일 필요는 없으며, 다른 객체도 인자로 받을 수 있다.
- Test(const &Test ref) {...} 와 같은 형태로 선언. 참조자 꼭 붙여야 한다!

복사 생성자에 참조자를 꼭 붙여야 하는 이유
- const는 필수는 아니다. 하지만 참조자는 필수이다.
- 이걸 안붙이면 무한루프에 빠진다.
- 복사생성자 호출 -> 매개변수 생성 시 인자로 넘어가는 객체의 복사 -> 생성자, 복사생성자 호출 -> 그 복사생성자 안에서 또다시 객체 복사 -> 복사생성자 호출 -> ... 무한반복 ...
- 참고로 복사생성자 매개변수로 &를 안하면 컴파일 에러 발생

디폴트 복사생성자
- 복사 생성자를 정의하지 않으면, 디폴트 복사생성자가 삽입된다.
- 디폴트 기본생성자는 하는게 없지만, 디폴트 복사 생성자는 멤버대 멤버 복사가 발생한다. 

explicit 키워드
- 자동 형변환을 막는다. 주로, 객체 생성 시 자동으로 형변환되는 것을 막는다.
- explicit Test(int n) {...} << 이렇게 하면 Test aa = 3 이게 불가능하다. explicit을 빼면 가능하다.

얕은 복사
- 멤버대 멤버 복사. 디폴트 생성자의 작동 방식을 의미

얕은 복사의 문제점
- 메모리 동적할당을 했을 시, 멤버대 멤버 복사는 한 공간을 각각 클래스가 가리킨다 (총 2개의 변수가 가리킴)
- 이 때, 하나의 클래스가 소멸되면서 소멸자에서 동적해제를 하면, 나머지 1개는 동적해제 된 공간을 가리킬 수 있다.

깊은 복사
- 새로 생성되는 객체가 직접 동적할당 후 메모리를 복사한다. 즉, 2개의 변수가 각각 다른 메모리를 가리키도록 한다.
- 멤버 뿐만 아니라 포인터가 가리키는 대상까지 복사.

복사 생성자 호출 시점 (총 3가지)
- 기존에 생성된 객체를 이용해 새로운 객체를 초기화
- Call-by-Value 방식의 함수 호출과정에서 객체를 인자로 전달
- 참조형/포인터가 아닌 객체를 반환

임시객체
- 객체 반환 시점에 임시로 만들어지는 객체. 임시변수와 동일한 개념인데 객체인것 뿐
- 임시 객체의 '참조 값'이 반환된다. 
- 때문에 누군가가 참조할 수 있다.

임시객체 생성 방법
- Test(10) << 이렇게하고 아무도 안받으면 그냥 임시객체.

임시객체 소멸 시점
- 코드 다음줄로 이동 시 소멸된다.
- 하지만, 코드 다음줄로 넘어가기전에 누군가가 가리킨다면(참조한다면) 소멸되지 않는다.

새로 생성되는 객체에게 임시객체를 대입할 경우
- Test ref = Test(10);
- 이 때, ref의 복사생성자 호출 안됨. 임시객체에 ref라는 이름을 붙이게 된다.
- 즉, Test(10)의 생성자만 호출되며 이때 리턴되는 임시객체에 ref라는 이름을 붙임

임시객체를 참조자로 가리키기
- Test& ref = Test(10); << 이거 불가능
- const Test& ref = Test(10) << 이렇게 해야 가능
- 왜냐하면, 참조자는 상수를 가리킬 수 있으며, 상수를 가리키는 참조자는 const 참조자.

friend 선언
- 나의 private/protected에 접근할 수 있게 해준다.
- 어디 영역이든 위치할 수 있다. (private / protected / public)
- class friend 선언 / 함수 friend선언이 가능하다.

함수의 friend 선언
- 해당 함수를 통해 클래스의 private/protected로 접근 가능
- 함수 원형 선언이 포함되어 있다.
- 클래스 friend도 원형 선언도 마찬가지.

static 멤버변수 (클래스 변수)
- 클래스당 1개만 존재하는 변수. 객체당 1개 아님!
- 객체 생성 여부와 관계 없이 메모리에 할당됨.
- 개체 외부에 존재하지만, 객체에서 접근할 권한만 존재

static 멤버변수 초기화 방법
- 클래스 외부에 int Test::변수이름 = 0처럼 초기화되어야 함.
- 만약 클래스 생성자에서 초기화하면, 객체가 생성될 때 마다 해당 값으로 초기화 발생..

static 멤버변수 다른 접근
- 스코프 연산자(::)를 이용해 접근 가능. Test::이름 <<으로 접근
- public으로 선언되어 있을 경우이다.

static 멤버함수
- static 멤버변수와 동일한 속성 (클래스 별 1개 / 사실 객체멤버 아님 / 생성 여부와 관계없이 존재)
- 내부에서는 static 멤버변수와 static 멤버함수 호출만 가능하다.

static 함수에서 static 멤버변수만 접근 가능한 이유
- 일반 멤버변수에 접근할 경우, 아직 초기화되지 않은 변수에 접근할 가능성

Mutable
- const 함수 내에서의 값 변경을 허용
- 변수 앞에 붙인다. (mutable int a)
- const의 기능을 제거할 수 있다. 조심히 사용하자.

컨트롤 클래스(핸들러 클래스)
- 기능의 처리를 담당하는 클래스
- 객체지향에서 반드시 존재하는 클래스

상속이란?
- 부모의 특성을 자식에게 물려주고, 자식이 자신만의 특성을 더해 새로운 클래스를 생성하는 방법.
- 코드 재활용, 코드 유연성, 코드 확장성

부모 객체 초기화
- 자식은 부모를 초기화해야 하는 의무가 있음

부모 생성자 호출 방법
- 명시적 호출 시 멤버 이니셜라이저 사용
- 명시적으로 호출하지 않을 시 부모의 기본 생성자가 호출된다. <<이게 되기 위해서는 부모의 기본생성자가 존재해야 함. 없으면 기본 문법 에러난다 (디폴트 생성자 포함)

자식 객체 생성 과정
- 메모리 할당
- 부모 클래스 초기화(생성자 호출) << :a(10), Test() 처럼 멤버 이니셜라이저에 부모 클래스 호출구문이 뒤에있어도, 무조건 부모 생성자 먼저 호출된다. 
- 멤버 이니셜라이저 호출
- 자식의 생성자 몸체 진행

부모가 먼저 초기화되는 이유
- 부모가 초기화 되어있지 않다면, 자식의 생성자 몸체를 실행하면서 부모의 멤버변수 등에 접근할 때 문제 발생 가능성.

자식 객체 소멸 과정 (생성의 역순)
- 자식의 소멸자 몸체 진행
- 부모의 소멸자 몸체 진행
- 메모리 해제

자식 입장에서 부모의 private
- 자식은 부모의 private 변수에 접근 불가.
- 상속은 된다. 다만 접근 불가능할 뿐

상속의 형태
- public << protected << private 순으로 접근범위가 높음
- public 상속 : public보다 접근 범위가 낮은 변수를 public으로 상속 (결국 부모의 있는 그대로 상속)
- protected 상속 : protected보다 접근 범위가 낮은 변수를 protected로 상속 (public은 protected가 됨)
- private 상속 : private보다 접근 범위가 낮은 변수를 private으로 상속 (public / protected 변수가 private이 됨)

상속의 형태 특이점
- 어떤 상속이든, 부모의 private은 [접근 불가]로 상속된다.
- private이 아니라 접근 불가이다.  자식은 부모에게 접근할 수 없기 때문이다(정보은닉)

상속의 조건
- IS-A 관계 : A는 일종의 B이다
- HAS-A 관계 : 소유 관계
- 상속은 IS-A 관계의 표현을 위한 수단.

UML (Unified Modeling Language)
- 통합 모델 언어. 다이어그램같은 것.

객체 포인터 변수
- 객체를 가리킬 수 있는 포인터 변수
- [Test* a = new Test]와 같은 형태

객체 포인터 변수의 특징
- AAA형 객체 포인터 변수는 AAA객체 또는 AAA를 직/간접적으로 상속하는 모든 객체를 가리킬 수 있다. (객체의 주소를 저장할 수 있다)
- [Test* a = new 자식] <<이런게 가능하다는 말
- 이게 가능한 이유 : 상속은 IS-A 관계를 체크하는데, 이에 위반되지 않기 때문에 가능.

함수 오버라이딩
- 부모와 완전히 동일한 (함수 이름, 매개변수, const 여부) 함수를 자식이 정의해, 부모의 함수를 완전히 가린 상황
- 동일한 이름의 함수를, 자식 객체가 호출하면 자식의 함수가 / 부모 객체가 호출하면 부모의 함수가 호출된다.

함수 오버로딩 / 함수 오버라이딩
- 함수 오버로딩 : 동일한 이름의 함수를, 매개변수를 다르게 정의한 것. const도 오버로딩 조건
- 함수 오버라이딩 : 부모가 가진 함수와 완전히 동일한 함수를 자식이 정의한 것.

함수 오버라이딩 된 부모의 함수 호출방법
- 부모 객체로 호출해도 되며, 스코프 연산자를 사용해도 된다.
- Test::GetPay() << Test를 부모라고 가정한다. 이와 같이 호출한다.

오버라이딩 함수 내부에서, 다른 함수를 호출할 때.
- A가 부모, B가 자식일 때 A에도 Func(), B에도 Func()라는 오버라이딩된 함수가 있다고 가정
- 둘 다 내부에 GetPay() 함수를 보유하고 있으며, 이름은 같지만 하는 일은 다르다.
- 그리고 A.Func()에서 GetPay()를 호출 / B.Func()에서 GetPay를 호출하면 각자 자기 자신의 Getpay함수가 호출된다.

C++ 컴파일러의 포인터 연산 가능 여부 판단
- 포인터의 자료형을 기준으로 판단. 실제 가리키는 객체의 자료형 아님!
- Base* ptr = new Derived;   ptr->Derived.func() 하면 컴파일 에러 발생. 
- 함수를 호출하는 시점에 컴파일러는, ptr을 Base로 인식하기 때문에

가상함수
- 포인터의 자료형이 아닌, 실제 가리키는 객체의 오버라이딩된 함수를 불러오는 기능
- 가상함수 테이블을 이용한다.

가상함수 테이블이란?
- 해당 객체가 사용하는 모든 가상함수가 들어있는 테이블
- 오버라이딩 된 가상함수가 들어간다. 실 객체가 가리키는 가상함수를 호출할 수 있는 이유가 이것이다.
- 가상함수만 저장된다. 일반함수는 가상함수 테이블에 저장되지 않는다!

자식의 가상함수
- 부모로부터 상속받은 가상함수를 재정의한 자식의 가상함수는, virtual을 안붙여도 자동으로 가상함수로 인식된다.
- 즉, 부모의 함수가 virtual이면 오버라이딩하는 자식의 함수도 virtual로 인식

가상함수 테이블 생성 시점
- 해당 클래스에 가상함수가 1개라도 있을 시, 컴파일 타임에 생성. 객체 생성 시점 아님! 

가상함수 테이블과 객체 연결 시점
- 생성된 테이블을, 객체가 실제 생성될 때 객체 가장 앞에 포인터로 들어간다.

가상함수 테이블 작동 매커니즘
- 함수 포인터 사용
- 내부적으로는 콜백 함수 매커니즘.

순수 가상함수
- 함수의 몸체가 정의되지 않은 가상함수. (일반 함수는 불가능)
- virtual int GetPay() = 0;와 같이 하면, 몸체가 없어도 된다.

추상 클래스
- 순수 가상함수가 1개라도 정의된 클래스는, 객체로 만들 수 없다.
- 이렇게, 순수 가상함수가 1개 이상있는 클래스를 추상 클래스라 한다.
- 추상 클래스를 객체로 생성하려고 하면 (지역 객체든 동적할당이든 전역이든..) 컴파일이 안된다.

다형성이란?
- 모습은 같은데 형태는 다른것.
- 같은 문장의 코드를 2번 호출했는데, 결과는 다른 것

가상 소멸자
- virtual 키워드가 붙은 소멸자.
- First* aa = new Second; 	delete aa; 를 하게 되면, aa의 소멸자만 호출된다. --> 메모리 누수
- 하지만 virtual을 붙여두면 실제 가리키는 대상의 소멸자부터 순차적으로 호출된다. 

오버라이딩 및 가상함수 기능이 참조자에도 적용될까?
- Second bb;     First* ref1 = &bb;     ref1->Func() <<이걸 하면 Second의 func가 호출됨
- Second bb;     First& ref1 = bb;     ref2.Func() <<이걸 하면 Second의 func가 호출됨
- 즉, 참조자도 포인터와 마찬가지로 완전히 동일하게 작동한다.

업 캐스팅을 하면, 부모의 함수 + 자식의 가상함수만 호출 가능
- 햇갈리지 말자
- Second bb;	First aa = bb;	<< 이걸 하게 되면 aa는 First의 함수와 bb의 가상함수에 접근 가능

C++이 C보다 미세하게나마 느린 이유
- 가상함수 호출 시, 가상함수 테이블 검사로 인해.
- 하지만 큰 차이는 아니다.

다중 상속이란?
- 둘 이상의 클래스를 동시에 상속받는 것.
- class Test   :public BaseOne, protected BaseTwo << 이런식의 문법

다중상속의 문제
- 상속받는 2개 클래스에 동일한 함수가 존재할 시
- BaseOne / BaseTwo 둘다 Base클래스를 상속받을경우

상속받는 2개 클래스에 동일한 함수가 존재할 시
- 상속받는 2개 클래스에 동일한 이름이 있을 경우, 자식 입장에서는 누굴 호출해야할지 모름.
- 해결책 : 스코프를 이용한 접근. BaseOne::ABC() 혹은 BaseTwo::ABC() 이런식으로 접근

BaseOne / BaseTwo 둘다 Base클래스를 상속받을경우
- BaseOne / BaseTwo 안에는 Base클래스의 정보가 각각 들어있다.
- 그래서 이 2개를 다중상속받는 Test는 Base 클래스의 정보를 2개 가지고 있다.
- 이 때는 Base클래스의 함수를 호출하려면 BaseOne::Func(), BaseTwo::Func()식으로 호출해야 한다.
- 해결책 : 가상 상속 사용

가상 상속
- 상속받을 때, virtual을 붙여서 상속받으면 가상 상속이 된다.
- BaseOne : virtual Public Base / BaseTwo : virtual Public Base << 이런식으로 상속한다.
- 그리고 BaseOne / BaseTwo를 상속받는 Test 클래스를 객체로 생성하면, Base의 생성자는 1회만 호출된다.

연산자 오버로딩
- 'operator'와 '연산자'를 묶어서 함수의 이름을 정의하면, 연산자를 이용한 함수 호출도 허용.
- const선언 가능.

멤버 함수에 의한 연산자 오버로딩
- pos1.operator+(pos2)와 같은 형태
- Test operator+(cosnt Test& ref) <<와 같은 함수가 클래스 내부에 정의된다.

전역 함수에 의한 연산자 오버로딩
- operator+(pos1 + pos2)와 같은 형태
- Test operator+(const Test& ref1, const Test& ref2) <<와 같은 함수가 전역으로 정의된다.
- Test 클래스 내부에 friend Test operaotr+(const Test& ref1, const Test& ref2)와 같이 friend 선언이 되어있어야 한다.

멤버, 전역 연산자 오버로딩이 같이되어 있으면?
- 멤버 연산자 오버로딩이 호출. 하지만 컴파일에 따라 에러를 내기도 함.

멤버함수 연산자 오버로딩만 가능한 연산자
- = , () , -> , [] 총 4개

연산자 오버로딩 주의사항
- 본래 의도를 벗어난 오버로딩은 하지 말자 (+연산자 안에서 - 등...)
- 연산자 우선순위/결합성은 변경되지 않음 
- 매개변수 디폴트값 설정 불가능
- 연산자 기본기능을 변경하는 오버로딩은 허용되지 않는다. (int형 연산자 오버로딩 등 ..불가능)

전위 증감
- 자기 자신을 참조자로 리턴해야 한다.
- 인자는 없다.
- Point& operator++()  { ...++작업. return *this } 와 같은 형태. 

전위증감 연산이 참조자를 리턴하는 이유
- 보통 ++(++num)과 같이 계산한다.
- 즉, 괄호 안의 ++한 후 괄호 밖의 ++이 되어야 하는데, 이 규칙을 지키기 위해서이다.

후위 증감
- 참조자로 리턴하면 안된다!!! 그리고 리턴값은 const로 해야 한다
- 인자에 int를 넣으면 후위증감으로 인식
- const Point operator++(int) { Point Temp; 자기 자신을 ++...; return Temp } 와 같은 형태
- 전역함수라면 cosnt Point operator++(const Point& ref, int)와 같은 형태로 선언

후위증감은 왜 참조자 리턴을 안할까?
- 후위 증감은 내부의 Temp 객체를 리턴하지 자기 자신을 리턴하지 않는다.
- 자기 자신을 리턴하면 외부에서 증가된 값을 사용하기 때문에 문제가 된다. 후위증감은 코드 다음줄로 넘어간 후 증가값이 반영되어야 한다.
- Temp는 지역 객체이기 때문에 함수 호출이 끝나면 사라진다. 잘못된 참조가 된다.

후위증감의 리턴은 왜 const가 붙어있을까?
- 전위증감은 ++(++num)이 된다.
- 후위증감은 (num++)++ 이런게 될까? 당연히 안된다. 이걸 막기위해, 리턴되는 '임시 객체'를 const형으로 선언한다.
- (pos1++)++ --> (const Point형 임시 객체)++ -> (const Point형 임시 객체).operator+(int)가 되기 때문에, 막을 수 있다.
- 복습 : const 객체는 const 함수만 호출 가능.

전역함수로 연산자 오버로딩이 되어야 하는 경우
- 교환법칙 성립을 위해. (3*1은 1*3,  pos1 * 1은 1*pos1. 이게 교환법칙)
- 1*pos1은 컴파일러가 1.operator*(pos1)로 해석하는데, 이런건 해석 할 수 없다.
- 이 때, [Point operator*(int value, const Point& ref)] 로 정의된 전역함수가 있으면 계산 가능.

<<, >> 연산자를 이용한 클래스 멤버 출력
- cout << pos1만 하면 멤버 전부가 출력되게 하고 싶으면 << 연산자 오버로딩이 필요함
- 하지만 기본적으로 cout 객체의 멤버함수로 <<가 존재하기 때문에 우리는 전역함수로 해야 가능.

대입연산자 (복사 생성자와 매우 비슷)
- 정의하지 않으면 디폴트 대입 연산자가 삽입
- 디폴트 대입연산자는 멤버대 멤버의 얕은 복사
- 동적할당 시 깊은복사 필요.
- pos1.operator=(pos2)와 같은 형태이다.

대입연산자의 형
- Point& operator=(const Point& ref) { ....; return *this} << 반환형을 참조로 해야함.

대입 연산자 호출 시점
- 이미 생성된 객체에 대입할 때. 
- [Point Pos1 = Pos2] << 이건 복사
- [Point Pos1,  Pos2; Pos1 = Pos2] << 이건 대입

깊은 복사를 구현한 대입연산자 주의점
- 복사생성자는, 인자로 받은 객체의 동적할당 정보를 복사했다
- 대입 연산자는, 일단 자기 자신의 동적할당된 정보를 delete 해야 한다. 아니면 덮어쓴다.

상속 관계에서 대입연산자
- 자식 클래스의 대입연산자를 정의하지 않았을 시 : 디폴트 대입연산자 추가. 그리고 부모의 대입 연산자를 호출한다. 부모의 대입 연산자가 없으면 부모의 디폴트 대입 연산자가 호출된다.
- 자식 클래스의 대입연산자를 명시적으로 정의할 시 : 그 안에서 명시적으로 부모의 대입연산자를 호출해야 부모의 대입 연산자가 호출된다!! 자동으로 호출되지 않는다.

깊은 복사와 얕은 복사를 신경쓰기 싫으면?
- 객체의 주소값을 저장한다. (객체 포인터 배열)

new/delete도 연산자다

new 연산자가 하는 일
- 메모리 할당
- 생성자 호출
- 형변환(말록은 직접했던걸 new는 대신해주기 때문에)

new 연산자 오버로딩
- 위 절차 중 [메모리 할당]만 직접 하는 오버로딩.
- void* operator new(size_t size) {... void* adr = new char[size]; return adr} << 이 작업은 무조건 하는걸로 약속되어 있다.
- Point* aa = new Point가 실행되면, 컴파일러는 필요한 사이즈 계산 후, 해당 함수를 호출하면서 인자로 던진다.
- 그리고 함수가 끝나면 나머지 절차(생성자 호출, 형변환)를 한다.

delete 연산자가 하는 일
- 객체 소멸자 호출
- 메모리 할당 해제

delete 연산자 오버로딩
- 위 절차 중 [메모리 할당 해제] 절차를 진행한다.
- void operator delete(void* adr) << 이미 약속되어 있다.
- 소멸자가 끝난 다음에 진행된다.

막간 퀴즈! main {Point* aa = new Point;   return 0  } << 이렇게 되면 소멸자가 호출될까?
- 안된다!!! delete를 명시적으로 호출해야 소멸자가 호출된다.
- 아마, return 0으로 자연스럽게 프로세스가 종료되면, exitthread를 하는데, 그 안에서는 HeapDestroy를 하는듯 하다.

new / delete 연산자는 static이다.
- static이 아니면 호출이 불가능하다. 객체 생성 전에 호출되는 함수이기 때문에!
- static이 안붙었지만 static으로 간주된다.

배열 new/delete 연산자
- 배열 없는것과 동일하다. 단지 new aaa[], delete[] aaa 로 사용할 뿐이다.

포인터 연산자 오버로딩
- -> : 포인터가 가리키는 객체의 멤버에 접근
- * : 포인터가 가리키는 객체에 접근

->, * 연산자 오버로딩
- Point* operator->() { return this }  <<this는 나를 가리키는 포인터이다. 즉 주소 값이다. 주소 값 자체를 리턴한다.
- Point& operator*()  {return *this}  << 참조값을 리턴한다. 객체 자체에 접근해야 하기 때문이다.

스마트 포인터란?
- 포인터의 역활을 하는 객체
- -> , *연산자 오버로딩이 핵심
- 자동으로 소멸자까지 호출해준다.

( ) 연산자 오버로딩
- 객체를 함수처럼 사용할 수 있는 오버로딩
- Point operator+(const Point& pos) { ... } 와 같은 형태

펑터
- ( ) 연산자 오버로딩을 통해 함수처럼 동작하는 클래스
- 혹은 함수 오브젝트라고도 한다.

펑터 사용 이유
- 펑터로 전달되는 것에 따라 사용되는 기준이 달라진다.

형변환 연산자 오버로딩
- 객체를 일반 자료형으로 형변환 할 수 있는 연산자 오버로딩
- 특징 : 반환형이 없다. 하지만 반환은 된다. 
- Number num = num1 + 10; << 했을 때, 형변환 연산자가 오버로딩 되어있으면 num1을 int로 형변환 한다.
- operator int()	{return num} 과 같은 형태로 선언

템플릿
- 함수/클래스를 만드는 도구
- 컴파일 타임에 자료형을 결정해 함수/클래스를 만들어 준다.

템플릿 함수
- 템플릿으로 인해 만들어진 함수

템플릿 함수와 동일한 일반함수가 같이 정의되어 있으면?
- 일반 함수가 호출된다.
- Add<int>(10, 20)처럼 명시적으로 지정하면 템플릿 함수가 호출된다.

함수 템플릿의 특수화
- 어떤 특수한 형에 대해서는 사용자가 지정한 형을 사용하라는 것.
- template<> 
  char* Max<char*> (char* a, char*b) { .... }  << Max옆에 <char*>는 생략해도 된다.
- "char*형 함수는 별도로 만들지 말고 이걸 써라!" 라는 뜻이다.

템플릿 클래스
- 템플릿으로 인해 만들어진 클래스.
- 기능은 모두 동일한데, 저장 대상의 타입만 다를 경우 템플릿 클래스를 사용한다.
- 호출 시, <>를 꼭 붙여줘야 한다. 함수 템플릿과는 다름

템플릿 클래스와 일반 클래스가 같이 정의되어 있으면?
- 동시에 정의할 수 없음.

클래스 선언과 정의 분리
- 정의에도 template<typename T>를 같이 적어줘야 함.

템플릿은 함수 선언부와 정의부를 분리할 수 없다.
- 컴파일 타임에 이루어져야 하기 때문에 다 알려줘야 함

클래스 템플릿의 특수화
- 함수 템플릿의 특수화화 동일. 특정한 자료형을 사용하는 클래스.

부분 특수화
- template<T1>	
  class MySys<T1, int> {..} <<< T2에 대해서만 특수화를 했다.

템플릿 매개변수
- 템플릿 시 사용하는 T, T1, T2와 같은 문자

C++ 캐스팅
- static_cast
- dynamic_cast
- const_cast
- reinterpret_cast

static_cast
- 일반 자료형 간 형변환 + 객체 포인터의 클래스 상속관계의 형변환 제공. 
- 객체는 부모 <-> 자식간 형변환 제공.
- 단점 : 책임은 프로그래머 몫

dynamic_cast
- 클래스 상속관계의 형변환 제공.
- 포인터/참조자만 사용 가능
- 자식 -> 부모로 형변환 제공.
- 부모가 Polymorphic 클래스라면(가상 함수가 하나라도 있음) 부모->자식 컴파일도 허용. (RTTI를 확인해, 런타임에 안전성 체크)

const_cast
- 포인터/참조자만 사용 가능
- const 속성 제거

reinterpret_cast
- 포인터와 관련있는 모든 연산 허용

static cast와 dynamic cast의 차이점
- static cast : 무조건 부모<-> 자식간 형변환 제공
- dynamic cast : 자식 -> 부모간 형변환 제공. 
- 부모가 Polymorphic 클래스라면 부모 -> 자식 형변환도 제공. 

static cast와 dynamic ast의 차이점2
- static cast는 컴파일 타임에 안전성 검사 안함.
- dynamic_cast는 런타임에 안전성 검사를 한다. --> 때문에 static이 좀 더 빠르다.

Dynamic cast에 참조형 vs 포인터 차이점
- 잘못된 형변환일 시
- 참조형 : bad_cast 예외 발생
- 포인터 : null 반환

객체 대입 업캐스팅
- Super{}가 있고, 상속받는 Sub : public Super{}가 있다.
- 이때, 이미 생성된 Sub객체를 새로 생성하는 Super에 대입 가능? [Sub aa; Super bb = aa;] 아니 불가능.

객체 대입 업캐스팅 해결
- static_cast를 사용하면 가능 [Super bb = static_cast<Super>(aa);]
- dynamic_cast를 사용하면, 포인터만 가능 [Super* cc = dynamic_cast<Super*>(&aa);]

C++ 형변환 시 주의점
- 상속 관계에서, 업 캐스팅은 언제나 안전. 다운 캐스팅은 언제나 위험

안전한 다운 캐스팅을 하려면?
- Dynamic_Cast를 사용
- 이유 : 클래스 생성 시, virtual table에 RTTI(런타임 타입 인포)가 저장된다. 때문에 런타임에 캐스팅을 체크하는 dynamic cast를 사용하면 RTTI를 확인해 안전한 캐스팅 가능
- 이유 : Dymamic_Cast는 런타임에 클래스 가상함수 테이블을 참조해 Type을 확인하기 때문에 안전한 다운캐스팅 가능

this 콜
- 멤버함수나 멤버변수에 접근할 때 사용되는 함수호출규약
- this를 ecx에 담고 그걸 호출.
- 기본적으로는 __stdcall이다.
- 하지만, 가변인자를 사용하는 함수 호출은 __cdecl을 따른다.

Test c; c + 10; <<이걸 성립시키기 위해서는?
- Test에 int를 인자로 받는 생성자가 존재해야 함
- double을 계산하고 싶어도 마찬가지

explicit 키워드
- 묵시적 형변환을 막는다.
- Test c; c+10을 막기도 하며, Test c = 3이 Test c(30)으로 변하는것도 막는다(Test c(30)만 되도록 한다)
- 애초에 C++스타일은 Test c(30)이다. =를 이용한 대입은 C++스타일이 아니다.

클래스 메서드와 가상함수의 차이점은?
- 가상함수 테이블에 등록되는지 마는지.
- 그리고 클래스 메서드는 컴파일 타임에 이미 어떤함수가 호출될지 어셈에 박힌다 (정적 바인딩)
- 가상함수는 런타임에 호출되는 함수 무엇인지 알 수 있다 (동적 바인딩)
