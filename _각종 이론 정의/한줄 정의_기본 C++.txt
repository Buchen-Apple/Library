함수 오버로딩
- 동일한 이름의 함수를 매개변수가 다르게 선언한 것
- C++은 함수의 이름과 매개변수를 같이 보고 함수를 찾는다. 반환형은 전혀 관련 없다.

매개변수 디폴트 값
- 함수의 선언/정의를 분리했을 시 함수의 선언에만 위치해야 함. 정의부에 위치하면 에러
- 변수에 값을 전달하지 않으면 컴파일러가 지정된 값을 대신 넣어준다.

부분적 디폴트 값
- 함수의 일부 매개변수만 디폴트값 지정 가능. 
- 오른쪽 부터 정의되어야 함(컴파일러가 왼쪽부터 값을 채우기 때문에)

인라인 함수
- 컴파일 타임에 처리 (매크로는 전처리 시점에 처리)
- 매크로함수에 비해 정의하기 쉬움.
- inline을 해도 컴파일러가 무시하기도 함. 반대로 컴파일러가 인라인 시키기도 함

인라인 함수의 단점
- 매크로 함수는, 다양한 자료형을 1개로 표현 가능
- 인라인은, 자료형 종속
- 템플릿을 사용하면, 자료형 종속적이지 않게 가능

컴파일 최적화
- 컴파일 최적화를 끄면, 컴파일러는 인라인 함수를 사용하지 않는다.

이름 공간(namespace)의 장점
- 함수 이름, 변수 이름 중복에서 자유로워진다.

이름공간 적용 범위
- 지역변수와 적용범위 동일.
- { } 를 벗어나면 적용되지 않음. 전역으로 하면 전체적용됨

이름공간 별칭 지정
- AAA::BBB::CCC::num1 = 20 << 이걸 namespace ABC=AAA::BBB::CCC;로 하면 ABC::num1=20 으로 접근 가능

범위지정 연산자(::) 또하나 역활
- 전역변수/지역변수의 이름이 동일할 때, 지역변수만 접근 가능.
- 범위지정 연산자를 사용하면 전역변수 접근 가능
- ::val 을 하면 전역의 val에 접근

true/false와 TRUE/FALSE의 차이
- true/false는 참과 거짓을 표시하는 키워드
- TRUE/FALSE는 참과 거짓을 표시하는 정수
- true/false는 sizeof하면 1, TRUE/FALSE는 sizeof하면 4(정수 상수는 기본적으로 int형)

참조자
- 메모리공간에 붙은 또 하나의 이름
- 새로 선언하는 변수 앞에 &가 오면 참조자가 된다.
- int &a = num1;과 같이 사용.

참조자 특징
- 선언과 동시에 누군가를 참조해야 함. 선언 후 나중에 참조하기 이런거 없음
- 기존에 존재하는 메모리 공간에 이름을 붙인다. 때문에 변수에만 사용 가능 (상수 사용 불가. NULL도 상수이기 때문에 불가)
- 참조자 수 제한 없음
- 참조자를 대상으로 참조자 선언 가능

배열의 요소를 참조자로 가리키기
- int arr[3]에서 arr[0]과 같은 요소는 일반 변수이기 때문에 그냥 가리키면 된다.
- int &ref = arr[0];

배열을 참조자로 가리키기
- 배열의 요소가 아니라 배열 자체를 참조자로 가리키기 위해서는, 길이를 같이 전달해야 한다.
- 1차원 배열은 [int arr[3];       int (&ref)[3] = arr;]
- 2차원 배열은 [int arr[3][10];	  int (&ref)[3][10] = arr;] 처럼 가로 세로를 모두 전달해야 함

포인터를 참조자로 가리키기
- int *ptr = &num;	 int *(&pref) = ptr;
- int **pptr = &ptr;   int **(&ppref) = pptr;

함수 매개인자로 참조자를 쓸 수 있는 이유
- 매개변수는 함수가 호출되어야 초기화 되기 때문에.

참조자를 받는 call-by-reference의 문제점
- 코드 분석이 힘들다
- int num=24; func(num); cout <<num;을 하면 C에서는 무조건 24
- 그럼 C++에서는? func의 매개변수가 참조자 일 수도 있기 때문에, 내부에서 값이 바뀔 수도 있다. 때문에 코드 분석 힘듬

참조자 call-by-reference를 어느정도 해결하는 방법
- 완벽한 해결은 불가능. 완벽하게 해결하려면 참조자 매개변수를 안써야함.
- const 키워드를 이용하면, 함수의 선언부만 봐도 [아 이 값은 변동 없는 값이구나]라는걸 어느정도 전달 가능

매개변수도 참조자, 반환형도 참조형일 경우
- 함수는, 매개변수로 받은 참조자를 이용해 값을 ++한 후 참조자 리턴.
- 리턴값을 받는쪽에서, 참조자로 받으면, 동일한 변수를 가리킬 수 있다. [int& num2 = func(num)]
- 리턴값을 받는 쪽에서, 일반 변수로 받으면 값만 저장된다. [int num2 = func(num) <<num은 1이었고 내부에서 1 증가. 그럼 num2는 2가 되고, num과는 아예 다른 변수가 된다)

잘못된 참조 반환
- 함수 내부에서 선언한 지역변수 num을, 참조자로 리턴하고 호출한 쪽에서 그걸 인자로 받는다면?
- 함수 종료 시점에 지역변수 num은 소멸되기 때문에, 밖에서는 이상한 공간을 참조할 수 있다.
- 참고로 위 상황에 컴파일러는 '경고 메시지'를 발생시키기 '오류 메시지'를 발생시키지 않음. 즉 컴파일 가능

const 변수를 참조자로 참조하기
- const int aa=10; const int& ref = aa; << 이렇게 해야 가능. const 참조자로 참조해야 함
- 애초에 const int aa = 10; int& ref = aa <<이건 컴파일 에러

리터럴 상수, 임시객체, 임수 변수 소멸 시점
- 리터럴이나 임시객체나 임수변수 등도 연산을 위해서는 메모리에 올라가야한다. 그래서 공간이 할당된다(data 영역)
- 코드 다음행으로 넘어가면 소멸된다.
- 하지만, 다음행으로 넘어가기 전에 누군가가 가리킨다면, 소멸되지 않는다.

const 참조자는 상수도 참조할 수 있다. 일반 참조자는 불가능
- const int& ref = 10; << 가능
- 상수도 메모리 공간이 가능하기 때문에, 코드 다음줄로 넘어가기 전에 const참조자로 가리키면 참조 가능

임시 변수가 필요한 이유
- 편의성
- func(const int& ref1);	func(1) <<<이게 가능하다.





Test c; c + 10; <<이걸 성립시키기 위해서는?
- Test에 int를 인자로 받는 생성자가 존재해야 함
- double을 계산하고 싶어도 마찬가지

explicit 키워드
- 묵시적 형변환을 막는다.
- Test c; c+10을 막기도 하며, Test c = 3이 Test c(30)으로 변하는것도 막는다(Test c(30)만 되도록 한다)
- 애초에 C++스타일은 Test c(30)이다. =를 이용한 대입은 C++스타일이 아니다.

객체 대입 업캐스팅
- Super{}가 있고, 상속받는 Sub : public Super{}가 있다.
- 이때, 이미 생성된 Sub객체를 새로 생성하는 Super에 대입 가능? [Sub aa; Super bb = aa;] 아니 불가능.

객체 대입 업캐스팅 해결
- static_cast를 사용하면 가능 [Super bb = static_cast<Super>(aa);]
- dynamic_cast를 사용하면, 포인터만 가능 [Super* cc = dynamic_cast<Super*>(&aa);]

C와 완전히 동일한 캐스팅은?
- Reinterpret Cast

C++ 형변환 시 주의점
- 업 캐스팅은 언제나 안전. 다운 캐스팅은 언제나 위험

static cast와 dynamic cast의 차이점
- static cast는 컴파일 타임에 형변환 체크
- dynamic cast는 컴파일 타임에 형변환 체크

안전한 다운 캐스팅을 하려면?
- Dynamic_Cast를 사용
- 이유 : 클래스 생성 시, virtual table에 RTTI(런타임 타입 인포)가 저장된다. 때문에 런타임에 캐스팅을 체크하는 dynamic cast를 사용하면 RTTI를 확인해 안전한 캐스팅 가능
- 이유 : Dymamic_Cast는 런타임에 클래스 가상함수 테이블을 참조해 Type을 확인하기 때문에 안전한 다운캐스팅 가능

Dynamic cast에 참조형 vs 포인터 차이점
- 잘못된 형변환일 시
- 참조형 : bad_cast 예외 발생
- 포인터 : null 반환

