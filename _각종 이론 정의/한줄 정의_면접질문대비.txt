간단한 자기소개
- 안녕하십니까 저는 2012년부터 2017년도까지 약 5년동안 게임 기획자로 일했구요. 프로그램이 너무 좋아져 서버프로그래머로 전직한 송 진규라고 합니다. 잘부탁드립니다.

왜 전직했나요? 
- 기획자로써 마지막으로 참여한 프로젝트가 언리얼 프로젝트였는데, 처음 다루다보니 책을 사서 읽게되었습니다. 근데 책 내용을 따라가기엔 프로그램적 지식이 부족하다는 생각이 들어서 c언어를 공부하게 됐는데 이게 너무 재미있어서 전직을 결심하게 되었습니다.
그리고 이왕이면 평소에 궁금했던 서버를 좀 더 알아보고 싶은 마음이 들어 서버를 선택했습니다. 기획자로 일할때 서버분들의 컴퓨터 화면을 보면 항상 콘솔창만 떠있어서 대체 서버가 어떻게 돌아가는지 궁금했습니다

가상 메모리란?
- 프로세스마다 가상 주소를 할당해, 물리 메모리의 제약을 벗어나기 위한 기법입니다.
- 램 뿐만 아니라 하드디스크까지를 하나의 물리적 메모리로 확장했구요.
- 모든 메모리를 페이지 단위로 분할해 요구 페이징 기법으로 작동합니다.

- CPU와 프로그래머는 다 이 가상 주소로 접근하게 되는데요, 이를 실제 물리메모리로 변경하는 것은 MMU가 해줍니다.
- MMU는 커널 영역 메모리에 있는 페이지 테이블을 이용해서 가상 주소와 물리 주소를 맵핑해줍니다.
- 그리고 이 MMU가 물리메모리에서 원하는 페이지를 찾지 못하는 것을 페이지 폴트라고 합니다.

- 페이지 폴트가 발생하면 페이지 스왑이 진행되고 기존 스레드는 block상태가 됩니다. 
- 근데 만약, 새로 깨어난 스레드가 원하는 페이지가 스왑과정에서 하드디스크로 내려간 페이지일 경우, 또 페이지폴트가 발생하며 스왑이 발생합니다.
- 이 과정이 계속 반복되는것, 즉 과도한 페이징 작업이 발생하는 것을 스레싱 현상이라고 합니다.
- 스레싱이 발생하면 전체적인 성능하락이 발생하는데요. 이를 방지하깅 위해서 프로세스마다 최소한의 페이지프레임을 할당해서 자주 실행되는 페이지를 램에 올려두는데, 이를 워킹셋이라 합니다.

인터럽트와 트랩
- 인터럽트는 하드웨어의 신호입니다. 예를 들어 I/O등이 완료되었을 시 인터럽트를 통해 CPU에게 신호를 줍니다.
- 트랩은 소프트 웨어의 신호입니다. 예를 들어 0으로 나누거나 페이지 폴트 등이 발생하면 트랩이 발생합니다.

메모리 계층이란?
- 개념
CPU랑 가까운 순으로, 레지스터/캐시/물리메모리/하드디스크로 나뉘어져 있는 이 구조를 의미합니다.

- 역활
각 계층의 역활은 자신보다 하위계층에 있는 메모리의 데이터를 캐싱하는 역활을 합니다.
하드->물리는 페이지 / 물리->캐시는 캐시라인 / 캐시->레지스터는 워드 단위로 이동합니다.
이렇게 계층을 나눈 이유는 CPU 가까이에 용량이 큰 메모리를 사용하기엔 기술적 제약과 비용문제가 있기 때문입니다.

- 그럼 이게 무슨 의미가 있는가? 하드디스크에 있는 데이터에 접근하면 느린게 아닌가?
라고 생각할 수도 있습니다. 물론 이런 상황은 느립니다.
하지만 프로그램의 지역성때문에 캐시히트가 발생할 확률은 약 90%이상이라고 합니다. 이건 윤성우님이 책에 그렇게 나와있으며 제가 검증해보지는 않았습니다.
때문에 메모리 계층은 의미가 있습니다.

스케쥴링 알고리즘에 대해 말해보시오
- 기본적으로 OS는 선점형 OS와 비선점형 OS로 나뉘어집니다.

- 비선점형 OS는 우선순위가 높은 스레드가 등장해도 CPU를 점유한 자기 자신이 점유권을 포기하지 않는 이상 다른 스레드는 절대 CPU 자원을 받을 수 없습니다.
- 그리고 FCFS(First Come First Service)라는 알고리즘으로 스케쥴링을 합니다.
- FCFS는 대기 큐에 들어온 순서대로 스레드를 실행하는 방법입니다. 

- 선점형 OS는 우선순위가 높은 스레드가 Ready에 등장할 시 기존에 Running 중인 스레드의 우선순위보다 높다면 cpu 자원을 내줘야 합니다.
- 선점형 OS의 스케쥴링 알고리즘은 무수히 많지만 그 중에 저는 멀티레벨 큐/멀티레벨 피드백 큐를 알고 있습니다.
- 멀티레벨 큐는 라운드 로빈 알고리즘과 우선순위 알고리즘, 그리고 타임슬라이스를 이용해 스케쥴링을 진행합니다.
- 다만 단점은, 스레드 기아현상이 발생할 수 있다는 것입니다.
- 그리고 이 기아현상을 해결하는 방법으로 나온 알고리즘이 멀티레벨 피드백 큐 입니다.
- 멀티레벨 피드백 큐는, 멀티레벨 큐와 동일하지만 스레드 기아현상을 해결하는게 추가되었습니다.
- 이 방법 또한 무수히 많지만 그 중 하나는 에이징이라는 방법으로, 우선순위가 낮은 스레드의 우선순위를 서서히 증가시키는 기법입니다.

LRU(Least Recently Used)와 LFU(Least frequently used)
- 캐시와 물리메모리에서 희생메모리를 선택할 때 사용하는 방법입니다.
- LRU는 캐시에 올라온지 가장 오래된 메모리를 밀어내는 방법입니다.
- 단점은, 이 오래된 메모리가 곧 사용될 예정일 경우 곧바로 다시 올라와야하기 때문에 합리적이지 않습니다.
- LFU는 가장 적게 사용된 메모리를 밀어내는 방법입니다.
- 단점은, 이 적게 사용된 메모리가 앞으로 쭉 사용될 예정일 경우 곧바로 다시 올라와야하기 때문에 합리적이지 않습니다.
- 각자 장단점이 있습니다.

멀티레벨 피드백 큐(다단계 피드백 큐)
- 선점형 OS가 기본적으로 사용하는 스케쥴링 방법입니다.
- 라운드로빈/우선순위 알고리즘을 사용합니다.
- 이 경우 기아현상이 발생할 수 있는데 이를 해소하기 위한 방법 중 하나가 에이징 기법입니다.

에이징 기법
- 에이징 기법은 우선순위가 낮은 스레드의 우선순위를 점진적으로 늘려 언젠가는 실행되도록 하는 방법입니다.

IOCP란 무엇이고 장점 적어보시오
- 비동기 입출력을 제공하며, 입출력 결과와 결과 처리 스레드를 가지고 있는 구조.
- 합리적인 스레드 풀링 : 기존 컨커런트 모델은 연결 1개당 스레드 1개를 제작. IOCP는 지정한 수 만큼의 스레드를 만들어 많은 연결을 처리. 컨커런트 모델에 비해 스레드 수가 적으므로 컨텍스트 스위칭 부담이 적다.
- wait thread queue는 스택 구조로 관리 : 캐시히트 가능성 증가, 기존에 사용했던 페이지가 물리메모리에 존재할 가능성.

Overlapped I/O 구조의 특징
- 기존의 일반 구조는 I/O요청 후 결과가 나올때까지 사용자는 아무것도 할 수 없는 상황. 
- 오버랩 구조는 I/O를 커널이 처리해주기 때문에 I/O요청 후 사용자는 다른일을 할 수 있다.

actor패턴
- reactor와 proactor가 존재합니다.
- reactor : 이벤트를 등록해두고 이벤트가 가능한 상태인지를 확인합니다.
- proactor : 작업을 등록해두고 작업이 완료될 시 통지를 받음.

스핀락의 장점
- 커널모드로의 전환이 발생하지 않습니다. 임계영역에 점유하고있는 스레드가 빠른시간 안에 작업을 끝낼 가능성이 있다면 스핀을 돌면서 기다리는게 block이 되지 않고 빠릅니다.

MTU에 대해 말씀해보세요
- 최대 전송 단위로 1500byte입니다.
- MTU가 있는 목적은, 재전송 오버헤드를 줄이기 위해서 존재합니다.
- 만약 이런 제한 없이 굉장히 큰 데이터를 전송하게 되면 데이터가 유실되거나 손실되어 재전송을 할 떄 오버헤드가 큽니다.
- 하지만 MTU라는 단위를 두고 이만큼만 전송하게 된다면, 재전송을 할 때 오버헤드가 덜 합니다.
- 그럼 반대로 너무 작은 데이터를 전송할 경우를 보겠습니다.
- 기본적으로 1개의 패킷을 전송하기 위해서는 TCP헤더 / IP헤더 / MAC헤더 등의 헤더가 붙게되는데 너무 작은 데이터를 전송하면 이 헤더들로 인해 오히려 트래픽이 증가합니다.
- 즉 현재 잡힌 MTU 1500은 이를 고려한 최적의 수치입니다.

네이글 알고리즘이란?
- 보낼 데이터가 있을때마다 보내는 것이 아니라, 데이터가 MSS만큼 모이거나 상대방에게 ack가 왔을 떄 데이터를 보내는 방법입니다.
- 기본적으로 적용 상태이구요, 이를 사용하면 트래픽을 감소시킬 수 있습니다.
- 왜냐하면, 너무 작은 데이터를 전송하게 되면 각 계층의 헤더가 붙으면서, 모아서 보내는 것 보다 트래픽이 증가하게 됩니다.
- 다만, 모아서 보내기 때문에 클라이언트 입장에서는 응답성이 떨어진다고 느낄 수 있습니다.

콜 바이 밸류 vs 콜 바이 레퍼런스
- 콜 바이 밸류는 일단 함수의 인자로 "값"을 전달하는데요, 이는 말 그대로 값 전달이기 때문에 그 값은 전달한 함수 외부의 변수와는 전혀 상관없어 집니다.
- 콜 바이 래퍼런스는 함수의 인자로 주소 혹은 참조자를 전달하게 되는데요. 이로인해 함수 안에서 함수 외부의 변수에 접근할 수 있게 됩니다.

TCP/IP의 취약점
- TCP는 시퀀스 넘버를 통해 신뢰있는 통신을 하게 되는데요, 만약 누군가가 중간에 패킷을 가로채 이 시퀀스 넘버를 알게된다면 그 유저가 될 수 있습니다.
- 이 방법 중 하나를 하이재킹이라 합니다.
- 자세하게는 모르겠지만, 클라와 서버가 주고받는 패킷을 중계하는 느낌으로 이루어진다고 알고 있습니다.

가상함수란?
- 정의, 동적바인딩, 가상함수 테이블에 대한 설명, 객체 생성시 가상함수 테이블 들어가는 것.

- 상속하는 클래스가 정의하길 기대하는 함수이며 일반 함수와는 다르게 동적바인딩 방식을 따릅니다
- 이게 가능한 이유는, 가상함수 테이블 때문입니다.
- 가상함수 테이블은 키밸류 방식으로 관리되며 실제 가상함수의 주소가 저장되어 있습니다.
- 가상함수가 하나라도 있는 클래스는 컴파일 타임에 가상함수 테이블이 생성됩니다. 그리고 런타임 중 객체가 생성될 때 객체 메모리의 가장 앞에 가상함수테이블을 가리키는 포인터가 추가됩니다.
- 가상함수가 호출될 경우, 이 가상함수테이블 포인터로 가상함수테이블에 접근해, 실제 함수를 호출하게 되는 것입니다.

상속이란?
- 부모 클래스의 특성을 물려받아 자식클래스 자신만의 특성을 더해 새로운 클래스를 정의하는 개념입니다.
- 상속을 사용하면 프로그래머는 코드를 재사용하고, 확장성 좋은 코드를 작성해 개발 속도가 증가하는 장점을 얻게 됩니다.
- 실제 컨텐츠 서버를 제작할 때도 네트워크 모듈을 상속받아 사용했습니다. 새로운 서버를 제작할 때 컨텐츠 로직부분만 신경쓰면 되어 빠른 개발이 가능했습니다.

다형성이란?
- 모양은 같은데 다른기능을 수행한다는 개념입니다.
- 다형성을 통해 사용자는 구현이 아닌, 인터페이스에 종속된 프로그래밍이 가능해 집니다.
- C++에서는 이 다형성을 위해 가상함수를 제공합니다.
- 가상함수는 위 내용 설명..

인터페이스와 추상클래스에 대해 말해보세요
- 추상클래스는, 내부에 순수 가상함수가 1개라도 있어서 객체로 정의가 불가능한 클래스를 의미합니다.
- 인터페이스는, 앞으로 생성될 객체들의 표준을 정의하는 개념입니다. java에서는 interface키워드를 사용한다고 하는데,  C++에서는.. Public 접근제어인 순수 가상함수로만 만들어진 클래스를 인터페이스라고 보면 될 듯 합니다.

오버라이딩과 가상함수에 대해 아는대로 말해보세요
- 개념 설명..
- 오버 라이딩은 가상함수 테이블에 등록되지 않으며 정적 바인딩
- 가상함수는 가상함수 테이블에 등록되며 동적 바인딩

static 키워드에 대해 말씀해 보세요
- 정의 : 접근 가능한 영역을 제한합니다.
- static 전역변수 : 해당 파일에서만 사용하겠다는 의미가 됩니다.
- 함수 내부의 static 지역변수 :  해당 함수에서만 접근하겠다는 의미이며 최초 1회만 초기화됩니다.
- static 멤버 변수 : 해당 클래스 내에 1개만 존재하는 변수가 되며, 객체가 생성되지 않아도 존재합니다.
- static 멤버 함수 : 해당 클래스에서만 접근할 수 있으며, 객체가 생성되지 않아도 존재합니다. 또한 static 멤버변수만 사용할 수 있습니다.

const 키워드에 대해 말씀해 보세요.
- 정의 : 변수나 포인터, 함수를 상수화 시키는 방법입니다.
- 일반 변수 입장에서 const가 붙으면 해당 변수의 값은 더 이상 변경될 수 없습니다.
- const * ptr(const 포인터) : 해당 포인터를 이용해서, 가리키는 대상의 값을 변경하지 않겠다.
- * const ptr (포인터 const) : 해당 포인터가 가리키고 있는 대상을 변경하지 않겠다.
- const 멤버 함수 : 해당 함수안에서는 멤버변수의 값을 변경하지 않겠다는 의미입니다. 하지만 예외적으로 Mutable 키워드를 사용한 변수는 const 멤버함수 내에서도 변경될 수 있습니다.
- 또한 const도 오버로딩의 조건이 될 수 있습니다.

메모리 풀에 대해 아는대로 말해보세요.
- new의 문제 (시스템 콜로 인해 커널모드 전환, 연속된 메모리 확인을 위한 오버헤드)
보통 C++에서 사용하는 new는, 사용자가 요청한 사이즈 만큼의 연속된 메모리가 있는지 확인합니다.
만약 그게 없으면 malloc, 힙얼록, 버추얼얼록을 사용해 새로 메모리를 할당합니다.
이는 굉장힌 오버헤드입니다.

- 장점 (new/delete를 하지 않아 성능적 이점. 단편화 어느정도 방지)
메모리풀은 메모리를 미리 만들어 두고, delete나 free하지 않기 때문에 성능적 이점이 있습니다.
또한, 미리 일정 크기 이상의 메모리를 만들어두는 프리리스트 개념을 사용하기 때문에 메모리 단편화도 어느정도 방지됩니다.

- 사용처
저는 이 메모리풀은 주로 구조체나 클래스를 관리하는 용도로 사용했습니다.
예를들어 채팅서버에서 새로운 유저가 접속할 시 유저 구조체, 새로운 방이 생성될 시 방 구조체 등에 사용했습니다.

락프리 알고리즘에 대한 정의와 장단점을 말해보세요
- 정의 : 여러개의 스레드에서 동시에 작업을 요청했을 때, 정해진 시간마다 최소한 한개의 호출은 성공하는 알고리즘.
- 장점 : 락을 사용할 경우, 빈번한 커널모드 전환으로 오히려 병렬성이 떨어질 수 있습니다. 하지만 락프리를 사용하면 커널모드 전환이 일어나지 않기 때문에 성능적 이점이 있습니다.
- 단점 : CPU 사용율이 높습니다. CAS를 할 때 마다 캐시라인이 틀어져 잘못 사용하면 오히려 성능이 저하될 수 있습니다. 구현이 까다롭습니다.

퀵 정렬에 대해 아는대로 말해보세요
- 최악의 경우 빅오(n2) 평균 경우 빅오(nlogn). 재귀 특성을 사용하는 분할정복법입니다.
- 퀵소트의 경우 모든 데이터가 이미 정렬되어 있고 가장 작은값이 피벗으로 선택되면 최악의 경우가 발생합니다.
- 하지만 median of three라는 중간값을 찾는 방법에 의해 평균적으로 빅오(nlogn)의 성능을 갖습니다.
- 또한 데이터의 이동이 비교에 비해 적고 별도의 메모리 공간을 요구하지 않기 때문에 다른 빅오(nlogn)의 정렬보다 빠르다고 할 수 있습니다.

- 기본 작동법 : 피벗이 들어갈 위치를 찾는것이 핵심.
1) 피벗을 정한다
2) 총 5개의 지점을 설정. [left : 정렬대상 가장 왼쪽], [Right : 정렬대상 가장 오른쪽], [low :피벗을 제외한 가장 왼쪽], [higt : 피벗을 제외한 가장 오른쪽], [피벗 : 중심축]
3) low를 오른쪽 이동. 피벗보다 정렬 우선순위가 낮은 데이터 만날 때 까지 (피벗보다 큰 값을 만날때 까지)
4) higt를 왼쪽 이동. 피벗보다 정렬 우선순위가 높은 데이터 만날 때 까지 (피벗보다 작은 값 만날 때 까지)
5) 위 둘은 서로 별개 이동. while문 뻉뻉 돈다.
6) 둘 다 멈췄는데 low가 high보다 작다면 low와 high의 값 변경
7) low와 high의 위치가 교차되면 정지. 
8) 피벗과 high가 가리키는 값 교환. 이후 제자리를 찾은 값을 기준으로 다시 좌,우 재귀 호출..
9) left와 right의 위치가 역전되면 정렬대상이 없는 것. 종료.

- 주의점 : 모든 데이터가 같을 때는 무한루프에 빠질 수 있기 때문에, >를 >=처럼 같은 조건도 처리해야 함.
- 주의점2 : 이렇게 했을 경우 배열의 경계자체를 벗어날 수도 있으니 경계검사도 해줘야 함.

샤딩은 무엇이고 파티셔닝이랑 무슨 차이가 있는지 말해보세요.
- 샤딩은 하나의 테이블을 로우 단위로 나눠 분산한 것입니다.
- 즉, 1개의 테이블에서 1~100번까지는 A DB에, 101번부터 200번까지는 B DB에 저장하는 형태입니다.

- 파티셔닝 입장에서 보자면 샤딩은, 수평 파티셔닝입니다.
- 수직 파티셔닝은 하나의 테이블을 컬럼 단위로 나눠 분산한 것 입니다.
- 즉 1개의 아이템 테이블을 "아이템 능력치" 테이블과 "아이템 판매가격"테이블과 같은 형태입니다.

- 둘 다 장점은 1개의 테이블에 몰리던 부하를 분산해 속도적 이점이 있습니다.
- 단점은, 특히 샤딩의 경우 물리적으로 분산되어 있기 때문에 트랜잭션과 조인이 불가능해집니다.

스테이트 풀과 스테이트 리스
- 스테이트 풀 : 상태를 서버 메모리에 가지고 있음. 주로 MMO게임서버처럼 서버가 모든 이동을 검증하는 등 입니다.
- 스테이트 리스 : 상태를 DB나 파일 등에 가지고 있음. 주로 웹서버처럼 유저의 정보는 모두 DB에 있고 거기에 읽거나 쓰는 구조입니다.

스테이트 리스의 특징
- 스케일 아웃 가능
- 부하가 DB에 몰림
- 주로 웹.