가상 메모리란?
- 프로세스마다 가상 주소를 할당해, 물리 메모리의 제약을 벗어나기 위한 기법입니다.
- 램 뿐만 아니라 하드디스크까지를 하나의 물리적 메모리로 확장했구요.
- 모든 메모리를 페이지 단위로 분할해 요구 페이징 기법으로 작동합니다.

- CPU와 프로그래머는 다 이 가상 주소로 접근하게 되는데요, 이를 실제 물리메모리로 변경하는 것은 MMU가 해줍니다.
- MMU는 커널 영역 메모리에 있는 페이지 테이블을 이용해서 가상 주소와 물리 주소를 맵핑해줍니다.
- 그리고 이 MMU가 물리메모리에서 원하는 페이지를 찾지 못하는 것을 페이지 폴트라고 합니다.

- 페이지 폴트가 발생하면 페이지 스왑이 진행되고 기존 스레드는 block상태가 됩니다. 
- 근데 만약, 새로 깨어난 스레드가 원하는 페이지가 스왑과정에서 하드디스크로 내려간 페이지일 경우, 또 페이지폴트가 발생하며 스왑이 발생합니다.
- 이 과정이 계속 반복되는것, 즉 과도한 페이징 작업이 발생하는 것을 스레싱 현상이라고 합니다.
- 스레싱이 발생하면 전체적인 성능하락이 발생하는데요. 이를 방지하깅 위해서 프로세스마다 최소한의 페이지프레임을 할당해 주는데, 이를 워킹셋이라 합니다.

인터럽트와 트랩
- 인터럽트는 하드웨어의 신호입니다. 예를 들어 I/O등이 완료되었을 시 인터럽트를 통해 CPU에게 신호를 줍니다.
- 트랩은 소프트 웨어의 신호입니다. 예를 들어 0으로 나누거나 페이지 폴트 등이 발생하면 트랩이 발생합니다.

메모리 계층이란?
- 레지스터/캐시/물리메모리/하드디스크를 의미합니다.
- 각 계층마다 데이터를 주고받는 블럭이 존재합니다.
- 프로그램의 지역적 특성때문에 캐시히트가 발생할 확률이 높기 때문에 메모리 계층은 의미가 있습니다.

스케쥴링 알고리즘에 대해 적어보시오
- 기본적으로 OS는 선점형 OS와 비선점형 OS로 나뉘어집니다.
- 선점형 OS : 우선순위가 높은 스레드가 Ready에 등장할 시 기존에 Running 중인 스레드의 우선순위보다 높다면 cpu 자원을 내주는 방법.
- 비선점형 OS : 우선순위가 높은 스레드가 등장해도 CPU를 점유한 자기 자신이 점유권을 포기하지 않는 이상 다른 스레드는 절대 CPU 자원을 받을 수 없다.
- 그리고 선점형 OS는 라운드 로빈 알고리즘과 우선순위 알고리즘, 그리고 타임슬라이스를 이용해 스케줄링을 진행합니다.

LRU(Least Recently Used)와 LFU(Least frequently used)
- 캐시와 물리메모리에서 희생메모리를 선택할 때 사용하는 방법입니다.
- LRU는 캐시에 올라온지 가장 오래된 메모리를 밀어내는 방법입니다.
- 단점은, 이 오래된 메모리가 곧 사용될 예정일 경우 곧바로 다시 올라와야하기 때문에 합리적이지 않습니다.
- LFU는 가장 적게 사용된 메모리를 밀어내는 방법입니다.
- 단점은, 이 적게 사용된 메모리가 앞으로 쭉 사용될 예정일 경우 곧바로 다시 올라와야하기 때문에 합리적이지 않습니다.
- 각자 장단점이 있습니다.

멀티레벨 피드백 큐(다단계 피드백 큐)
- 선점형 OS가 기본적으로 사용하는 스케쥴링 방법입니다.
- 라운드로빈/우선순위 알고리즘을 사용합니다.
- 이 경우 기아현상이 발생할 수 있는데 이를 해소하기 위한 방법 중 하나가 에이징 기법입니다.

에이징 기법
- 에이징 기법은 우선순위가 낮은 스레드의 우선순위를 점진적으로 늘려 언젠가는 실행되도록 하는 방법입니다.

IOCP란 무엇이고 장점 적어보시오
- 비동기 입출력을 제공하며, 입출력 결과와 결과 처리 스레드를 가지고 있는 구조.
- 합리적인 스레드 풀링 : 기존 컨커런트 모델은 연결 1개당 스레드 1개를 제작. IOCP는 지정한 수 만큼의 스레드를 만들어 많은 연결을 처리. 컨커런트 모델에 비해 스레드 수가 적으므로 컨텍스트 스위칭 부담이 적다.
- wait thread queue는 스택 구조로 관리 : 캐시히트 가능성 증가, 기존에 사용했던 페이지가 물리메모리에 존재할 가능성.

Overlapped I/O 구조의 특징
- 기존의 일반 구조는 I/O요청 후 결과가 나올때까지 사용자는 아무것도 할 수 없는 상황. 
- 오버랩 구조는 I/O를 커널이 처리해주기 때문에 I/O요청 후 사용자는 다른일을 할 수 있다.

actor패턴
- reactor와 proactor가 존재합니다.
- reactor : 이벤트를 등록해두고 이벤트가 가능한 상태인지를 확인합니다.
- proactor : 작업을 등록해두고 작업이 완료될 시 통지를 받음.

스핀락의 장점
- 커널모드로의 전환이 발생하지 않습니다. 임계영역에 점유하고있는 스레드가 빠른시간 안에 작업을 끝낼 가능성이 있다면 스핀을 돌면서 기다리는게 block이 되지 않고 빠릅니다.

MTU에 대해 말씀해보세요
- 최대 전송 단위로 1500byte입니다.
- MTU가 있는 목적은, 재전송 오버헤드를 줄이기 위해서 존재합니다.
- 만약 이런 제한 없이 굉장히 큰 데이터를 전송하게 되면 데이터가 유실되거나 손실되어 재전송을 할 떄 오버헤드가 큽니다.
- 하지만 MTU라는 단위를 두고 이만큼만 전송하게 된다면, 재전송을 할 때 오버헤드가 덜 합니다.
- 그럼 반대로 너무 작은 데이터를 전송할 경우를 보겠습니다.
- 기본적으로 1개의 패킷을 전송하기 위해서는 TCP헤더 / IP헤더 / MAC헤더 등의 헤더가 붙게되는데 너무 작은 데이터를 전송하면 이 헤더들로 인해 오히려 트래픽이 증가합니다.
- 즉 현재 잡힌 MTU 1500은 이를 고려한 최적의 수치입니다.

네이글 알고리즘이란?
- 보낼 데이터가 있을때마다 보내는 것이 아니라, 데이터가 MSS만큼 모이거나 상대방에게 ack가 왔을 떄 데이터를 보내는 방법입니다.
- 기본적으로 적용 상태이구요, 이를 사용하면 트래픽을 감소시킬 수 있습니다.
- 왜냐하면, 너무 작은 데이터를 전송하게 되면 각 계층의 헤더가 붙으면서, 모아서 보내는 것 보다 트래픽이 증가하게 됩니다.
- 다만, 모아서 보내기 때문에 클라이언트 입장에서는 응답성이 떨어진다고 느낄 수 있습니다.

콜 바이 밸류 vs 콜 바이 레퍼런스
- 콜 바이 밸류는 일단 함수의 인자로 "값"을 전달하는데요, 이는 말 그대로 값 전달이기 때문에 그 값은 전달한 함수 외부의 변수와는 전혀 상관없어 집니다.
- 콜 바이 래퍼런스는 함수의 인자로 주소 혹은 참조자를 전달하게 되는데요. 이로인해 함수 안에서 함수 외부의 변수 값을 변경할 수 있게 됩니다. 

TCP/IP의 취약점
- TCP는 시퀀스 넘버를 통해 순서를 보장하게 되는데요, 만약 누군가가 중간에 패킷을 가로채 이 시퀀스 넘버를 알게된다면 그 유저가 될 수 있습니다.
- 이 방법 중 하나를 하이재킹이라 합니다.
- 자세하게는 모르겠지만, 공격자가 클라에게 가거나 클라가 보내는 패킷을 중간에 중계하는 느낌으로 이루어진다고 알고 있습니다.

가상함수란?
- 상속 관계에서, 자식 클래스가 부모 클래스의 함수를 오버라이딩 한 virtual 함수를 의미합니다.
- 그리고 이 가상함수는 객체지향에서 다형성의 핵심입니다.
- 다형성이란 모양은 같은데 다른 기능을 수행하는 것을 의미하며 다형성을 통해 관리적 편리함을 얻게되고, 확장성이 좋으면서 느슨한 결합 프로그래밍이 가능해 집니다.

상속이란?
- 부모 클래스의 특성을 물려받아 자식클래스 자신만의 특성을 더해 새로운 클래스를 정의하는 방법 입니다.
- 상속을 사용해 프로그래머는 코드를 재사용하고, 확장성 좋은 코드를 작성할 수 있게 됩니다.
- 실제 네트워크 모듈을 만들때, 가상함수와 상속을 이용했는데요. 이는 실제 네트워크 모듈은 송수신 부분만 담당하고 상속받는 컨텐츠 서버가 자신의 특성, 즉 패킷에 대한 처리부분을 추가해 새로운 클래스를 정의한 것입니다.
- 이렇게 함으로써 명확하게 네트워크 부분과 컨텐츠 부분을 나눌 수 있게 되었습니다.

네트워크 모듈에 대해 설명해보세요
- 네트워크 모듈이란, Recv/Send등의 네트워크 송수신을 처리하는 모듈입니다.
