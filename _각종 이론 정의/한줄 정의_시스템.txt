시스템 프로그래밍이란?
- 컴퓨터에게 일을 시키는 프로그래밍.
- 윈도우즈 시스템 프로그래밍은 windows OS기반의 컴퓨터에게 일을 시키는 프로그래밍을 의미한다.

CPU란?
- 중앙처리장치. 연산을 담당하는 핵심 부품.
- 크게 [ALU, 레지스터, 버스인터페이스, 컨트롤 유닛]으로 나뉜다.

ALU
- CPU 내부의 블록 중 실제 연산을 담당한다.
- 이 외 CPU 내부 블록은 모두 연산을 도와주는 블록들이다.
- 산술연산 / 논리연산 총 2개의 연산을 한다.

컨트롤 유닛
- 실제 명령은 1001100 00000001 과 같이 이진수로 들어온다.
- ALU는 산술/논리연산만 가능하기때문에 뭔말인지 모른다. 
- 이를 해석 후 적절한 신호(덧셈해라! 논리연산해라! 등..)를 CPU의 다른 블록에게 보내는 역활이 컨트롤 유닛이다.

레지스터
- CPU내부에 존재하는 임시 저장 장치
- 컨트롤 유닛이나 ALU가 필요로 하는 명령어 및 데이터를 저장한다.
- ir(instruction register) : 메모리 Code영역의 코드를 저장해두는 레지스터. 다음에 실행될 명령어 저장
- pc(program counter) : 다음에 가져올 명령어를 가리킨다. 코드 영역(메모리)의 주소를 가리킴
- sp(stack pointer) : 이번에 실행될 스택의 위치. 스택 영역의 주소를 가리킴.
- fp(frame pointer) : sp의 백업. 함수 call 후 sp가 돌아갈 위치(ret)를 저장한다. 반복적으로 함수 call 시, 기존의 fp는 스택에 저장한 후 현재 sp를 fp에 저장하는 식의 테크닉 사용
- lr(Link Register) : pc의 백업. fp처럼 작동하는데 pc를 백업한다.

버스 인터페이스
- 컴퓨터 구성요소는 입출력 버스로 데이터를 주고받는데, 이는 나름의 규칙이 있다.
- 이 규칙을 해석하는 것이 버스 인터페이스이다. 
- 각 장치마다 존재한다.

클럭신호
- CPU가 일을 하는 단위. 1클럭에 일을 한 번 한다.
- 클럭신호가 높으면 초당 처리하는 명령어의 수가 많아져서 컴퓨터 성능은 올라간다
- 하지만, 각 장치마다 각자 일을 처리하는 속도가 다르기 때문에 무조건 빠르게 하면 안되고, 가장 속도가 느린 장치에 맞춰서 클럭 신호를 발생시켜야 동기화가 맞는다.
- 클럭 신호는 클럭발생기(오실레이터)가 발생시킨다.

메인 메모리란?
- 휘발성 저장장치
- 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역

입출력 버스란?
- 컴퓨터 구성요소 사이에 데이터를 주고받는 통로.
- 어드레스 버스 / 데이터 버스 / 컨트롤 버스 총 3개로 이루어진다.
- 어드레스 버스 : 주소값을 이동하기 위한 버스
- 데이터 버스 : 데이터를 이동하기 위한 버스
- 컨트롤 버스 : CPU가 원하는 바를 메모리에 전달할 때 사용 (CPU가 메모리에게 "데이터를 보내달라" 등의 요청을 할 때)

폰노이만 아키텍처
- "프로그램라는 것이 존재하며, 이 프로그램은 컴퓨터 내부에 저장되어 순차적으로 실행" 된다는 것.
- Stored Program Concept 라고도 불린다.

컴파일 과정
- 전처리기 --> 컴파일러 --> 어셈블러 --> 링커
- 전처리기 : #이 붙은 전처리 지시자에 의한 소스코드를 적절히 변경 (.i)
- 컴파일러 : 전처리 된 소스코드(C언어 코드)를 어셈블리로 변경 (.s)
- 어셈블러 : 컴파일러에 의해 어셈블리로 언어로 변경된 코드를 바이너리 코드로 변경 (.o)
- 링커 : 각 바이너리 코드를 1개로 묶어 실행파일로 만드는 작업 (.exe) 
- 이 실행파일을 실행하면, 프로그램 코드가 메모리에 올라가게 된다.

프로그램 실행 과정
- Fetch --> Decode --> Excution
- Fetch : 메모리상에 존재하는 명령어를 CPU의 IR(Instruction Register)로 가져온다. 입출력버스를 이용한다.
- Decode : IR에 있는 명령어를 해석한다. 해석한 명령은 ALU에게 전달한다.
- Excusion : ALU가 실제 명령을 실행한다.



문자셋이란?
- 문자들의 집합. 약속된 문자 표현 방법

Single Byte Character Set
- 1바이트를 사용하는 문자 셋. 아스키 코드.

Multi Byte Character Set
- 다양한 바이트를 사용하는 문자 셋. 어떤 문자는 2바이트, 어떤 문자는 3바이트로 표시.
- MBCS는 SBCS를 포함하는 개념이다. 때문에 유니코드는 MBCS가 아니다!!!

Wide Byte Character Set
- 모든 문자를 2바이트로 표현하는 문자 셋.
- 이게 유니코드!! 

유니코드
- 균일하게 2바이트로 모든 문자를 표현.
- 단순히 "표"일 뿐.
- 예를 들어 A라는 글자는 0x01로 맵핑되어 있으며 "한"이라는 글자는 0x87로 맵핑된 것이다.

MBCS의 문제점
- 영어는 1바이트, 한글은 2바이트 처럼 문자가 균일하지 않게 표시된다.
- 코딩 시, 어떤 char형 문자열을 출력할 때 "ABC한글"은 문자열 길이가 5일것 같지만 ABC(3) + 한글(4)로 총 7이 나온다.
- 이 때문에 주의깊게 코딩을 할 필요가 있다.
- 이를 해결하기 위한 것이 모든 글자를 동일한 바이트로 표시하는 WBCS이다.

인코딩이란?
- 단순히 문자를 저장하는 방식일 뿐이다. 
- UTF-8 : 유니코드를 저장하는 방식. 한 글자를 저장하는데 1바이트를 기본으로 한다. 예를들어 영어는 1바이트로 저장되며, 혹시 한글이 저장될 경우 1바이트 이상으로 저장된다.
- UTF-16 : 유니코드를 저장하는 방식. 한 글자를 저장하는데 2바이를 기본으로 한다. 예를들어 영어도 2바이트, 한글도 2바이트이며 그 이상의 크기는 2바이트 이상으로 저장된다.

BOM이란?
- Byte Order Mark
- 해당 파일의 리틀엔디안/빅엔디안 같은 바이트 순서와 인코딩 방식을 지정한다.
- 저장된 파일 가장 앞에 표시된다.

BOM이 저장된 파일의 Text모드/Binary모드 오픈
- fopen으로 파일을 열면 BOM을 건너뛰고 읽어온다.
- 바이너리 모드로 열면 BOM도 같이 읽어온다. 이 경우, 직접 BOM만큼 파일포인터를 이동한 후 사용해야 한다.

BOM으로 인한 문제
- 리눅스와 제이슨에서는 BOM이 있으면 에러가 발생한다.
- 때문에, BOM을 제거한 후 사용해야 한다.

중립 자료형
- MBCS와 WBCS를 동시지원하며, 컴파일러 환경에 따라 둘 중 하나를 선택해준다.
- 전처리 과정에서 처리된다.
- 장점 : 이식성이 좋다.

32비트 아키텍쳐와 64비트 아키텍쳐의 차이점
- 컴퓨터 내부 구성요소들이 한 번에 송/수신할 수 있는 데이터 크기와 한 번에 처리할 수 있는 데이터 크기를 기준으로 결정

64비트는 32비트에 비해 뭐가 좋은가?
- 이론적으로 32비트보다 2배 더 많이 작업을 처리하기 때문에 2배 속도 증가
- 그리고 프로그래머가 사용 가능한 주소값 범위가 증가
(32비트에서 64비트로 증가. 이는 한 번에 처리 가능하고 송수신 가능한 최대 크기)
- 기존 32비트는 4G, 64비트는 16테라바이트의 공간 사용 가능
- 이로 인해 메모리 부족 문제는 완전히 사라졌다.

Polymorphic 자료형이란?
- 다형성 자료형.
- 상황에 따라 다르게 선언되는 자료형을 의미한다.
- 예를들어 LONG_PTR은 32비트에서는 4바이트 / 64비트에서는 8바이트로 선언된다.
- 참고로 PTR은 포인터의 의미가 아니라 포인터값 기반의 연산을 위해 정의되었기 때문에 붙은 이름이다.

LLP64와 LP64
- 데이터 표현 모델
- LLP64 : 윈도우에서 채택. long을 4바이트로 처리. 나머지는 동일
- LP64 : UNIX에서 채택. long을 8바이트로 처리. 나머지는 동일


명령어와 레지스터의 관계
- 명령어는 레지스터에 종속적이다.
- 레지스터 구성형태에 따라 명령어 구조가 달라진다
- 때문에 어셈블리 언어로 구현된 프로그램은, 작성 당시의 CPU와 구조가 다르면 실행 불가능하다

RISC와 CISC
- 명령어 구성에는 CPU성능과 비용 등으로 인해 각종 제약이 발생한다. 이 제약에 따라 CPU의 구조를 구분한다.
- 이 2개는 CPU의 구조적 특징에 따라 분류된다.

CISC(Complex Instruction Set Computer)
- 복잡한 명령어 체계를 가지는 컴퓨터
- 장점 : 명령어가 많다는 것은 프로그램 구현이 편리하다는 것.
- 단점 : 명령어 수가 많고, 크기가 일정하지 않기 때문에 CPU는 복잡해진다. 이에 따라 성능 하락 발생

RISC(Reduced Instruction Set Computer)
- CISC에서 실제 사용하는 명령어는 10%라는것에 착안해 만들어진 구조.
- 명령어 수를 대폭 줄이고 명령어 크기를 일정하게 디자인
- 장점 : 명령어 크기가 일정해짐에 따라 Pipelining 가능. 이로인한 속도 증가

Direct Addressing모드와 Indirect Addressing모드
- 메모리에 접근하는 방식

Direct Addressing모드
- 주소값이 가리키는 곳의 값을 데이터로 사용
- 단점 : 명령어 중 일정 부분만 주소값을 가리키도록 사용한다(명령어가 16비트일 경우, 8비트만 주소값을 가리키는 등..). 때문에 메모리의 모든 영역에 접근이 불가능한 상황이 발생한다.

Indirect Addressing모드
- 주소값이 가리키는 곳의 값을 주소로 판단. 그리고 그 주소가 가리키는 곳의 데이터를 가져온다.
- Direct모드의 문제점을 개선.





헤더와 CPP 분리 이유
- 헤더와 CPP가 1개의 파일에 있으면, 해당 파일을 include할 때 오래 걸린다 ---> 컴파일 시간 증가
- 헤더의 인터페이스만 제공해 사용자로 하여금 CPP를 몰라도 되도록 한다.

프로세스란?
- 메모리에 올라가 실행중인 프로그램
- 메모리 구조(코드영역, 데이터 영역, 스택 영역, 힙 영역) + Register Set을 프로세스라고도 한다.

스레드란?
- 프로세스가 할당받은 자원을 사용하는 프로세스 내부의 흐름.
- 실제로 CPU에게 시간을 할당받아 프로세스 주소공간에 있는 코드를 실행하고 데이터를 사용.
- 메모리 스택 + Register Set을 스레드라고도 한다.

프로세스와 스레드의 차이점은?
- 프로세스는 실행중인 프로그램을 의미하며, 스레드는 그 프로그램 내부의 흐름을 의미한다.

Data 영역
- 전역변수, 정적변수(static 변수)의 할당을 위한 공간

스택
- 지역변수와 매개변수(함수 호출 시 전달되는 인자값)가 저장되는 공간

힙 이란
- 동적 메모리 할당을 위한 공간.

Code 영역
- 실행 파일을 구성하는 명령어들이 올라가는 영역

스케쥴링이란?
- 프로세스나 스레드의 CPU 할당 순서 및 할당 방법을 결정하는 일.
- 목적 : 프로그램이 동시에 실행되는 것 처럼 보이게 하는 위함

스케쥴링 알고리즘이란?
- 스케쥴링에 사용되는 알고리즘
- 라운드 로빈 등이 존재한다.

스케쥴러란?
- 실제 스케쥴링을 하는 운영체제의 소프트웨어 모듈.
- CPU 입장에서는 스케쥴러도 하나의 프로세스일 뿐이다.

멀티 프로세스 관리 방법과 그 이유
- 모든 프로세스를 실행시킨 후 스케쥴러에 의해 CPU 시간을 할당받아 실행한다.
- 이유 : 대부분의 프로그램은 I/O에 많은 시간을 사용한다. 이 I/O를 하는 동안 다른 프로세스에게 일을 시키는것이 효율적이다.

스케쥴링 작동 기본 룰
- 각 스레드마다 타임 슬라이스(15.6m/s. 타이머 인터럽트에 의한 시간) 만큼의 시간 할당
- 할당받은 시간을 다 쓰거나, 해당 스레드가 block 상태가 될 경우, 우선순위를 고려한 라운드 로빈의 룰에 따라 CPU에 올라갈 스레드가 결정된다.
- 스레드가 선택되면 Running 상태의 스레드를 Ready혹은 Block으로 변경 후 Ready의 스레드를 Running으로 올린다.

프로세스의 상태와 각 상태가 되는 상황(스레드의 상태)
- Ready / Running / Blocked 총 3개의 상태

Ready 상태가 되는 경우
- 이제 막 생성된 스레드
- Blocked였다가 작업이 끝난 스레드
- Running이였는데 타임슬라이스가 끝난 스레드
- Running이였는데 나보다 우선순위가 높은 스레드가 Ready에 추가될 경우, 타임슬라이스가 남았더라도 Ready가 된다.

Running이 되는 경우
- Ready였다가 스케쥴러에 의해 선택된 스레드

Blocked가 되는 경우
- Running 중이었는데 I/O작업 등에 의해 스레드가 멈추는 상황. (데이터 I/O, 소켓 I/O, Sleep등의 함수 호출)

Ready와 Running의 차이점
- 스케쥴러에 의해 선택될 수 있느냐 없느냐의 차이

CreateProcess의 주의점
- 프로세스로 전달할 문자열은 변수 형태여야 한다.
- 왜냐하면, 함수 내부에서 인자로 받은 문자열에 변경을 가하기 때문이다. 상수 형태로 전달하면 문자열 변경이 불가능.
- 컴파일 타임에는 멀쩡하지만 런타임때 에러가 발생한다.

완전 경로
- 풀 경로

현재 디렉터리
- 어떤 파일을 찾을 때 기본이 되는 디렉터리
- 프로세스 생성 시, 실행파일이 존재하는 곳이 현재 디렉터리.
- 사용자는 현재 디렉토리 이후의 정보만 전달하면 된다.

커널
- OS중에서도 실제 핵심 영역을 커널이라 한다.

커널 오브젝트란?
- 커널이 관리하는 정보를 모아둔 데이터 블록.
- 커널에 의해 생성/소멸된다.
- 커널 오브젝트 종류에 따라, 다른 형태의 오브젝트를 생성한다. 각자 관리해야하는 정보가 다르기 때문이다.

프로세스 생성 주체
- 실제로는 커널이 생성한다. 우리는 생성을 요청하는것 뿐.

Busy Wating이란?
- 스레드가 하는 의미없는 루프를 돌면 다음줄이 실행되지 않기 때문에 스레드가 멈춘것 처럼 보인다.
- 이걸 Busy Wating이라 한다.
- 이 때 스레드는 Running 상태이다.

커널 오브젝트 핸들이란?
- 커널 오브젝트를 생성한 후 할당된 숫자.
- 사용자에게 제공될 수 있으며, 사용자는, 이 핸들과 함수 호출로 커널 오브젝트에 접근할 수 있다.
- 프로세스에 종속적!!!! 핵심 !!! 커널 오브젝트는 운영체제에 종속적!!!

커널 오브젝트 핸들은 프로세스에 종속적이다. 그 의미는?
- 동일한 커널 오브젝트에 접근하더라도, 그 오브젝트에 접근할 수 있는 핸들은 프로세스마다 다르다.
- 즉, A프로세스의 100번 핸들과 B프로세스의 100번 핸들은 동일한 커널 오브젝트를 가리키지 않을 수도 있다.

커널 오브젝트는 운영체제에 종속적이다. 그 의미는?
- 커널 오브젝트는 어떤 프로세스든 접근 가능하다. 
- 커널 오브젝트의 실질적인 생성/삭제/관리는 커널이 한다. 프로세스는 단지 핸들을 통해 접근 권한만 있는 것 뿐이다.

Usage Count란?
- 커널 오브젝트에 존재하는 참조 카운트.
- 모든 커널 오브젝트는 생성 시, Usage Count가 1이 된다.
- 그 외에도, 접근 대상이 생길 때 마다 Usage Count가 1씩 늘어난다.
- 부모/자식 관계의 프로세스의 경우 부모도 자식을 참조하기 때문에 1이 늘어난 것.
- CloseHandle 시 1 감소. 프로세스나 스레드의 경우에는, 종료 시점에 자기 자신의 Usage Count 1 감소
- 0이되면 커널 오브젝트는 소멸된다.

CloseHandle란?
- 나의 핸들테이블에서 해당 커널 오브젝트의 정보를 제거하며, Usage Count 1 감소
- 극단적으로 말해, 프로세스가 종료되어도 다른 누군가가 해당 프로세스 커널 오브젝트를 참조중이라면 커널 오브젝트는 소멸되지 않는다.
- CloseHandle은 이 Usage Count를 감소시키는 역활을 한다.

Usage Count의 존재 이유
- 커널 오브젝트 종료시기와 프로세스 종료시기가 동일할 경우 문제가 발생한다.
- 예를들어 자식의 종료코드는 자식의 커널 오브젝트에 저장된다.
- 때문에 자식 프로세스가 종료되었다고 바로 자식 프로세스를 종료하면, 부모는 자식의 종료코드를 받을 수 없다.

프로세스간 통신 기법이 존재하는 이유
- 프로세스는 개별적인 메모리 공간을 사용한다.
- 때문에 프로세스간에 데이터를 주고 받기 위해서는 OS가 기능을 제공해야 한다.

프로세스가 별로 메모리 공간이 존재하는 이유
- 안정성을 높이기 위함.
- 이렇게 안하면 서로 메모리 침범으로 프로세스에 문제가 생길 수 있다.

메일슬롯
- 일종의 우체통(메모리 공간)을 두어 데이터를 주고 받는 방법
- 우체통을 메일 슬롯이라 한다.
- Receiver가 메일슬롯을 만들어 두면(CreateMailslot), Sender는 거기에 접근해(CreateFile) 데이터를 보낸다.
- Receiver는 메일슬롯에 데이터가 들어오면 block상태에서 깨어나며, 데이터를 Read한다.

메일슬롯의 특징
- 단방향 통신만 가능. 양방향 통신을 하고 싶으면, 서로가 Receiver와 Sender가 되어야 한다.
- 브로드 캐스팅 지원. Sender는 한번의 메시지 전송으로 n명의 Receiver에게 데이터 보내기 가능

커널 오브젝트의 상태
- Signaled / Non-Signaled
- 커널 오브젝트에 멤버변수로 존재한다.
- 커널 오브젝트에 따라 상태가 변하는 시점이 다르다.

프로세스/스레드의 커널 오브젝트 상태
- 최초 생성 시 Non-Signaled. 종료 시 Signaled 상태.
- 즉, 종료 신호를 받았는지 받지 않았는지를 기준으로 체크하면 될듯.
- 프로세스/스레드는 한번 Signaled 상태가 되면 Non-Signaled상태가 될 수 없다.

커널 상태를 확인하는 함수
- WaitForSingleObject / WaitForMultipleObject
- 정상적인 경우 커널 상태가 Signaled가 되면 리턴

프로세스 핸들 테이블
- 프로세스마다 생성되며 해당 프로세스가 참조하는 커널 오브젝트 보관.
- 핸들(숫자) / 커널 오브젝트의 주소 / 상속 여부 보관

핸들 테이블의 상속
- 자식 프로세스 생성 시, [핸들 테이블 상속 / 핸들 상속 여부] 총 2개의 속성을 결정해야 한다.

부모의 핸들테이블 상속
- 핸들 테이블의 특정한 핸들만 상속하는것은 불가능.
- 부모의 핸들 테이블 중 상속 여부가 TRUE인 모든것을 상속
- 상속 시, 모든 값(핸들 값, 커널 오브젝트 주소, 상속 여부)가 상속된다.

생성하는 자식 프로세스의 핸들 상속
- 이번에 생성하는 자식 프로세스를 부모의 핸들테이블에 등록할 때, 핸들테이블의 [상속 여부]를 TRUE로 할 것인지

핸들을 얻는 시점
- 핸들 정보가 핸들 테이블에 등록될 때, 핸들을 얻었다고 한다.

가짜 핸들
- GetCurrentProcess() 함수를 이용하면 현재 프로세스의 핸들을 얻을 수 있다.
- 하지만 이는 사실 -1같은 약속된 값일 뿐 실제 핸들테이블의 핸들이 아니다.

가짜 핸들의 특징
- CloseHandle을 할 필요 없음
- 자식 프로세스로 상속되지 않음.

현재 프로세스의 진짜 핸들을 얻는 방법
- DuplicateHandle()를 사용.
- GetCurrentProcess()를 이용해 얻은 핸들값(-1)을 Duplicate한다면 진짜 핸들이 생성된다.
- DuplicateHandle을 사용할 경우, Usage Count도 증가하기 때문에 CloseHandle을 해야 한다.

부모 프로세스의 핸들을 자식 프로세스에게 전달 방법
- DuplicateHandle을 이용해 부모 프로세스의 핸들테이블에 자신을 가리키는 핸들값 생성
- 자식 프로세스를 생성할 때 핸들 테이블 상속
- 자식에게 어떻게든 부모의 핸들값에 등록된 자신을 가리키는 핸들값을 전달.

이름없는 파이프
- 단방향 통신
- 핸들 테이블 상속을 통해, 부모 자식간에 통신 가능
- 관계있는 프로세스들 사이에서 사용

이름있는 파이프
- 양방향 통신
- 생성한 이름있는 파이프를 통해 통신.

프로세스 환경변수
- 프로세스마다 별도의 문자열을 보관할 수 있는 Key = Value 형태의 메모리 공간을 환경변수라 한다.
- 부모 : 자식의 환경변수 변경 가능 / 자기 자신의 환경변수 상속 가능



컨텍스트 스위칭이란?
- 현재 CPU가 실행중인 스레드를 멈추고 Ready상태의 스레드 중 하나가 일을 할 수 있도록 전환하는 작업.
- PCB 혹은 TCB를 교체하는 작업이다.

쓰레싱 현상이란?
- 페이지폴트로 인해 스레드가 일을 하지 못하는 과도한 페이징 작업.

워킹셋이란?
- 프로세스 가상 메모리 중에, 실제 RAM에 올라가 있는 페이지들을 워킹셋이라 한다.
- 목적 : 자주 사용하는 것들을 올려두어, 최대한 페이지 폴트, 스왑파일 과정 없이 데이터를 참조하게 한다.
- Code 영역 / Data 영역이 포함

커밋 메모리란?
- 실제 해당 프로세스에게 할당된 페이지
- HDD의 페이지 파일에도 커밋된 메모리가 존재할 수 있다.

Sleep(0)와 switchToThread의 공통점
- 현재 나의 타임슬라이스를 포기한 후 다른 스레드에게 남은 시간을 양도한다 
- 15.6m/s중 10m/s만 쓴 후에 위 함수를 호출하면 남은 5.6m/s를 다른 스레드가 일한다

Sleep(0)와 switchToThread의 차이점
- switchToThread는 자신이 실행중이던 프로세서의 ready상태 스레드 중 하나에게 양보한다. ready스레드가 아무도 없다면 자신이 다시 올라온다.
- Sleep(0)은 자신이 실행중이던 프로세서 외 다른 프로세서의 스레드 중 ready상태의 스레드 하나를 골라 양보한다.
만약, 모든 프로세서에 ready중인 스레드가 하나도 없으면 자신이 다시 올라온다.
- 과거의 Sleep(0)은 자신보다 우선순위가 높거나 같은 스레드가(자신이 3이면 0~3까지) ready에 있을 경우 양보했으며, 없을 경우 자기 자신이 다시 올라왔다.

스레드 생성 시 주의점
- _beginthreadex()를 사용해야한다.
- 왜냐하면 기존의 CreateThread는 C런타임 라이브러리 사용 시 스레드 safe하지 않기 때문이다.
- _beginthreadex()를 사용하면 tid 데이터 블록이 생성된다. 이 블록이 C런타임 라이브러리를 안전하게 사용할 수 있도록 해준다.

스레드 종료 방법
- 스레드 함수가 리턴
- ExitThread()함수 호출	-	비정상
- TerminateThread()함수 호출	- 비정상

스레드 종료 방법 중 정상적인것은?
- 스레드 자신이 종료하는것이 좋음.
- 왜냐하면, class의 소멸자는 스코프 종료 시점에 코드가 박히기 때문에, 스레드를 강제로 종료하면 해당 코드를 실행하지 않고 나간다. 그러면 어떻게 작동할지 모름
- 그리고 동적할당한 메모리도 보통 return 전에 해제할텐데 누수도 난다.

스레드 우선순위란?
- 스케쥴러가 CPU로 올릴 스레드를 선택하는 기준. 우선순위가 높은 스레드가 먼저 선택된다.
- 프로세스 우선순위(우선순위 클래스) : 프로세스의 속성이며, 이 프로세스의 스레드는 모두 우선순위 클래스가 같음
- 스레드 우선순위(우선순위 레벨) : 스레드 속성.
- 이 2개를 합쳐 기본 우선순위가 결정된다.

기아현상이란? (starvation)
- 계속 높은 우선순위의 스레드만 CPU를 할당받아 우선순위가 낮은 스레드는 일을 하지 못하는 상황
- 이를 방지하기 위해, OS는 오랜시간 CPU시간을 할당받지 못한 스레드의 우선순위를 서서히 끌어올린다.

컴파일 최적화기능은?
- 컴파일러가 최적의 속도를 낼 수 있도록 합리적으로 기계어를 만들어내는 기능
- 단점은, 내가 원하는대로 작동하지 않을 수도 있다.
- Debug모드에서는 적용되지 않는다.

volatile이란?
- 컴파일에게 이 변수만큼은 최적화 하지 말라는 명령
- 레지스터에 있는 값에 바로 접근하는게 아니라 실제 물리메모리에서 값을 가져오도록 한다. (레지스터를 쓰긴 함)

DLL 맵핑
- 기본적으로 DLL은 자신이 맵핑되고 싶은 가상메모리 주소가 있다. (예를 들어 0x10000)
- 프로세스 A에서는 가상메모리 0x10000이랑 물리메모리의 어딘가와 맵핑이 되었다.
- 근데 프로세스 B가 동일한 DLL을 가상메모리 0x10000과 맵핑하기 싶은데 이미 누군가가 0x10000을 사용 중일 경우, 프로세스 B를 위해 해당 DLL이 다시 물리메모리로 올라오며, 그 물리메모리와 0x10000이 아닌 다른 가상주소와 맵핑된다.

MMU란?
- CPU에 있는 하드웨어. 물리 메모리와 가상 메모리를 맵핑시켜 준다. (Memory Mapping Unit)

가상메모리를 사용하는 이유
- 사용자에게 메모리 공간 제약이 없도록 하기 위함
- 각자 영역을 나눠두지 않으면, 무분별한 메모리 침범으로 다른 프로세스에 영향을 끼칠 가능성.