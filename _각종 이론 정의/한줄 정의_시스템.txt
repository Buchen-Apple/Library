시스템 프로그래밍이란?
- 컴퓨터에게 일을 시키는 프로그래밍.
- 윈도우즈 시스템 프로그래밍은 windows OS기반의 컴퓨터에게 일을 시키는 프로그래밍을 의미한다.

CPU란?
- 중앙처리장치. 연산을 담당하는 핵심 부품.
- 크게 [ALU, 레지스터, 버스인터페이스, 컨트롤 유닛]으로 나뉜다.

ALU
- CPU 내부의 블록 중 실제 연산을 담당한다.
- 이 외 CPU 내부 블록은 모두 연산을 도와주는 블록들이다.
- 산술연산 / 논리연산 총 2개의 연산을 한다.

컨트롤 유닛
- 실제 명령은 1001100 00000001 과 같이 이진수로 들어온다.
- ALU는 산술/논리연산만 가능하기때문에 뭔말인지 모른다. 
- 이를 해석 후 적절한 신호(덧셈해라! 논리연산해라! 등..)를 CPU의 다른 블록에게 보내는 역활이 컨트롤 유닛이다.

레지스터
- CPU내부에 존재하는 임시 저장 장치
- 컨트롤 유닛이나 ALU가 필요로 하는 명령어 및 데이터를 저장한다.
- !!! CPU의 모든 연산은 일단 레지스터에 있어야 한다 !!!
- !!! +를 해도, 피 연산자 2개가 이미 레지스터에 있어야 한다 !!!
- sp(stack pointer) : 스택 중 데이터가 저장된 위치. 스택 영역의 주소를 가리킴.
- fp(frame pointer) : sp의 백업. 함수 call 후 sp가 돌아갈 위치(ret)를 저장한다. 반복적으로 함수 call 시, 기존의 fp는 스택에 저장한 후 현재 sp를 fp에 저장하는 식의 테크닉 사용
- ir(instruction register) : 메모리 Code영역의 코드를 저장해두는 레지스터. 다음에 실행될 명령어 저장
- pc(program counter) : 다음에 가져올 명령어를 가리킨다. 코드 영역(메모리)의 주소를 가리킴. 명령어를 순차적으로 Fetch하기 위함.
- lr(Link Register) : pc의 백업. fp처럼 작동하는데 pc를 백업한다.

버스 인터페이스
- 컴퓨터 구성요소는 입출력 버스로 데이터를 주고받는데, 이는 나름의 규칙이 있다.
- 이 규칙을 해석하는 것이 버스 인터페이스이다. 
- 각 장치마다 존재한다.

클럭신호
- CPU가 일을 하는 단위. 1클럭에 일을 한 번 한다.
- 클럭신호가 높으면 초당 처리하는 명령어의 수가 많아져서 컴퓨터 성능은 올라간다
- 하지만, 각 장치마다 각자 일을 처리하는 속도가 다르기 때문에 무조건 빠르게 하면 안되고, 가장 속도가 느린 장치에 맞춰서 클럭 신호를 발생시켜야 동기화가 맞는다.
- 클럭 신호는 클럭발생기(오실레이터)가 발생시킨다.

메인 메모리란?
- 휘발성 저장장치
- 컴파일이 완료된 프로그램 코드가 올라가서 실행되는 영역

입출력 버스란?
- 컴퓨터 구성요소 사이에 데이터를 주고받는 통로.
- 어드레스 버스 / 데이터 버스 / 컨트롤 버스 총 3개로 이루어진다.
- 어드레스 버스 : 주소값을 이동하기 위한 버스
- 데이터 버스 : 데이터를 이동하기 위한 버스
- 컨트롤 버스 : CPU가 원하는 바를 메모리에 전달할 때 사용 (CPU가 메모리에게 "데이터를 보내달라" 등의 요청을 할 때)

폰노이만 아키텍처
- "프로그램이라는 것이 존재하며, 이 프로그램은 컴퓨터 내부에 저장되어 순차적으로 실행" 된다는 것.
- Stored Program Concept 라고도 불린다.

컴파일 과정
- 전처리기 --> 컴파일러 --> 어셈블러 --> 링커
- 전처리기 : 전처리 지시자에 의한 소스코드를 적절히 변경 (.i)
- 컴파일러 : 전처리 된 소스코드(C언어 코드)를 어셈블리로 변경 (.s)
- 어셈블러 : 컴파일러에 의해 어셈블리로 언어로 변경된 코드를 바이너리 코드로 변경 (.o)
- 링커 : 각 바이너리 코드를 1개로 묶어 실행파일로 만드는 작업 (.exe) 
- 이 실행파일을 실행하면, 프로그램 코드가 메모리에 올라가게 된다.

프로그램 실행 과정
- Fetch --> Decode --> Excution
- Fetch : 메모리상에 존재하는 명령어를 CPU의 IR(Instruction Register)로 가져온다. 입출력버스를 이용한다.
- Decode : IR에 있는 명령어를 해석한다. 해석한 명령은 ALU에게 전달한다.
- Excusion : ALU가 실제 명령을 실행한다.



문자셋이란?
- 문자들의 집합. 약속된 문자 표현 방법

Single Byte Character Set
- 1바이트를 사용하는 문자 셋. 아스키 코드.

Multi Byte Character Set
- 1~2바이트를 사용 : 영어는 1바이트 아스키, 한글은 2바이트 완성형
- MBCS는 SBCS를 포함하는 개념이다. 때문에 유니코드는 MBCS가 아니다!!!

Wide Byte Character Set
- 문자 하나에 2바이트 이상 사용
- 이게 유니코드!! 

유니코드
- 단순히 "표"일 뿐.
- 예를 들어 A라는 글자는 0x01로 맵핑되어 있으며 "한"이라는 글자는 0x87로 맵핑된 것이다.

인코딩이란?
- 단순히 문자를 저장하는 방식일 뿐이다. 
- UTF-8 : 유니코드를 저장하는 방식. 한 글자를 저장하는데 1바이트를 기본으로 한다. 예를들어 영어는 1바이트로 저장되며, 혹시 한글이 저장될 경우 1바이트 이상으로 저장된다.
- UTF-16 : 유니코드를 저장하는 방식. 한 글자를 저장하는데 2바이를 기본으로 한다. 예를들어 영어도 2바이트, 한글도 2바이트이며 그 이상의 크기는 2바이트 이상으로 저장된다.

MBCS의 문제점
- 영어는 1바이트, 한글은 2바이트 처럼 문자가 균일하지 않게 표시된다.
- 코딩 시, 어떤 char형 문자열을 출력할 때 "ABC한글"은 문자열 길이가 5일것 같지만 ABC(3) + 한글(4)로 총 7이 나온다.
- 이 때문에 주의깊게 코딩을 할 필요가 있다.
- 이를 해결하기 위한 것이 모든 글자를 동일한 바이트로 표시하는 WBCS이다.

BOM이란?
- Byte Order Mark
- 해당 파일의 리틀엔디안/빅엔디안 같은 바이트 순서와 인코딩 방식을 지정한다.
- 저장된 파일 가장 앞에 표시된다.

BOM이 저장된 파일의 Text모드/Binary모드 오픈
- fopen으로 파일을 열면 BOM을 건너뛰고 읽어온다.
- 바이너리 모드로 열면 BOM도 같이 읽어온다. 이 경우, 직접 BOM만큼 파일포인터를 이동한 후 사용해야 한다.

BOM으로 인한 문제
- 리눅스와 제이슨에서는 BOM이 있으면 에러가 발생한다.
- 때문에, BOM을 제거한 후 사용해야 한다.

중립 자료형
- MBCS와 WBCS를 동시지원하며, 컴파일러 환경에 따라 둘 중 하나를 선택해준다.
- 전처리 과정에서 처리된다.
- 장점 : 이식성이 좋다.

32비트 아키텍쳐와 64비트 아키텍쳐의 차이점
- 컴퓨터 내부 구성요소들이 한 번에 송/수신할 수 있는 데이터 크기와 한 번에 처리할 수 있는 데이터 크기를 기준으로 결정

64비트는 32비트에 비해 뭐가 좋은가?
- 이론적으로 32비트보다 2배 더 많이 작업을 처리하기 때문에 2배 속도 증가
- 그리고 프로그래머가 사용 가능한 주소값 범위가 증가
(32비트에서 64비트로 증가. 이는 한 번에 처리 가능하고 송수신 가능한 최대 크기)
- 기존 32비트는 4G, 64비트는 16테라바이트의 공간 사용 가능
- 이로 인해 메모리 부족 문제는 완전히 사라졌다.

Polymorphic 자료형이란?
- 다형성 자료형.
- 상황에 따라 다르게 선언되는 자료형을 의미한다.
- 예를들어 LONG_PTR은 32비트에서는 4바이트 / 64비트에서는 8바이트로 선언된다.
- 참고로 PTR은 포인터의 의미가 아니라 포인터값 기반의 연산을 위해 정의되었기 때문에 붙은 이름이다.

LLP64와 LP64
- 데이터 표현 모델
- LLP64 : 윈도우에서 채택. long을 4바이트로 처리. 나머지는 동일
- LP64 : UNIX에서 채택. long을 8바이트로 처리. 나머지는 동일

명령어와 레지스터의 관계
- 명령어는 레지스터에 종속적이다.
- 레지스터 구성형태에 따라 명령어 구조가 달라진다
- 때문에 어셈블리 언어로 구현된 프로그램은, 작성 당시의 CPU와 구조가 다르면 실행 불가능하다

RISC와 CISC
- 명령어 구성에는 CPU성능과 비용 등으로 인해 각종 제약이 발생한다. 이 제약에 따라 CPU의 구조를 구분한다.
- 이 2개는 CPU의 구조적 특징에 따라 분류된다.

CISC(Complex Instruction Set Computer)
- 복잡한 명령어 체계를 가지는 컴퓨터
- 장점 : 명령어가 많다는 것은 프로그램 구현이 편리하다는 것.
- 단점 : 명령어 수가 많고, 크기가 일정하지 않기 때문에 CPU는 복잡해진다. 이에 따라 성능 하락 발생

RISC(Reduced Instruction Set Computer)
- CISC에서 실제 사용하는 명령어는 10%라는것에 착안해 만들어진 구조.
- 명령어 수를 대폭 줄이고 명령어 크기를 일정하게 디자인
- 장점 : 명령어 크기가 일정해짐에 따라 Pipelining 가능. 이로인한 속도 증가

Direct Addressing모드와 Indirect Addressing모드
- 메모리에 접근하는 방식

Direct Addressing모드
- 주소값이 가리키는 곳의 값을 데이터로 사용
- 단점 : 명령어 중 일정 부분만 주소값을 가리키도록 사용한다(명령어가 16비트일 경우, 8비트만 주소값을 가리키는 등..). 때문에 메모리의 모든 영역에 접근이 불가능한 상황이 발생한다.

Indirect Addressing모드
- 주소값이 가리키는 곳의 값을 주소로 판단. 그리고 그 주소가 가리키는 곳의 데이터를 가져온다.
- Direct모드의 문제점을 개선.

헤더와 CPP 분리 이유
- 헤더와 CPP가 1개의 파일에 있으면, 해당 파일을 include할 때 오래 걸린다 ---> 컴파일 시간 증가
- 헤더의 인터페이스만 제공해 사용자로 하여금 CPP를 몰라도 되도록 한다.

프로세스란?
- 메모리에 올라가 실행중인 프로그램
- 메모리 구조(코드영역, 데이터 영역, 스택 영역, 힙 영역) + Register Set을 프로세스라고도 한다.

메모리 구조
- 32비트 기준, 프로세스마다 4G가 할당되며, 그 중 유저영역은 2G이다.
- 나머지 2G는 커널에서 사용하기때문에 접근 불가능하다.
- 4G가 할당된다고 유저가 4G를 모두 사용할 수 있다고 착각하지 말자.

스레드란?
- 프로세스가 할당받은 자원을 사용하는 프로세스 내부의 흐름.
- 실제로 CPU에게 시간을 할당받아 프로세스 주소공간에 있는 코드를 실행하고 데이터를 사용.
- 메모리 스택 + Register Set을 스레드라고도 한다.

프로세스와 스레드의 차이점은?
- 프로세스는 완전히 독립된 두개의 프로그램을 실행하기 위함
- 스레드는 하나의 프로그램에서 둘 이상의 프로그램 흐름을 만들기 위함

Data 영역
- 전역변수, 정적변수(static 변수)의 할당을 위한 공간

스택
- 지역변수와 매개변수(함수 호출 시 전달되는 인자값)가 저장되는 공간

스택메모리 관리 방법
- 함수가 호출되면 일단 스택프레임이 할당된다.
- 스택프레임 할당 시, 해당 함수에서 사용할 스택 공간을 미리 다 잡아둔다.
(a라는 변수를 선언하면, 이는 그냥 메모리 일정 부분을 비워두는 것.)
- 이후, 컴파일러가 a라는 변수를 실제 사용할 때, ebp를 기준으로 ebp-8과 같이 접근해 실제 주소로 변환.

힙 이란
- 동적 메모리 할당을 위한 공간.

Code 영역
- 실행 파일을 구성하는 명령어들이 올라가는 영역

스케쥴링이란?
- 프로세스나 스레드에게 CPU를 골고루 할당하는 일
- 목적 : 프로그램이 동시에 실행되는 것 처럼 보이게 하는 위함

스케쥴링 알고리즘이란?
- 스케쥴링에 사용되는 알고리즘
- 라운드 로빈 등이 존재한다.

스케쥴러란?
- 실제 스케쥴링을 하는 운영체제의 소프트웨어 모듈.
- CPU 입장에서는 스케쥴러도 하나의 프로세스일 뿐이다.

멀티 프로세스 관리 방법과 그 이유
- 모든 프로세스를 실행시킨 후 스케쥴러에 의해 CPU 시간을 할당받아 실행한다.
- 이유 : 대부분의 프로그램은 I/O에 많은 시간을 사용한다. 이 I/O를 하는 동안 다른 프로세스에게 일을 시키는것이 효율적이다.

스케쥴링 작동 기본 룰
- 각 스레드마다 타임 슬라이스(15.6m/s. 타이머 인터럽트에 의한 시간) 만큼의 시간 할당
- 할당받은 시간을 다 쓰거나, 해당 스레드가 block 상태가 될 경우, 우선순위를 고려한 라운드 로빈의 룰에 따라 CPU에 올라갈 스레드가 결정된다.
- 스레드가 선택되면 Running 상태의 스레드를 Ready혹은 Block으로 변경 후 Ready의 스레드를 Running으로 올린다.

프로세스의 상태와 각 상태가 되는 상황(스레드의 상태)
- Ready / Running / Blocked 총 3개의 상태

Ready 상태가 되는 경우
- 이제 막 생성된 스레드
- Blocked였다가 작업이 끝난 스레드
- Running이였는데 타임슬라이스가 끝난 스레드
- Running이였는데 나보다 우선순위가 높은 스레드가 Ready에 추가될 경우, 타임슬라이스가 남았더라도 Ready가 된다.

Running이 되는 경우
- Ready였다가 스케쥴러에 의해 선택된 스레드

Blocked가 되는 경우
- Running 중이었는데 I/O작업 등에 의해 스레드가 멈추는 상황. (데이터 I/O, 소켓 I/O, Sleep등의 함수 호출)

Ready와 Running의 차이점
- 스케쥴러에 의해 선택될 수 있느냐 없느냐의 차이

CreateProcess의 주의점
- 프로세스로 전달할 문자열은 변수 형태여야 한다.
- 왜냐하면, 함수 내부에서 인자로 받은 문자열에 변경을 가하기 때문이다. 상수 형태로 전달하면 문자열 변경이 불가능.
- 컴파일 타임에는 멀쩡하지만 런타임때 에러가 발생한다.

완전 경로
- 풀 경로

현재 디렉터리
- 어떤 파일을 찾을 때 기본이 되는 디렉터리
- 프로세스 생성 시, 실행파일이 존재하는 곳이 현재 디렉터리.
- 사용자는 현재 디렉토리 이후의 정보만 전달하면 된다.

커널
- OS중에서도 실제 핵심 영역을 커널이라 한다.

커널 오브젝트란?
- 커널이 관리하는 정보를 모아둔 데이터 블록.
- 커널에 의해 생성/소멸된다.
- 커널 오브젝트 종류에 따라, 다른 형태의 오브젝트를 생성한다. 각자 관리해야하는 정보가 다르기 때문이다.

프로세스 생성 주체
- 실제로는 커널이 생성한다. 우리는 생성을 요청하는것 뿐.

Busy Wating이란?
- 스레드가 의미없는 루프를 돌면 다음줄이 실행되지 않기 때문에 스레드가 멈춘것 처럼 보인다.
- 이걸 Busy Wating이라 한다. (바쁜 대기)
- 이 때 스레드는 Running 상태이다.

커널 오브젝트 핸들이란?
- 커널 오브젝트를 생성한 후 할당된 숫자.
- 사용자에게 제공될 수 있으며, 사용자는, 이 핸들과 함수 호출로 커널 오브젝트에 접근할 수 있다.

커널 오브젝트 핸들은 프로세스에 종속적이다. 그 의미는?
- 동일한 커널 오브젝트에 접근하더라도, 그 오브젝트에 접근할 수 있는 핸들은 프로세스마다 다르다.
- 즉, A프로세스의 100번 핸들과 B프로세스의 100번 핸들은 동일한 커널 오브젝트를 가리키지 않을 수도 있다.
- 다만, 자식 프로세스에게 핸들테이블이 상속될 때는 핸들값까지 완전히 동일하게 상속된다. (복붙느낌)

커널 오브젝트는 운영체제에 종속적이다. 그 의미는?
- 커널 오브젝트는 어떤 프로세스든 접근 가능하다. 
- 커널 오브젝트의 실질적인 생성/삭제/관리는 커널이 한다. 프로세스는 단지 핸들을 통해 접근 권한만 있는 것 뿐이다.

Usage Count란?
- 커널 오브젝트에 존재하는 참조 카운트.
- 모든 커널 오브젝트는 생성 시, Usage Count가 1이 된다.
- 그 외에도, 접근 대상이 생길 때 마다 Usage Count가 1씩 늘어난다.
- 부모/자식 관계의 프로세스의 경우에 자식프로세스는 부모가 참조하기 때문에 1이 늘어난 것.
- CloseHandle 시 1 감소. 프로세스나 스레드의 경우에는, 종료 시점에 자기 자신의 Usage Count 1 감소
- 0이되면 커널 오브젝트는 소멸된다.

CloseHandle란?
- 나의 핸들테이블에서 해당 커널 오브젝트의 정보를 제거하며, Usage Count 1 감소
- 극단적으로 말해, 프로세스가 종료되어도 다른 누군가가 해당 프로세스 커널 오브젝트를 참조중이라면 커널 오브젝트는 소멸되지 않는다.
- CloseHandle은 이 Usage Count를 감소시키는 역활을 한다.

Usage Count의 존재 이유
- 커널 오브젝트의 소멸 타이밍을 결정하기 위함.
- 예를들어 자식의 종료코드는 자식의 커널 오브젝트에 저장된다.
- 때문에 자식 프로세스가 종료되었다고 바로 자식 프로세스를 종료하면, 부모는 자식의 종료코드를 받을 수 없다.

프로세스간 통신 기법이 존재하는 이유
- 프로세스는 개별적인 메모리 공간을 사용한다.
- 때문에 프로세스간에 데이터를 주고 받기 위해서는 OS가 기능을 제공해야 한다.

프로세스가 별로 메모리 공간이 존재하는 이유
- 안정성을 높이기 위함.
- 이렇게 안하면 서로 메모리 침범으로 프로세스에 문제가 생길 수 있다.

메일슬롯
- 일종의 우체통(메모리 공간)을 두어 데이터를 주고 받는 방법
- 우체통을 메일 슬롯이라 한다.
- Receiver가 메일슬롯을 만들어 두면(CreateMailslot), Sender는 거기에 접근해(CreateFile) 데이터를 보낸다.
- Receiver는 메일슬롯에 데이터가 들어오면 block상태에서 깨어나며, 데이터를 Read한다.

메일슬롯의 특징
- 단방향 통신만 가능. 양방향 통신을 하고 싶으면, 서로가 Receiver와 Sender가 되어야 한다.
- 브로드 캐스팅 지원. Sender는 한번의 메시지 전송으로 n명의 Receiver에게 데이터 보내기 가능

커널 오브젝트의 상태
- Signaled / Non-Signaled
- 커널 오브젝트에 멤버변수로 존재한다.
- 커널 오브젝트에 따라 상태가 변하는 시점이 다르다.

프로세스/스레드의 커널 오브젝트 상태
- 최초 생성 시 Non-Signaled. 종료 시 Signaled 상태.
- 즉, 종료 신호를 받았는지 받지 않았는지를 기준으로 체크하면 될듯.
- 프로세스/스레드는 한번 Signaled 상태가 되면 Non-Signaled상태가 될 수 없다.

커널 상태를 확인하는 함수
- WaitForSingleObject / WaitForMultipleObject
- 정상적인 경우 커널 상태가 Signaled가 되면 리턴

프로세스 핸들 테이블
- 프로세스마다 생성되며 해당 프로세스가 참조하는 커널 오브젝트 보관.
- 핸들(숫자) / 커널 오브젝트의 주소 / 상속 여부 보관

핸들 테이블의 상속
- 자식 프로세스 생성 시, [핸들 테이블 상속 / 핸들 상속 여부] 총 2개의 속성을 결정해야 한다.

부모의 핸들테이블 상속
- 핸들 테이블의 특정한 핸들만 상속하는것은 불가능.
- 부모의 핸들 테이블 중 상속 여부가 TRUE인 모든것을 상속
- 상속 시, 모든 값(핸들 값, 커널 오브젝트 주소, 상속 여부)가 상속된다.

생성하는 자식 프로세스의 핸들 상속
- 이번에 생성하는 자식 프로세스를 부모의 핸들테이블에 등록할 때, 핸들테이블의 [상속 여부]를 TRUE로 할 것인지

핸들을 얻는 시점
- 핸들 정보가 핸들 테이블에 등록될 때, 핸들을 얻었다고 한다.

가짜 핸들
- GetCurrentProcess() 함수를 이용하면 현재 프로세스의 핸들을 얻을 수 있다.
- 하지만 이는 사실 -1같은 약속된 값일 뿐 실제 핸들테이블의 핸들이 아니다.

가짜 핸들의 특징
- CloseHandle을 할 필요 없음
- 자식 프로세스로 상속되지 않음.

현재 프로세스의 진짜 핸들을 얻는 방법
- DuplicateHandle()를 사용.
- GetCurrentProcess()를 이용해 얻은 핸들값(-1)을 Duplicate한다면 진짜 핸들이 생성된다.
- DuplicateHandle을 사용할 경우, Usage Count도 증가하기 때문에 CloseHandle을 해야 한다.

부모 프로세스의 핸들을 자식 프로세스에게 전달 방법
- DuplicateHandle을 이용해 부모 프로세스의 핸들테이블에 자신을 가리키는 핸들값 생성
- 자식 프로세스를 생성할 때 핸들 테이블 상속
- 자식에게 어떻게든 부모의 핸들값에 등록된 자신을 가리키는 핸들값을 전달.

이름없는 파이프
- 단방향 통신
- 핸들 테이블 상속을 통해, 부모 자식간에 통신 가능
- 관계있는 프로세스들 사이에서 사용

이름있는 파이프
- 양방향 통신
- 생성한 이름있는 파이프를 통해 통신.

프로세스 환경변수
- 프로세스마다 별도의 문자열을 보관할 수 있는 Key = Value 형태의 메모리 공간을 환경변수라 한다.
- 부모 : 자식의 환경변수 변경 가능 / 자기 자신의 환경변수 상속 가능

RTOS(Real Time OS)
- 일반 OS와 큰 차이는 없다면 하는일이 더 적다.
- 때문에 일반 OS보다 가볍고 응답성이 좋다. 대신 범용적이지 않다.

OS와 RTOS의 구분
- 응답성에 따라 구분.

soft RTOS와 hard RTOS
- soft RTOS : 일반적인 RTOS를 의미. 일반 OS보다 응답성이 빠른 정도.
- hard RTOS : '데드라인'개념이 있다. 핵발전소 관련 시스템 등 시간에 정말 Critical한 상황에서도 사용할 수 있는 RTOS

선점형 OS(Preemptive OS)와 비선점형 OS(Non-Preemptive OS)의 구분
- 프로세스의 실행을 다른 프로세스로 넘기는 방식에 따라 구분

비선점형 OS(Non-Preemptive OS)
- 우선순위가 높은 프로세스/스레드가 등장해도 실행 대상을 변경하지 않는다
- 실행대상 변경 시점 : 실행 중인 프로세스/스레드가 명시적으로 CPU양보, I/O등 작업으로 Blocking이 될 시.

선점형 OS(Preemptive OS)
- 우선순위가 높은 프로세스/스레드가 등장하면 실행대상 즉시 변경
- 장점 : 프로그래머가 신경쓸 일이 없다. 멀티 프로세스 기반 OS에 적합.
- 단점 : 비선점형 OS에 비해 스케쥴러가 일을 많이 한다.

우선순위 스케쥴링 알고리즘
- 프로세스와 스레드에 우선순위를 부여해 우선순위가 높은 스레드를 우선실행하는 알고리즘

스레드 우선순위란?
- 스케쥴러가 CPU로 올릴 스레드를 선택하는 기준. 우선순위가 높은 스레드가 먼저 선택된다.
- 프로세스 우선순위(우선순위 클래스) : 프로세스의 속성이며, 이 프로세스의 스레드는 모두 우선순위 클래스가 같음
- 스레드 우선순위(우선순위 레벨) : 스레드 속성.
- 이 2개를 합쳐 기본 우선순위가 결정된다.

기아현상이란? (starvation)
- 계속 높은 우선순위의 스레드만 CPU를 할당받아 우선순위가 낮은 스레드는 일을 하지 못하는 상황
- 보통 I/O작업 등으로 스레드가 블락상태가 빠지게 되기 때문에 기아현상이 발생하는 경우는 거의 없다.

기아현상 해결 방법
- OS 자체적으로 CPU시간을 할당받지 못한 스레드의 우선순위를 서서히 끌어올린다.
- 높은 우선순위의 스레드가 Block상태가 될 때 낮은 우선순위 스레드에게 우선순위 위임

라운드 로빈 스케쥴링 알고리즘
- 우선순위가 같은 스레드들끼리 순차적으로 실행할 수 있도록 하는 알고리즘
- 모든 스레드는 타임슬라이스만큼 일을 한 후 내려온다.

타임 슬라이스
- 퀀텀이라고도 하며, 스레드가 CPU에 올라가 일을 하는 시간.
- 타이머 인터럽트가 발생하는 시간(15.6m/s)
- timebeginperiod함수를 이용해 이 시간을 15.6m/s 이하로 변경할 수 있다.

스케쥴링이 진행되는 시점
- 매 타임슬라이스 마다 (라운드 로빈 알고리즘 관점)
- 스레드가 생성/종료되는 시점 (우선순위 알고리즘 관점)
- 실행 중 스레드가 Blocked상태가 되는 시점

컨텍스트 스위칭이란?
- 현재 CPU가 실행중인 스레드를 멈추고 Ready상태의 스레드 중 하나가 일을 할 수 있도록 전환하는 작업.
- PCB 혹은 TCB를 교체하는 작업이다.

리다이렉션(Redirection)
- 방향 재지정
- 콘솔 화면에 출력이 이루어 져야 할 상황에, 리다이렉션을 하면 파일로 출력이 이루어진다.

스택 프레임
- 함수 호출 과정에서 스택에 할당되는 메모리 블록(지역변수의 선언으로 인해 할당되는 메모리 블록)

함수 호출 인자
- 일부는 레지스터에 저장되고, 나머지는 스택에 저장된다.
- 속도 향상을 위해.
- 보통 C스타일을 따른다 (가장 오른쪽 인자가 스택에 먼저 저장)

컴파일러가 함수 인자 처리 방법
- C스타일로 받은 인자를 하나씩 꺼내서 왼쪽부터 할당한다.

함수 호출 규약(Calling Convention)
- 함수 호출 시 인자 전달 순서 결정
- 함수 종료 시, 스택 프레임 반환 주체(Caller, Callee) 결정
- Visual Studio에서 디폴트 호출 규약 지정 가능 (디폴트 __cdecl)
- 함수 호출규약은 언어차원에서 제공. OS 아님.

__cdecl만 caller(호출자)가 스택을 정리하며, 나머지는 callee가 스택 정리
모두 인자 전달은 C스타일

함수 호출이 빨라지는 근거
- 레지스터에 인자를 저장한다. 많은 인자를 레지스터에 저장할 수록 함수호출이 더 빨라진다.

함수 호출 규약이 존재하는 이유
- 규칙이 없으면, 호출된 함수도 스택프레임을 정리하고 호출자도 스택프레임 정리하는 등 이상한 오작동 발생 가능.

프로세스를 안쓰고 스레드를 쓰는 이유
- 한 번에 두가지 이상의 일을 처리하기 위해서는 프로세스를 새로 생성해야 함
- 하지만, 이는 컨텍스트 스위칭 부담이 된다. 
- 때문에, 컨텍스트 스위칭 부담을 줄일 수 있는 개념(스레드는 레지스터와 스택을 제외한 모든걸 공유하기 때문에)을 만들었다.

스레드의 특성
- 독립된 스택 영역 보유
- 코드 영역 공유
- 데이터, 힙 영역 공유

스레드 동기화 문제 발생 원인
- 데이터와 힙 영역 공유로 인해서.

유저 영역
- 코드/데이터/힙/스택이 있는 메모리 영역
- 프로세스 동작 시 사용
- 32비트 기준, 2G(가상메모리)

커널 영역
- 프로세스의 유저 영역을 제외한 나머지 메모리 영역
- 운영체제 동작 시 사용
- 32비트 기준, 2G(가상메모리)

유저모드 커널모드 제공 주체
- 메모리 보호 기능은 프로세서(CPU)에 달려있다. 당연히 CPU가 제공주체이다.

유저 모드와 커널 모드 존재 이유
- 사용자가 커널 영역에 접근할 시 시스템에 문제가 생길 수 있기 때문에 접근 제약을 두었다.

유저 모드
- 유저 영역의 메모리만 접근 가능. 커널 영역 접근 불가.

커널 모드
- 유저 영역 + 커널 영역 모두 접근 가능

커널 레벨 스레드
- 커널이 생성 후 관리하는 스레드. 윈도우의 기본
- 장점 : 커널이 관리해주기 때문에 안전 + 다양한 기능
- 단점 : 모드 전환이 빈번하기 때문에 느리다.

유저 레벨 스레드
- 유저가 직접 생성 후 관리하는 스레드.
- 커널 입장에서는 1개의 스레드(메인 스레드)만 존재.
- 장점 : 모드 전환이 없기 때문에 빠르다
- 단점 : 프로그램을 예측하기 어렵다(예를 들어, 유저레벨 스레드 4개 중 하나만 blocked상태가 되어도 해당 프로세스 전체가 블락된다)

스레드 최대 생성 수
- 메모리가 허용하는 만큼

스레드 최소 스택 사이즈
- 1M. 그 이하로 설정할 경우 강제로 1M로 설정한다.

스레드 종료 방법
- 스레드 함수가 리턴
- ExitThread()함수 호출	-	비정상
- TerminateThread()함수 호출	- 비정상

스레드 종료 방법 중 정상적인것은?
- 스레드 자신이 종료하는것이 좋음.
- 왜냐하면, class의 소멸자는 스코프 종료 시점에 코드가 박히기 때문에, 스레드를 강제로 종료하면 해당 코드를 실행하지 않고 나간다. 그러면 어떻게 작동할지 모름
- 그리고 동적할당한 메모리도 보통 return 전에 해제할텐데 누수도 난다.

프로세스로부터  스레드를 분리한다
- 부모가 자식 프로세스의 핸들을 인자로 CloseHandle을 하는것과 같이, 스레드 핸들을 인자로 CloseHandle을 하는 것.

스레드 생성 시 주의점
- _beginthreadex()를 사용해야한다.
- 왜냐하면 기존의 CreateThread는 C런타임 라이브러리 사용 시 스레드 safe하지 않기 때문이다.
- _beginthreadex()를 사용하면 tid 데이터 블록이 생성된다. 이 블록이 C런타임 라이브러리를 안전하게 사용할 수 있도록 해준다.

_beginThreadex로 스레드 생성 시
- _endthreadex를 호출해야, tid를 소멸시킬 수 있다.

스레드 동기화
- 메모리 접근 동기화 : 메모리에, 동시에 한 스레드만 접근하도록 한다.
- 실행 순서 동기화 : 메모리에 접근하는 스레드의 순서

스레드 동기화의 방법
- 유저 모드 동기화 : 유저 모드에서 처리. 속도 빠름 (크리티컬섹션, 인터락, SRWLOCK)
- 커널 모드 동기화 : 커널 모드에서 처리. 속도는 느리지만 기능이 많음 (뮤텍스, 세마포어, 이벤트)

메모리 접근 동기화
- 크리티컬 섹션 / 인터락 / SRWLOCK / 뮤텍스 / 세마포어
- 임계영역 접근을 막는 것.

임계영역이란?
- 동기화 문제가 일어날 수 있는 코드 블록

volatile이란?
- 컴파일러에게 이 변수만큼은 최적화 하지 말라는 명령
- 레지스터에 있는 값에 바로 접근하는게 아니라 실제 물리메모리에서 값을 가져오도록 한다. (레지스터를 쓰긴 함)

뮤텍스
- 뮤텍스라는 커널 오브젝트 사용
- 뮤텍스를 누군가가 획득 가능하면 Signaled 상태
- WaitForSingleObject함수로 뮤텍스 대기. Signaled가 되면 반환되며, 함수의 기능에 따라 자동으로 Non-Signaled로 바뀜.
- ReleaseMutex함수로 뮤텍스 반환.
- CloseHandle로 리소스 반환

세마포어
- 뮤텍스가 여러개 있는 느낌
- 바이너리 세마포어를 뮤텍스라고도 한다.
- 접근 가능한 모든 스레드가 접근하면 Non-Signaled가 된다.

뮤텍스와 세마포어 차이점
- 뮤텍스는 한 번에 하나의 스레드만 접근 가능. 세마포어는 한 번에 n개의 스레드가 접근 가능

이름있는 뮤텍스/세마포어
- 커널 오브젝트이기 때문에 이름을 지정하면 접근 가능

WAIT_ABANDONED
- 뮤텍스를 소유한 스레드가 뮤텍스를 반환하지 않고 종료될 경우, 뮤텍스를 대기중인(WaitForSingleObject) 스레드는 해당 오류가 리턴된다.
- 윈도우가 반환
- 세마포어는 해당 없음

실행 순서 동기화
- 이벤트
- 예시 : 생산자-소비자 모델

이벤트
- 수동리셋 모드 : WaitForSingleObject리턴 시 ResetEvent함수를 해야 Non-Signaled가 된다.
- 자동리셋 모드 : WaitForSingleObject리턴 시 자동으로 Non-Signaled가 된다.

수동/자동 이벤트 특징
- 수동 리셋 이벤트는, 대기 중인 모든 스레드를 깨운다.
- 자동 리셋 이벤트는, 대기 중인 스레드 중 1개만 깨운 후 다시 Non-Signaled로 돌아간다.

대기 가능 타이머(Waitable Timer)
- 스레드의 실행 시간/ 실행 주기 결정
- 최초 Non-Signaled 상태
- 수동 리셋 타이머 : 알람시계 개념. 알람 한번 울리고 끝
- 주기적 타이머 : 일정 시간마다 알람이 계속 울림

스레드 풀이란?
- 스레드를 재활용하는 것.
- 할당된 일을 마친 스레드를 소멸시키지 않고 스레드 풀에 보관. 할일이 있으면 스레드 풀에서 스레드가 하나 깨어남

스레드 풀이 필요한 이유
- 스레드 생성/소멸에는 많은 작업이 필요하기 때문에.

스레드 풀 생성 시점
- 할 일이 등록되기 전에 미리 생성해둔다. (그 안에 쓰레드 포함)

스레드 풀에 스레드가 하나도 없는데 일을 해야한다면?
- 일이 순서대로 잘 처리될 수 있도록 해야 함

메모리란?
- 데이터를 저장하기 위한 하드웨어 장치.

메모리 계층
- 레지스터 --> 캐시 --> 메인메모리 --> 하드디스크
- 모든 메모리는 자신보다 하위에 있는 메모리를 캐시해두는 역활.

각 메모리의 위치와 역활
- 레지스터 : CPU에 내장 / 각 CPU연산에 필요한 정보 임시저장
- 캐시 : CPU에 근접 / 메인 메모리의 데이터 중 일부를 미리 캐시해둔다.
- 메인 메모리 : 프로세스 주소공간이 올라가 있는 공간. 페이지 프레임으로 관리.
- 하드 디스크 : 크고 작은 파일을 저장하기 위한 공간. 메모리 측면에서는 페이징 파일이 있는 곳.

메모리의 속도
- CPU와 가까울수록 빠르고 멀수록 느리다.

하드 디스크를 쓰는 이유
- CPU 근처로 메모리를 가져갈수록 기술적 문제와 비용 증가.

L1 캐시와 L2 캐시의 차이점
- CPU와 얼마나 더 가까이 있는가
- 저장 가능 용량

프로그램의 특성
- 템퍼럴 로컬리티 : 한번 접근한 메모리는 다시 접근할 가능성이 높다.
- 스페이셜 로컬리티 : 접근하는 메모리 영역은, 이미 접근했던 메모리 근처의 영역일 가능성이 높다.

캐시 히트
- 원하는 데이터가 캐시에 있을 시 캐시 히트라 한다.

캐시 미스
- 원하는 데이터가 캐시에 없을 시 캐시 미스라 한다.
- L2에서 데이터 가져오길 시도하며, L2에서도 캐시미스가 나면 메인 메모리로 가서 가져온다.

캐시메모리가 성능에 도움을 주는 이유
- 캐시로 메모리를 캐싱할때 아래 2개의 속성 때문.
- 템퍼럴 로컬리티 / 스페이셜 로컬리티 

캐시 교체 정책
- 캐시가 가득 찼을때 어떻게 처리 할 것인지 결정하는 정책.
- 캐시미스가 나서 새로운 데이터를 가져왔을 경우, 캐시에 공간이 없으면 공간을 만들어야한다.
- 대표적으로 LRU(Least Recently Used. 가장 오래된 블럭을 밀어냄)

메모리간 데이터 이동의 특징
- 블록 단위로 이동된다.
- 하위 메모리로 갈 수록 이동하는 블록 단위가 더 커진다.
- 이유 : 스페이셜 로컬리티를 위해. 하위 메모리 접근 횟수를 줄이기 위해

물리 주소
- 메인 메모리에게 할당된 주소

물리 주소의 한계
- CPU 입장에서 접근 가능한 주소의 범위가 제한.
- 이는 곧 프로그래머가 할당 가능한 주소 범위가 제한적

가상 메모리
- 사용 이유 : 물리 주소의 한계 극복
- CPU와 프로그래머는 가상 주소를 사용. 물리 주소는 MMU만 알고 있다.
- '페이징' 기법을 사용해 구현.
- 핵심 하드웨어 : MMU

페이징 기법이란?
- 메모리를 일정 크기(예시로 4K)로 묶어 관리하는 기법
- 장점 : 물리메모리에 필요한 메모리만 적재 가능. 메모리 부족 현상 해결!
- 페이지 프레임 : 실제 메인메모리 블록
- 페이지 : 가상 메모리 블록
- 크기는 동일

MMU란?
- CPU에 있는 하드웨어. 물리 메모리와 가상 메모리를 맵핑시켜 준다. (Memory Mapping Unit)

페이지 테이블
- 가상 메모리와 맵핑된 물리메모리 주소를 저장한 테이블
- Key / Value 구조
- MMU에서 관리
- 프로세스마다 할당
- 커널 메모리 영역에 존재

페이지 인 / 페이지 아웃
- 페이지 아웃 : 물리 메모리의 페이지프레임을 하드디스크의 페이지 파일에 저장하는 작업.
- 페이지 인 : 하드 디스크의 페이지 파일에 있는 페이지프레임을 물리메모리로 올리는 작업.

블로킹 함수
- 호출 후 완료될 때 까지 스레드가 블로킹되는 함수

동기 I/O
- 함수 리턴시점과 작업 완료시점이 동일

비동기 I/O
- 함수 리턴시점과 작업 완료 시점이 다름

중첩 I/O
- 비동기 I/O의 모델 중 하나
- I/O연산을 여러번 중첩해서 실행 가능

가상메모리의 상태
- 페이지에 할당되는 상태.
- 예약(Reserver), 할당(Commit), 할당되지 않음(Free) 총 3개의 상태

Commit
- 물리메모리에 할당이 이루어진 상태
- 물리메모리 : 램 + 하드디스크 포함

Free
- 물리메모리에 할당이 전혀 이루어지지 않은 상태

Reserve
- Commit과 Free의 중간상태
- 다른 메모리 할당 함수에 의해 할당 불가능
- 예약을 했을 뿐이기 때문에 물리메모리에 할당되진 않는다.

메모리 할당 시작 주소 (Allocate Granularity Boundary)
- 윈도우가 실제 메모리를 할당하는 경계
- 64KB
- 메모리가 지나치게 조각나는 것을 막고 관리의 효율성을 위함

VirtualAlloc()
- Free 상태의 페이지를 Commit/Reserve로 변경
- Reserve 상태의 페이지를 Commit으로 변경 (Reserve 상태의 주소를 전달해야 함)
- Reserve 시 : AGB단위로 예약. 
 -Commit 시 : 전달받은 KB만큼 할당. 최소 페이지 크기(4KB). 1KB할당을 요청해도 4KB 할당.

VirtualFree()
- Commit / Reserve상태의 메모리를 Free로 변경
- 예약이 된 메모리의 일부만 반환하는것 불가능. 페이지 단위로 작동.

디폴트 힙(프로세스 힙)
- 운영체제가 기본적으로 제공하는 힙. 
- 기본적으로 Reserve상태. malloc과 new 시, 그 reserve를 commit으로 바꾸는 등의 작업이 일어난다.
- 초기 크기 1MB이며, 필요에 따라 윈도우가 늘린다.

동적 힙(다이나믹 힙)
- HeapAlloc함수를 통해 생성된 힙.
- 장점 1 : 메모리 단편화 최소화로 성능 향상 (리스트의 예)
- 장점 2 : 디폴트 힙 내부의 동기화를 사용하지 않음으로써 성능 향상
- 장점 3 : 힙의 모든 내용을 날릴 때 한번에 날릴 수 있다.

메모리 단편화(Memory Fragmentation)
- 1개의 리스트는 n개의 노드로 구성되는데, 각 노드들이 디폴트 힙의 여기저기에 흩어져있다.
- 이 상황을 메모리 단편화라 한다.

HeapCreate()
- 동적 힙을 생성한다.
- [동기화 처리 여부 / 예약할 힙의 크기 / 초기 Commit 크기 / 힙 성장 여부(Growable Heap)] 를 설정할 수 있다.

성장 가능 힙(Growable Heap)
- 디폴트 힙은 운영체제가 자동으로 크기를 키운다.
- 마찬가지로, 성장 가능한 동적힙은 크기 부족 시 알아서 늘어난다.

HeapDestroy()
- 동적 힙 삭제
- Reserve/Commit상태의 동적 힙을 Free로 되돌린다.

HeapAlloc()
- 동적 힙에 메모리 할당
- 요청하는만큼 Reserve상태의 동적 힙을 Commit으로 변경

HeapFree()
- 동적 힙의 메모리 해제
- 메모리를 해제하는 중 페이지가 Reserve가 될 수도 있다.

메모리 할당 순서
- malloc -> new -> HeapAlloc -> VirtualAlloc
- malloc / new는 RTT일 뿐이며 내부에서는 결국 HeapAlloc과 VirtualAlloc이 호출된다.

MMF란? (Memory Mapped File)
- 프로세스의 가상메모리와 하드디스크의 파일을 직접 맵핑
- 가상메모리에 있는 데이터는 특정 상황에 하드디스크에 데이터 저장.

MMF 장점
- 프로그래밍 편리 (빈번한 I/O작업 삭제)
- 성능 향상 (직접 파일 접근 안함)

COW(Copy On Wirte)란?
- Write할 때 Copy하라!
- 어떤 테이블에 포인터로 접근만 하다가, 실제 내용을 변경해야 할 경우 복사.

스핀락과 락프리의 차이점
- 스핀락은 "임계 영역 접근"에 대한 락
- 락프리는 "작업 성공"에 대한 락

쓰레싱 현상이란?
- 페이지폴트로 인해 스레드가 일을 하지 못하는 현상. 과도한 페이징 작업.

워킹셋이란?
- 프로세스 가상 메모리 중에, 실제 RAM에 올라가 있는 페이지들을 워킹셋이라 한다.
- 목적 : 자주 사용하는 것들을 올려두어, 최대한 페이지 폴트, 스왑파일 과정 없이 데이터를 참조하게 한다.
- Code 영역 / Data 영역이 포함

커밋 메모리란?
- 실제 해당 프로세스에게 할당된 페이지
- HDD의 페이지 파일에도 커밋된 메모리가 존재할 수 있다.

Sleep(0)와 switchToThread의 공통점
- 현재 나의 타임슬라이스를 포기한 후 다른 스레드에게 남은 시간을 양도한다 
- 15.6m/s중 10m/s만 쓴 후에 위 함수를 호출하면 남은 5.6m/s를 다른 스레드가 일한다

Sleep(0)와 switchToThread의 차이점
- switchToThread는 자신이 실행중이던 프로세서의 ready상태 스레드 중 하나에게 양보한다. ready스레드가 아무도 없다면 자신이 다시 올라온다.
- Sleep(0)은 자신이 실행중이던 프로세서 외 다른 프로세서의 스레드들을 모두 참고해 ready상태의 스레드 하나를 골라 양보한다.
만약, 모든 프로세서에 ready중인 스레드가 하나도 없으면 자신이 다시 올라온다.
- 과거의 Sleep(0)은 자신보다 우선순위가 높거나 같은 스레드가(자신이 3이면 0~3까지) ready에 있을 경우 양보했으며, 없을 경우 자기 자신이 다시 올라왔다.

컴파일 최적화기능이란?
- 컴파일러가 최적의 속도를 낼 수 있도록 합리적으로 기계어를 만들어내는 기능
- 단점은, 내가 원하는대로 작동하지 않을 수도 있다.
- Debug모드에서는 적용되지 않는다.

DLL 맵핑
- 기본적으로 DLL은 자신이 맵핑되고 싶은 가상메모리 주소가 있다. (예를 들어 0x10000)
- 프로세스 A에서는 가상메모리 0x10000이랑 물리메모리의 어딘가와 맵핑이 되었다.
- 근데 프로세스 B가 동일한 DLL을 가상메모리 0x10000과 맵핑하기 싶은데 이미 누군가가 0x10000을 사용 중일 경우, 프로세스 B를 위해 해당 DLL이 다시 물리메모리로 올라오며, 그 물리메모리와 0x10000이 아닌 다른 가상주소와 맵핑된다.

가상메모리를 사용하는 이유
- 사용자에게 메모리 공간 제약이 없도록 하기 위함

워드 단위 복사
- 기본적으로 워드 단위(64bit는 8바이트) 복사는 최소단위 오퍼레이션으로 이루어진다.
- 하지만, 워드 크기 이상의 복사는 REP로 바이트 단위 복사가 이루어진다.

워드 단위 이상 복사 시 문제점
- REP로 바이트 단위 복사이기 때문에, 최소단위 오퍼레이션이 아니다

파이프라이닝이란?
- 시간단 처리량 증가를 위한 기법. 속도 증가 아님

파이프 라이닝 작동법
- fetch, decode, excution을 각자 다른 파이프에서 처리해 한 번에 많은 작업 처리