프로그래밍 언어란?
- 사람과 컴파일러가 이해할 수 있는 언어

컴파일러의 역활은?
- 프로그래밍 언어를 기계가 이해할 수 있는 기계어로 번역

C언어의 장점
- 절자지향적 -> 배우기 쉽다.
- 이식성이 좋다
- 성능이 좋다

C언어의 단점
- 주의깊게 사용해야 한다.

프로그램 완성 과정
- 코드작성 -> 컴파일 -> 실행파일 생성

함수란
- 반환형 / 함수 이름 / 매개변수 / 몸체로 이루어짐
- 프로그램의 핵심

표준함수
- 기본적으로 제공되는 함수

표준 라이브러리
- 표준함수들의 모임

헤더파일이란?
- 함수나 라이브러를 컴파일 할 때 필요한 인터페이스들이 정의되어 있는 파일

return의 의미
- 함수를 호출한 영역으로 값을 반환
- 함수 종료

메인함수에서 return에서 0을 반환하는 이유
- 메인함수를 호출한 주체는 운영체제이며, 0은 정상 리턴을 의미.

세미콜론의 역활
- 코드 문장의 끝을 표현

특수문자
- \r, \n같은 특수한 의미가 있는 문자.
- 모든 특수문자는 앞에 \이 붙는다.

\n은(Line Feed)?
- 다음줄로 개행

\r은(Carrige return)?
- 커서를 맨 왼쪽으로 이동

\"는?
- 큰따옴표 자체를 문자에 넣고싶을때 사용.

윈도우의 개행문자
- \r\n을 개행문자로 사용.

주석이 존재하는 이유
- 코드 분석을 용이하게 하기 위함.

주석 중첩
- 블록단위 주석은 중첩 불가능

서식문자란?(conversion specifier)
- 출력의 형태를 지정하는 문자
- 정수,소수,문자,문자열을 표시할 수 있다.
- %d : 10진수
- %u : 언사인 10진수
- %x : 16진수(%X로하면 대문자 출력)
- %p : 포인터의 주소값

변수
- 메모리 공간에 이름을 붙인 것.

변수 초기화란?
- 선언된 변수에 처음 값을 저장하는 것.
- 생성과 동시에 초기화 가능

초기화를 하지 않으면?
- 아무 의미없는 값이 저장되어 있다.

전역 변수를 초기화하지 않으면?
- 전역변수는 자동으로 0으로 초기화된다.

변수 선언 시 주의사항
- 중괄호 가장 앞부분에 위치해야 함(C언어의 경우)
- 공백 삽입 불가능
- 알파뱃/숫자/언더바(_)만 허용
- 숫자로 시작 불가능
- 대소문자 구분함
- 키워드를 변수이름으로 상용 불가

변수의 종류
- 정수형 변수, 실수형 변수

정수형/실수형 변수의 차이점
- 메모리에서 관리되는 방식

함수의 호출문에 연산식
- 함수 호출보다 연산식이 먼저 진행

이항 연산자
- 2개의 피연산자 존재
- 대입 / 산술 / 복합대입 / 비교연산 / 논리AND / 논리 OR

비교연산의 특징
- 조건 만족 시 true, 불만족시 false 반환
- 타 연산자들과 작동 방식이 조금 다름

부호 연산자
- 변수나 상수 앞에 붙는 부호
- + / -
- 복합대입과 햇갈리지 말자

단항 연산자
- 1개의 피연산자 존재
- 전위 증감 / 후위 증감 / 논리 NOT
- 전위 증/감 : 변수 증/감 후 로직 진행
- 후위 증/감 : 모든 로직 종료 후, 코드 다음줄로 이동시 변수 증/감

후위 증/감과 소괄호
- int num2 = (num--)+2;
- num--이 먼저 된 후 +2가 될 것 같지만 num+2 후, 코드 다음줄로 이동 시 num--이 진행

논리 연산자
- 논리 AND(&&) : 둘 다 참이면 true 반환
- 논리 OR(||) : 둘 중 하나라도 true면 true 반환
- 논리 NOT(!) : false를 true로 / true를 false로 변환해 반환

콤마 연산자
- 구분을 목적으로 하는 연산자

연산자 우선순위란?
- 동일한 코드에서 어떤 연산자를 우선 처리할지

결합 방향
- 우선순위가 동일한 연산자를, 어떠한 순서로 연산하는가

연산자 우선순위 외우기
- 표 외우기(사진)

2진수란?
- 2개의 기호를 이용해 데이터를 표현하는 방식
- 10진수는 10개 / 16진수는 16개 등..

2진수 덧셈
- 1+1 시 자기자신은 0이되며 1은 한칸 올린다.
- 0000 1111
  0000 0001
= 0001 0000 

16진수
- 대소문자 구분 없음
- 2진수 4개(4비트)는 16비트1개
- 1바이트를 16진수 2개로 표시

16진수 존재 이유
- 2진수로 표현하면 데이터가 너무 길어지기 때문이다.

비트란?
- 컴퓨터가 표현하는 데이터 최소단위

바이트란
- 비트가 8개 묶인 데이터 단위

진수 데이터 표현
- 0으로 시작하면 8진수
- 0x로 시작하면 16진수
- 특별한 선언 없으면 10진수

2진수를 10진수로 변환
- 2로 나눠서 1이 남을때까지 계산.
- 남은 값부터 각 계산값의 나머지를 이어붙이면 2진수

16진수를 10진수로 변환
- 16의 자리수 제곱 * 값 을 모두 다 더한다.
- 16진수 100
-> (16^0)*1 = 0
-> (16^1)*1 = 0
-> (16^2)*1 = (16*16)*1 = (256)*1 = 256
-> 0 + 0 + 256 = 256
-> 즉, [16진수 100 = 10진수 256]

컴퓨터의 정수 표현 방식
- 가장 앞에 부호비트(MSB. Most Significant Bit)를 표시. 0이면 양수 / 1이면 음수

양의 정수 표현 방법
- MSB가 0이면 양수

음의 정수 표현 방법
- MSB가 1이면 음수
- 2의 보수를 취한다.

2의 보수
- 컴퓨터의 음수 표현 방법
- [1의 보수 -> +1]
- 양->음, 음->양 시 사용

1의 보수
- 0을 1로 / 1을 0으로 변경

컴퓨터의 실수 표현 방식
- 표현 수식이 있음
- 우리가 표현하고자 하는 값의 근사치를 실수로 표시.

실수 표현 문제
- 근사치로 표시하기 때문에 오차가 있음 (부동소수점 오차)

비트연산자
- AND / OR / XOR / NOT / Left Shift / Right Shift
- AND : 2개의 비트가 모두 1이면, 1반환
- OR : 둘 중 하나의 비트면 1이면, 1반환
- XOR : 둘의 비트가 다르면, 1반환. 같으면 0 반ㅌ환
- NOT : 비트가 1이면 0, 0이면 1 반환.
- Left Shift : 비트를 <<로 이동
- RIght SHift : 비트를 >>로 이동

XOR의 특징
- 연속으로 2번 XOR하면 자기 자신이 나온다. (A ^ B = C / C ^ B = A)
- 주로 암호화에 사용

NOT의 특징
- MSB도 바뀐다.

Left Shift의 특징
- << 1칸 이동마다 값은 x2가 된다.
- 비는 값은 0으로 채운다.

Right Shift의 특징
- >> 1칸 이동마다 값은 /2가 된다.
- 비는 값은 양수일경우 0, 음수일 경우 1로 채운다 (MSB 고려)

논리 시프트
- 산술 시프트와 달리 MSB를 지키지 않으며, 빈 값은 무조건 0으로 채운다.

산술 시프트
- MSB를 지키기 때문에, 음수를 >> 연산하면 MSB로 1을 채운다.

자료형이란?
- 데이터를 표현하는 기준.
- 변수와 상수도 자료형에 근거

다양한 자료형 존재 이유
- 컴퓨터가 정수/실수를 표현하는 방법이 다르기 때문에
- 메모리의 효율적 사용을 위해

CPU 최적화 연산. int
- CPU는 정수형 연산 시 int형이 가장 빠르기 때문에, int로 형변환 시킨다.

실수 자료형 선택 시 주의점
- 정밀도 고려 (얼마나 오차가 나는지)

실수 입/출력 서식문자
- 출력 : %f
- 입력 : %lf

unsigned
- MSB조차 값 표현에 사용.
- 정수 자료형만 적용

컴퓨터의 문자 표현 방식
- 숫자와 문자를 맵핑해둔 아스키코드 사용
- 결국 문자도 숫자

문자를 char형에 저장하는 이유
- 아스키 코드가 128개로 이루어져 있기 때문에
- 메모리 효율적 사용

int연산이 CPU에 빠르면 문자도 int로 해야하지 않음?
- int 연산은 정수형 연산때만 빠른데, 문자는 정수형 연산을 할 일이 없음(가능은 함)

상수
- 변경 불가능한 데이터.
- 자료형을 근거로 표현
- 이름 있는 상수 / 이름 없는 상수로 구분

이름 없는 상수(리터럴 상수)
- 할당된 메모리에 이름이 없는 상수

리터럴 상수의 자료형
- 정수형 상수는 int형 / 실수형 상수는 double
- 문자형 상수('A')도 int형

상수형 접미사
- int/double 외 자료형으로 상수를 선언하는 방법
- 대소문자 구분 없음
- U : unsigned int
- L : long
- UL : unsigned long
- LL : long long
- ULL : unsigned long long
- F : float
- L : long double

이름 있는 상수 (심볼릭 함수. const 함수)
- 변수처럼 이름이 있는 상수
- const 키워드 사용 / 매크로 사용
- 값 변경 불가능

const를 이용한 상수
- 선언과 동시에 초기화

형변환
- 자료형 변경
- 자동 형변환 / 강제 형변환
- 딱히 연산은 없고 컴파일러에게 그렇게 알려주는 것

자동 형변환 발생 시점
- 대입 연산 : 대입하는 상황에 두 피연산자의 자료형이 다를 때, 왼편 피연산자 기준으로 자동형변환 (저장소 기준)
- 정수의 승격 : 4바이트 이하의 정수를 연산할 때. CPU가 처리하는데 적합한 자료형은 int. 이때 발생
- 자료형 불일치 : 두 피연산자의 자료형이 다를 때. int a = 1 + 1.5 일때 1 + 1.5에서 자료형 불일치 형변환 발생


정수를 실수로 형변환
- 정상

실수를 정수로 형변환
- 소수부의 손실

바이트가 큰 정수를 바이트가 작은 정수로 형변환
- 상위바이트 손실


소수부의 손실
- 실수형 데이터를 정수형 데이터로 형변환 시 발생
- int a = 3.1414 << 이 상황

상위바이트 손실
- 큰 바이트를 작은 바이트로 형변환 시 발생
- 부호가 바뀌는 상황도 발생한다.
- char ch = 129 << 이 상황
- 00000000 00000000 00000000 10000001(129)가 char에 저장되면 1바이트만 저장되기 때문에 10000001이 저장된다.
- 이는 2의 보수를 해보면 -127이 나온다. 부호가 바뀌었다.


자료형 불일치로 인한 형변환
- 데이터의 손실을 최소화 하는 방향으로 진행
- 정수보단 실수, 정수끼리는 바이트가 큰 것. 실수끼리도 바이트가 큰 것.


강제 형변환 발생 시점
- 프로그래머가 강제로 형변환 발생시킴.

연산 결과의 자료형
- 피 연산자의 자료형과 일치
- 3/4=0이 된다. 0.00... 얼마가 되지만 정수 나눗셈이기 때문에 0이 됨

C언어의 문자열 표현
- 가장 마지막에 null문자가 있는 곳 까지를 문자열로 본다. 이는 C언어의 특징이며 다른 언어는 다르게 표시될 수 있다.

서식문자에 #을 붙이면?
- 각 진수를 진수답게 출력
- %#o(8진수 출력)를 하면 7을 07로 표시
- %#x(16진수 출력)를 하면 7 을 0x7로 표시

실수 서식문자 %e란?
- %e는 지수를 표시하는 방법
- %E는 대문자로 표시

실수 서식문자 %g란?
- 실수의 형태에 따라 %f / %e를 결정

출력의 필드 폭
- %8d : 필드폭 8칸 확보. 오른쪽 정렬
- %-8d : 필드폭 8칸 확복. 왼쪽 정렬

scanf함수란?
- 입력받은 데이터를 메모리에 저장

scanf함수의 특징
- 공백을 기준으로 데이터 구분
- A B C를 입력하면 3개의 데이터, abc를 입력하면 1개의 데이터
- 가장 마지막에 널문자를 자동으로 채워준다.

실수 출력 서식 문자 (printf)
- %f : float (4바이트)
- %f : double (8바이트)
- %Lf : long double (8바이트 이상)

실수 입력 서식 문자 (scanf)
- %f : float
- %lf : double
- Lf : long double

반복문이란?
- 동일한 작업을 반복하는 명령문
- 초기식 / 조건식 / 증감식으로 이루어짐.

반복문의 종류
- while, do~while, for 총 3개

반복문의 핵심
- 반복문의 조건을 무너트리는 연산이 꼭 필요

반복문의 특징
- 반복 대상이 1줄이면, 중괄호(스코프) 생략 가능

무한루프
- 반복문 종료 조건이 없는 루프. 
- 프로그래머가 기능 완성을 위해 사용하기도 함.

while
- 조건제공. 조건 만족 시, 특정 영역 반복

while문과 do ~ while의 차이점
- 반복 조건을 검사하는 시점
- while : 반복조건을 앞에서 확인
- do~while : 반복조건을 뒤에서 확인. 반복 영역을 최소한 1회는 실행

for문과 while문의 차이점
- for문은 [반복 조건(초기식), 조건 검사(조건식), 반복 조건 무너트림(증감식)] 이 3개를 묶어뒀다.
- 초기식 : 최초 1회 호출
- 조건식 : 매 반복 시작 전에 호출
- 증감식 : 매 반복 마지막에 호출

분기문이란?
- 코드의 흐름을 분기시킨다.
- if문 / switch문 / 삼항연산

if문
- if와 else로 이루어져 있음

if문과 if~else문의 차이점
- if문은 모든 조건을 확인.
- if~else는, 조건에 만족하는 if문이 발견되면 나머지는 건너뛴다.

삼항연산자
- 피 연산자가 3개
- A > B ? true : false (A>B가 진실이라면 true 실행 / 거짓이라면 false 진행)
- 가독성이 좋지만 어셈 몇줄이 더들어감

break문
- break문을 감싸고 있는 가장 가까운 반복문 1개를 빠져나옴
- if문이 아니라 while/do~while/for 중 1개!!

continue
- 실행중인 반복문의 조건 검사 위치로 이동
- 그 아래 코드는 모두 무시

case문
- case 레이블에는 상수만 사용 가능
- 분기문의 하나

if~else와 switch문 선택
- 분기가 많은 경우 : switch
- 조건이 애매한 경우 : if~else
goto
- 지정된 레이블로 jump
- 프로그램의 자연스러운 흐름 방해

함수를 만드는 이유
- main함수에서 처리하기에는 프로그램이 너무 방대하기 때문
- 유지보수 용이(문제 생길 시 코드 수정 용이)

함수의 리턴
- C/C++의 경우, 1개만 리턴 가능

함수 선언부 (함수 원형)
- 함수는 호출되기 전에 선언되어 있어야 한다.

함수 정의부 (함수 몸체)
- 실제 함수의 몸체가 있는 부분

정의부와 원형부 분리 이유
- 정의부만 모아 라이브러리 생성 -> 컴파일 속도 증가 / 이름 충돌 가능성 감소 / 코드 관리 용이

전역변수와 지역변수의 차이점
- 메모리상 존재 기간
- 변수 접근 가능 범위

지역 변수(자동변수)
- 해당 스코프를 빠져나갈 때 소멸
- 해당 스코프 내에서만 접근
- 스택 영역에 존재

static 지역변수
- 전역변수의 성격을 갖는다
- 다만, 해당 스코프 내에서만 접근 가능하다.
- 함수 호출 시 마다, 계속 if문으로 생성되었는지 본다.

매개변수
- 함수의 인자로 정의되는 변수
- 지역변수의 일종

전역 변수
- 프로그램 종료 시 소멸
- 프로그램 어디서나 접근 가능 (동일한 이름의 지역변수가 있으면 지역변수로 접근됨)
- Data 영역에 존재

전역변수의 문제점
- 많이쓰면 프로그램을 복잡하게 만든다. (스파게티 코드)

register 변수
- 컴파일러에게 '이 변수는 CPU 레지스터 메모리에 할당해줘'라고 전달하는 것
- 컴파일러가 최종 판단. 적용 안될 수도 있음
- 지역변수만 가능

재귀함수란?
- 함수 내에서 자기 자신을 다시 호출하는 함수.
- 매번 스택을 재할당 한다

재귀함수 장점
- 코드 간결화

재귀함수 단점
- 지속적인 메모리 잡아먹음(스택 영역)

배열이란?
- 둘 이상의 변수를 모아둔 것
- 메모리 공간에 나란히 선언된다.

배열의 구성요소
- 배열 이름 / 자료형 / 길이정보
- int arr[10] : 배열이름은 arr이며 자료형은 int. 길이는 10

배열 초기화리스트
- 사용 시 배열의 길이를 생략해도 됨
- int arr[] = {1,2,3} 하면 자동으로 길이는 3
- int arr[5] = {1,2} 나머지는 0으로 채워짐

배열 sizeof
- 바이트 단위. 
- 길이를 구하고 싶으면 sizeof(arr) / sizeof(int) 와 같이 해야함.

널 문자와 공백문자는 다른것
- 둘이 아스키 코드 값이 다르다. (널은 0, 공백은 32)

널 문자 존재 이유
- 문자열의 끝을 알기 위해

포인터란?
- 변수의 주소값을 저장하는 변수
- 변수형태 포인터 / 상수형태 포인터(포인터 상수)로 나뉜다.
- 상수형태 포인터 : 배열의 이름을 의미. 가리키는 값 변경 불가능

포인터 변수의 크기
- 32비트는 4바이트 / 64비트는 8

포인터 형이 다양한 이유
- 포인터 기반 메모리의 접근 기준 마련.
- int * a << CPU : a의 주소는 0x88인데, int형이니 여기부터 4바이트의 위치에 존재하겠군

포인터 연산자
- & / *
- & : 상수에 사용 불가
- * : 해당 포인터가 가리키는 메모리에 접근

1차원 포인터상수의 포인터 형
- 배열의 이름이 가리키는 대상을 기준으로 결정.
- int arr[4] << 포인터 형 : int

포인터 연산
- 포인터 자료형의 크기를 기준으로 연산
- int *ptr; ptr++ << int가 4바이트 이기 때문에 값(주소)이 4바이트 증가

상수형 문자열 포인터
- 배열에 저장되지 않음.
- char* str = "Hello" <<이런 형태. 내용 수정 불가 / 다른 문자열을 가리킬 순 있음

printf는 문자열의 주소 값을 입력받음

포인터 배열
- 포인터 변수로 이루어진 배열
- int *arr[10] << int형 포인터 변수를 10개 저장할 수 있는 포인터 배열

char형 포인터 배열
- 문자열 포인터 저장 가능
- char *arr[3] = {"Simple", "ABC", "LOVE"}  << 문자열 상수의 포인터 저장

함수의 인자 전달
- 값의 전달(Call by Value)
- 주소의 전달 (Call By reference)

배열을 함수 인자로 전달
- 주소의 전달만 가능
- func(int *arr) << 1차원 배열을 인자로 받을 수 있음.
- func(int arr[]) << 함수 매개변수 선언의 경우, 이것도 위와 동일

함수 인자로 받은 배열의 길이 계산
- 불가능. 
- 이유 : 주소만 전달받았기 때문에. sizeof하면 포인터 크기가 나옴(8바이트)

라이브러리 중 포인터 주소를 전달받은 대표적인 함수
- scanf

const와 포인터의 관계
- const 바로 뒤를 상수화
- const int* ptr = &num : *ptr을 상수화. 포인터 변수 ptr은 num의 값을 변경할 수 없다.
- int* const ptr = &num : ptr을 상수화. 포인터 변수 ptr은 num 말고 다른 변수를 가리킬 수 없음
- const int* const ptr = &num = *ptr 상수화/ ptr 상수화. 포인터 변수 ptr은 num만 가리킬 수 있으며, num의 값도 변경 불가능

const 키워드의 역활
- 프로그램 안전성 증가

2차원 배열
- Type arr[세로][가로] 

2차원 배열의 크기
- sizeof 시, 바이트 단위로 정확히 계산
- int arr[3][4]는 48바이트(3*4*4(int형이니 마지막 *4))

2차원 배열의 메모리 할당
- 1차원 배열처럼 1줄로 할당.

2차원 배열 초기화
- 1차원 배열과 동일한 하지만, {}로 묶어야 한다.
- int arr[3][3] = {
{1},			
{4, 5}
{7, 8, 9} }

{1, 0, 0}
{4, 5, 0}
{7, 8, 9} 로 할당

2차원 배열 크기 안알려주고 초기화
- 배열의 '가로길이'는 알려줘야 함. 세로길이로는 안됨

3차원 배열
- TYPE arr[높이][세로][가로]
- 2차원 배열이 높이만큼 모여있는 느낌


		







워드 단위 복사
- 예를들어 워드가 8바이트일 경우 8바이트는 한 번에 복사된다.
- 하지만, 워드보다 크기가 크다면 바이트 단위 복사가 일어난다.

전역변수에 static일 붙일 경우
- 해당 파일에서만 사용한다는 의미. 다른 파일에서는 접근 불가능

라이브러리란?
- 유용한 기능을 제공하는 코드 집합.
- Class나 Function으로 이루어짐