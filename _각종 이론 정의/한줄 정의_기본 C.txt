프로그래밍 언어란?
- 사람과 컴파일러가 이해할 수 있는 언어

컴파일러의 역활은?
- 프로그래밍 언어를 기계가 이해할 수 있는 기계어로 번역

C언어의 장점
- 절자지향적 -> 배우기 쉽다.
- 이식성이 좋다
- 성능이 좋다

C언어의 단점
- 주의깊게 사용해야 한다.

프로그램 완성 과정
- 코드작성 -> 컴파일 -> 실행파일 생성

함수란
- 반환형 / 함수 이름 / 매개변수 / 몸체로 이루어짐
- 프로그램의 핵심

표준함수
- 기본적으로 제공되는 함수

표준 라이브러리
- 표준함수들의 모임

return의 의미
- 함수를 호출한 영역으로 값을 반환
- 함수 종료

메인함수에서 return에서 0을 반환하는 이유
- 메인함수를 호출한 주체는 운영체제이며, 0은 정상 리턴을 의미.

세미콜론의 역활
- 코드 문장의 끝을 표현

특수문자
- \r, \n같은 특수한 의미가 있는 문자.
- 모든 특수문자는 앞에 \이 붙는다.

\n은(Line Feed)?
- 다음줄로 개행

\r은(Carrige return)?
- 커서를 맨 왼쪽으로 이동

\"는?
- 큰따옴표 자체를 문자에 넣고싶을때 사용.

윈도우의 개행문자
- \r\n을 개행문자로 사용.

주석이 존재하는 이유
- 코드 분석을 용이하게 하기 위함.

주석 중첩
- 블록단위 주석은 중첩 불가능

서식문자란?(conversion specifier)
- 출력의 형태를 지정하는 문자
- 정수,소수,문자,문자열을 표시할 수 있다.
- %d : 10진수
- %u : 언사인 10진수
- %x : 16진수(%X로하면 대문자 출력)
- %p : 포인터의 주소값

변수
- 메모리 공간에 이름을 붙인 것.

변수 초기화란?
- 선언된 변수에 처음 값을 저장하는 것.
- 생성과 동시에 초기화 가능

초기화를 하지 않으면?
- 아무 의미없는 값이 저장되어 있다.

전역 변수를 초기화하지 않으면?
- 전역변수는 자동으로 0으로 초기화된다.

변수 선언 시 주의사항
- 중괄호 가장 앞부분에 위치해야 함(C언어의 경우)
- 공백 삽입 불가능
- 알파뱃/숫자/언더바(_)만 허용
- 숫자로 시작 불가능
- 대소문자 구분함
- 키워드를 변수이름으로 상용 불가

변수의 종류
- 정수형 변수, 실수형 변수

정수형/실수형 변수의 차이점
- 메모리에서 관리되는 방식

함수의 호출문에 연산식
- 함수 호출보다 연산식이 먼저 진행

이항 연산자
- 2개의 피연산자 존재
- 대입 / 산술 / 복합대입 / 비교연산 / 논리AND / 논리 OR

비교연산의 특징
- 조건 만족 시 true, 불만족시 false 반환
- 타 연산자들과 작동 방식이 조금 다름

부호 연산자
- 변수나 상수 앞에 붙는 부호
- + / -
- 복합대입과 햇갈리지 말자

단항 연산자
- 1개의 피연산자 존재
- 전위 증감 / 후위 증감 / 논리 NOT
- 전위 증/감 : 변수 증/감 후 로직 진행
- 후위 증/감 : 모든 로직 종료 후, 코드 다음줄로 이동시 변수 증/감

후위 증/감과 소괄호
- int num2 = (num--)+2;
- num--이 먼저 된 후 +2가 될 것 같지만 num+2 후, 코드 다음줄로 이동 시 num--이 진행

논리 연산자
- 논리 AND(&&) : 둘 다 참이면 true 반환
- 논리 OR(||) : 둘 중 하나라도 true면 true 반환
- 논리 NOT(!) : false를 true로 / true를 false로 변환해 반환

콤마 연산자
- 구분을 목적으로 하는 연산자

연산자 우선순위란?
- 동일한 코드에서 어떤 연산자를 우선 처리할지

결합 방향
- 우선순위가 동일한 연산자를, 어떠한 순서로 연산하는가

연산자 우선순위 외우기
- 표 외우기(사진)

2진수란?
- 2개의 기호를 이용해 데이터를 표현하는 방식
- 10진수는 10개 / 16진수는 16개 등..

2진수 덧셈
- 1+1 시 자기자신은 0이되며 1은 한칸 올린다.
- 0000 1111
  0000 0001
= 0001 0000 

16진수
- 대소문자 구분 없음
- 2진수 4개(4비트)는 16진수 1개
- 1바이트를 16진수 2개로 표시

16진수 존재 이유
- 2진수로 표현하면 데이터가 너무 길어지기 때문이다.

비트란?
- 컴퓨터가 표현하는 데이터 최소단위

바이트란
- 비트가 8개 묶인 데이터 단위

진수 데이터 표현
- 0으로 시작하면 8진수
- 0x로 시작하면 16진수
- 특별한 선언 없으면 10진수

2진수를 10진수로 변환
- 2로 나눠서 1이 남을때까지 계산.
- 남은 값부터 각 계산값의 나머지를 이어붙이면 2진수

16진수를 10진수로 변환
- 16의 자리수 제곱 * 값 을 모두 다 더한다.
- 16진수 100
-> (16^0)*0 = 0
-> (16^1)*0 = 0
-> (16^2)*1 = (16*16)*1 = (256)*1 = 256
-> 0 + 0 + 256 = 256
-> 즉, [16진수 100 = 10진수 256]

컴퓨터의 정수 표현 방식
- 가장 앞에 부호비트(MSB. Most Significant Bit)를 표시. 0이면 양수 / 1이면 음수

양의 정수 표현 방법
- MSB가 0이면 양수

음의 정수 표현 방법
- MSB가 1이면 음수
- 2의 보수를 취한다.

2의 보수
- 컴퓨터의 음수 표현 방법
- [1의 보수 -> +1]
- 양->음, 음->양 시 사용

1의 보수
- 0을 1로 / 1을 0으로 변경

컴퓨터의 실수 표현 방식
- 표현 수식이 있음
- 우리가 표현하고자 하는 값의 근사치를 실수로 표시.

실수 비트 구조
- 상위 1비트는 MSB
- 나머지 중 8비트(float 기준)는 지수 부분
- 나머지 23비트(float 기준)는 가수 부분

실수 비트의 지수부분/가수부분
- 지수 부분 : 기준이 되는 값 저장. 값 자체는 아님(127이면, 127의 기준값이 저장됨. 127이 저장되는것이 아님)
- 가수 부분 : 지수 부분을 기준으로, 계산되는 값. 정밀도 높임.

실수 계산 방법
- 지수 부분의 기준값에서, 가수 부분을 1비트씩 보면서 1이면 /2를 계속한다.
- 가수 부분의 마지막 비트까지 확인한 값이 최종 결과값이다.
- 위와 같은 작업은 CPU가 한다.

double과 float의 차이점
- double은 지수/가수부분이 더 크다.
- 지수부분이 큼으로써, 표현 가능 값이 더 크다.
- 가수부분이 큼으로써, 소수부분 정밀도가 높다.

실수 계산이 정수 계산보다 오버헤드가 큰 이유
- 정수는 비트 자체의 값을 단순히 대입만 하면 되는데, 실수는 비트를 보고 실제 값을 만들어내야하기 때문에.

부동 소수점 오차
- 지수와 가수의 조합으로 값이 만들어지기 때문에, 근사치로 저장되어 오차 발생.

비트연산자
- AND / OR / XOR / NOT / Left Shift / Right Shift
- AND : 2개의 비트가 모두 1이면, 1반환
- OR : 둘 중 하나의 비트면 1이면, 1반환
- XOR : 둘의 비트가 다르면, 1반환. 같으면 0 반ㅌ환
- NOT : 비트가 1이면 0, 0이면 1 반환.
- Left Shift : 비트를 <<로 이동
- RIght SHift : 비트를 >>로 이동

비트 XOR의 특징
- 연속으로 2번 XOR하면 자기 자신이 나온다. (A ^ B = C / C ^ B = A)
- 주로 암호화에 사용

비트 NOT의 특징
- MSB도 바뀐다.

Left Shift의 특징
- << 1칸 이동마다 값은 x2가 된다.
- 비는 값은 0으로 채운다.

Right Shift의 특징
- >> 1칸 이동마다 값은 /2가 된다.
- 비는 값은 양수일경우 0, 음수일 경우 1로 채운다 (MSB 고려)

논리 시프트
- 산술 시프트와 달리 MSB를 지키지 않으며, 빈 값은 무조건 0으로 채운다.

산술 시프트
- MSB를 지키기 때문에, 음수를 >> 연산하면 MSB로 1을 채운다.

자료형이란?
- 데이터를 표현하는 기준.
- 변수와 상수도 자료형에 근거

다양한 자료형 존재 이유
- 컴퓨터가 정수/실수를 표현하는 방법이 다르기 때문에
- 메모리의 효율적 사용을 위해

CPU 최적화 연산. int
- CPU는 정수형 연산 시 int형이 가장 빠르기 때문에, int로 형변환 시킨다.

실수 자료형 선택 시 주의점
- 정밀도 고려 (얼마나 오차가 나는지)

실수 입/출력 서식문자
- 출력 : %f
- 입력 : %lf

unsigned
- MSB조차 값 표현에 사용.
- 정수 자료형만 적용

컴퓨터의 문자 표현 방식
- 숫자와 문자를 맵핑해둔 아스키코드 사용
- 결국 문자도 숫자

문자를 char형에 저장하는 이유
- 아스키 코드가 128개로 이루어져 있기 때문에
- 메모리 효율적 사용

int연산이 CPU에 빠르면 문자도 int로 해야하지 않음?
- int 연산은 정수형 연산때만 빠른데, 문자는 정수형 연산을 할 일이 없음(가능은 함)

상수
- 변경 불가능한 데이터.
- 자료형을 근거로 표현
- 이름 있는 상수 / 이름 없는 상수로 구분

이름 없는 상수(리터럴 상수)
- 할당된 메모리에 이름이 없는 상수

리터럴 상수의 자료형
- 정수형 상수는 int형 / 실수형 상수는 double
- 문자형 상수('A')도 int형

상수형 접미사
- int/double 외 자료형으로 상수를 선언하는 방법
- 대소문자 구분 없음
- U : unsigned int
- L : long
- UL : unsigned long
- LL : long long
- ULL : unsigned long long
- F : float
- L : long double

이름 있는 상수 (심볼릭 함수. const 함수)
- 변수처럼 이름이 있는 상수
- const 키워드 사용 / 매크로 사용
- 값 변경 불가능

const를 이용한 상수
- 선언과 동시에 초기화

형변환
- 자료형 변경
- 자동 형변환 / 강제 형변환
- 딱히 연산은 없고 컴파일러에게 그렇게 알려주는 것

자동 형변환 발생 시점
- 대입 연산 : 대입하는 상황에 두 피연산자의 자료형이 다를 때, 왼편 피연산자 기준으로 자동형변환 (저장소 기준)
- 정수의 승격 : 4바이트 이하의 정수를 연산할 때. CPU가 처리하는데 적합한 자료형은 int. 이때 발생
- 자료형 불일치 : 두 피연산자의 자료형이 다를 때. int a = 1 + 1.5 일때 1 + 1.5에서 자료형 불일치 형변환 발생


정수를 실수로 형변환
- 정상

실수를 정수로 형변환
- 소수부의 손실

바이트가 큰 정수를 바이트가 작은 정수로 형변환
- 상위바이트 손실


소수부의 손실
- 실수형 데이터를 정수형 데이터로 형변환 시 발생
- int a = 3.1414 << 이 상황

상위바이트 손실
- 큰 바이트를 작은 바이트로 형변환 시 발생
- 부호가 바뀌는 상황도 발생한다.
- char ch = 129 << 이 상황
- 00000000 00000000 00000000 10000001(129)가 char에 저장되면 1바이트만 저장되기 때문에 10000001이 저장된다.
- 이는 2의 보수를 해보면 -127이 나온다. 부호가 바뀌었다.


자료형 불일치로 인한 형변환
- 데이터의 손실을 최소화 하는 방향으로 진행
- 정수보단 실수, 정수끼리는 바이트가 큰 것. 실수끼리도 바이트가 큰 것.


강제 형변환 발생 시점
- 프로그래머가 강제로 형변환 발생시킴.

연산 결과의 자료형
- 피 연산자의 자료형과 일치
- 3/4=0이 된다. 0.00... 얼마가 되지만 정수 나눗셈이기 때문에 0이 됨

C언어의 문자열 표현
- 가장 마지막에 null문자가 있는 곳 까지를 문자열로 본다. 이는 C언어의 특징이며 다른 언어는 다르게 표시될 수 있다.

서식문자에 #을 붙이면?
- 각 진수를 진수답게 출력
- %#o(8진수 출력)를 하면 7을 07로 표시
- %#x(16진수 출력)를 하면 7 을 0x7로 표시

실수 서식문자 %e란?
- %e는 지수를 표시하는 방법
- %E는 대문자로 표시

실수 서식문자 %g란?
- 실수의 형태에 따라 %f / %e를 결정

출력의 필드 폭
- %8d : 필드폭 8칸 확보. 오른쪽 정렬
- %-8d : 필드폭 8칸 확복. 왼쪽 정렬

scanf함수란?
- 입력받은 데이터를 메모리에 저장

scanf함수의 특징
- 공백을 만날때 까지 버퍼에서 읽는다 (\n이 아니라 공백)
- A B C를 입력하면 3개의 데이터, abc를 입력하면 1개의 데이터
- 가장 마지막에 널문자를 자동으로 채워준다.

실수 출력 서식 문자 (printf)
- %f : float (4바이트)
- %f : double (8바이트)
- %Lf : long double (8바이트 이상)

실수 입력 서식 문자 (scanf)
- %f : float
- %lf : double
- Lf : long double

반복문이란?
- 동일한 작업을 반복하는 명령문
- 초기식 / 조건식 / 증감식으로 이루어짐.

반복문의 종류
- while, do~while, for 총 3개

반복문의 핵심
- 반복문의 조건을 무너트리는 연산이 꼭 필요

반복문의 특징
- 반복 대상이 1줄이면, 중괄호(스코프) 생략 가능

무한루프
- 반복문 종료 조건이 없는 루프. 
- 프로그래머가 기능 완성을 위해 사용하기도 함.

while
- 조건제공. 조건 만족 시, 특정 영역 반복

while문과 do ~ while의 차이점
- 반복 조건을 검사하는 시점
- while : 반복조건을 앞에서 확인
- do~while : 반복조건을 뒤에서 확인. 반복 영역을 최소한 1회는 실행

for문과 while문의 차이점
- for문은 [반복 조건(초기식), 조건 검사(조건식), 반복 조건 무너트림(증감식)] 이 3개를 묶어뒀다.
- 초기식 : 최초 1회 호출
- 조건식 : 매 반복 시작 전에 호출
- 증감식 : 매 반복 마지막에 호출

분기문이란?
- 코드의 흐름을 분기시킨다.
- if문 / switch문 / 삼항연산

if문
- if와 else로 이루어져 있음

if문과 if~else문의 차이점
- if문은 모든 조건을 확인.
- if~else는, 조건에 만족하는 if문이 발견되면 나머지는 건너뛴다.

삼항연산자
- 피 연산자가 3개
- A > B ? true : false (A>B가 진실이라면 true 실행 / 거짓이라면 false 진행)
- 가독성이 좋지만 어셈 몇줄이 더들어감

break문
- break문을 감싸고 있는 가장 가까운 반복문 1개를 빠져나옴
- if문이 아니라 while/do~while/for 중 1개!!

continue
- 실행중인 반복문의 조건 검사 위치로 이동
- 그 아래 코드는 모두 무시

case문
- case 레이블에는 상수만 사용 가능
- 분기문의 하나

if~else와 switch문 선택
- 분기가 많은 경우 : switch
- 조건이 애매한 경우 : if~else

goto
- 지정된 레이블로 jump
- 프로그램의 자연스러운 흐름 방해

함수를 만드는 이유
- main함수에서 처리하기에는 프로그램이 너무 방대하기 때문
- 유지보수 용이(문제 생길 시 코드 수정 용이)

함수의 리턴
- C/C++의 경우, 1개만 리턴 가능

함수 선언부 (함수 원형)
- 함수는 호출되기 전에 선언되어 있어야 한다.

함수 정의부 (함수 몸체)
- 실제 함수의 몸체가 있는 부분

전역변수와 지역변수의 차이점
- 메모리상 존재 기간
- 변수 접근 가능 범위

지역 변수(자동변수)
- 해당 스코프를 빠져나갈 때 소멸
- 해당 스코프 내에서만 접근
- 스택 영역에 존재

static 지역변수
- 전역변수의 성격을 갖는다
- 다만, 해당 스코프 내에서만 접근 가능하다.
- 함수 호출 시 마다, 계속 if문으로 생성되었는지 본다.

매개변수
- 함수의 인자로 정의되는 변수
- 지역변수의 일종

전역 변수
- 프로그램 종료 시 소멸
- 프로그램 어디서나 접근 가능 (동일한 이름의 지역변수가 있으면 지역변수로 접근됨)
- Data 영역에 존재

전역변수의 문제점
- 많이쓰면 프로그램을 복잡하게 만든다. (스파게티 코드)

register 변수
- 컴파일러에게 '이 변수는 CPU 레지스터 메모리에 할당해줘'라고 전달하는 것
- 컴파일러가 최종 판단. 적용 안될 수도 있음
- 지역변수만 가능

재귀함수란?
- 함수 내에서 자기 자신을 다시 호출하는 함수.
- 매번 스택을 재할당 한다

재귀함수 장점
- 코드 간결화

재귀함수 단점
- 지속적인 메모리 잡아먹음(스택 영역)

배열이란?
- 둘 이상의 변수를 모아둔 것
- 메모리 공간에 나란히 선언된다.

배열의 구성요소
- 배열 이름 / 자료형 / 길이정보
- int arr[10] : 배열이름은 arr이며 자료형은 int. 길이는 10

배열 초기화리스트
- 사용 시 배열의 길이를 생략해도 됨
- int arr[] = {1,2,3} 하면 자동으로 길이는 3
- int arr[5] = {1,2} 나머지는 0으로 채워짐

배열 sizeof
- 바이트 단위. 
- 길이를 구하고 싶으면 sizeof(arr) / sizeof(int) 와 같이 해야함.

널 문자와 공백문자는 다른것
- 둘이 아스키 코드 값이 다르다. (널은 0, 공백은 32)

널 문자 존재 이유
- 문자열의 끝을 알기 위해

포인터란?
- 변수의 주소값을 저장하는 변수
- 변수형태 포인터 / 상수형태 포인터(포인터 상수)로 나뉜다.
- 상수형태 포인터 : 배열의 이름을 의미. 가리키는 값 변경 불가능

포인터 변수의 크기
- 32비트는 4바이트 / 64비트는 8

포인터 형이 다양한 이유
- 포인터 기반 메모리의 접근 기준 마련.
- int * a << CPU : a의 주소는 0x88인데, int형이니 여기부터 4바이트의 위치에 존재하겠군

포인터 연산자
- & / *
- & : 상수에 사용 불가
- * : 해당 포인터가 가리키는 메모리에 접근

1차원 배열의 포인터 형
- 배열의 가리키는 첫 요소를 기준으로 결정.
- int arr[4] << 포인터 형 : int

포인터 연산
- 포인터 자료형의 크기를 기준으로 연산
- int *ptr; ptr++ << int가 4바이트 이기 때문에 값(주소)이 4바이트 증가

상수형 문자열 포인터 (char형 포인터)
- 메모리에 있는 문자열의 첫 주소를 가리킬수 있음
- char* str = "Hello" <<이런 형태. 내용 수정 불가 / 다른 문자열을 가리킬 순 있음

printf는 문자열의 주소 값을 입력받음

포인터 배열
- 포인터 변수로 이루어진 배열
- int *arr[10] << int형 포인터 변수를 10개 저장할 수 있는 포인터 배열
- 2중 포인터로 가리키기 가능

포인터 배열의 포인터 형
- 배열 이름이 가리키는 첫번째 요소의 자료형
(int *arr[20];	int **parr = arr; << 이렇게 가능)

char형 포인터 배열
- char형 포인터 변수를 여러개 담는 배열
- char *arr[3] = {"Simple", "ABC", "LOVE"}  << 문자열 상수의 포인터 저장

함수의 인자 전달
- 값의 전달(Call by Value)
- 주소의 전달 (Call By reference)

배열을 함수 인자로 전달
- 주소의 전달만 가능 (배열 이름은 애초에 포인터이기 때문)
- func(int *arr) << 1차원 배열을 인자로 받을 수 있음.
- func(int arr[]) << 함수 매개변수 선언의 경우, 이것도 위와 동일

포인터의 call-by-reference
- int *a = &num일 경우, a가 num2를 가리키게 하고 싶다.
- 함수를 만들면 인자는? void func(int **pa); func(&a)와 같이 해야 한다.
- void func(int *pa); func(a) 처럼 할 경우, a의 값(a의 값은 num의 주소)만 전달된다.
- 즉, call-by-value이다.

함수 인자로 받은 배열의 길이 계산
- 불가능. 
- 이유 : 주소만 전달받았기 때문에. sizeof하면 포인터 크기가 나옴(8바이트)

라이브러리 중 포인터 주소를 전달받은 대표적인 함수
- scanf

const와 포인터의 관계
- const 바로 뒤를 상수화
- const int* ptr = &num : *ptr을 상수화. 포인터 변수 ptr은 num의 값을 변경할 수 없다.
- int* const ptr = &num : ptr을 상수화. 포인터 변수 ptr은 num 말고 다른 변수를 가리킬 수 없음
- const int* const ptr = &num = *ptr 상수화/ ptr 상수화. 포인터 변수 ptr은 num만 가리킬 수 있으며, num의 값도 변경 불가능

const 키워드의 역활
- 프로그램 안전성 증가

2차원 배열
- Type arr[세로][가로] 

2차원 배열의 크기
- sizeof 시, 바이트 단위로 정확히 계산
- int arr[3][4]는 48바이트(3*4*4(int형이니 마지막 *4))

2차원 배열의 메모리 할당
- 1차원 배열처럼 1줄로 할당.

2차원 배열 초기화
- 1차원 배열과 동일한 하지만, {}로 묶어야 한다.
- int arr[3][3] = {
{1},			
{4, 5}
{7, 8, 9} }

{1, 0, 0}
{4, 5, 0}
{7, 8, 9} 로 할당

2차원 배열 크기 안알려주고 초기화
- 배열의 '가로길이'는 알려줘야 함. 세로길이로는 안됨

3차원 배열
- TYPE arr[높이][세로][가로]
- 2차원 배열이 높이만큼 모여있는 느낌.

이중포인터란?
- 포인터 변수의 주소를 저장
- 1차원 포인터 배열을 가리킬 수 있다.
		
이중포인터의 사용처
- 포인터 변수가 가리키는 대상을 swap하는 함수 제작 시, 인자로 이중 포인터를 해야함

2차원 배열의 형은?
- 더블 포인터형 아님
- 더블 포인터는 포인터 배열을 가리킬 수 있음

2차원 배열에서 arr과 arr[0]은 같은것?
- 다른것!!
- arr : 배열의 첫 번째 요소를 가리키며, 배열 전체를 의미. sizeof하면 2차원 배열 전체 사이즈가 나옴
- arr[0] : 배열의 첫번째 요소를 가리키며, 행 1개를 의미. sizeof하면 2차원 배열의 행 1개의 사이즈가 나옴

2차원 배열의 포인터 연산
- ++/ -- 시, 해당 배열의 자료형(int ,double 등..) * 가로길이 만큼의 바이트가 이동한다.
- int arr1[3][2] ;	arr1+1 << 2행의 첫번째 요소를 가리킨다.

2차원 배열의 포인터 형
- 자료형 / 포인터 연산 값. <<이 2개가 필요
- int arr[3][4]의 포인터형은? : 가리키는 대상은 int형이며, 포인터 연산 시 sizeof(int) * 4(가로길이) 만큼 이동

2차원 배열을 가리키는 포인터 변수 (배열 포인터 변수)
- int arr[2][4];	int (*ptr)[4] <<와 같이 표시
- 배열 포인터 변수 1개가, 세로 길이가 다른 (가로길이는 같은) 변수 여러개를 가리킬 수 있다.

포인터 배열과 배열 포인터
- 포인터 배열 : int *who[4] (int형 1차원 포인터 변수 4개 저장 가능)
- 배열 포인터 : int (*who)[4] (2차원 배열을 가리킬 수 있는 포인터. 1차원은 의미 없음)

2차원 포인터 배열을 가리키려면?
- 배열 포인터로 가리키면 된다.
- int *who[2][4];  int* (*parr)[4] = who;

2차원 배열을 함수 인자로 전달하기
- void Func( int (*parr)[7], int (*parr2][5] )
- void Func( int parr[][7], int parr2[][5] )  << 이것도 가능. 이건 매개변수로 선언할 때만 가능

2차원 배열 세로길이 계산법
- 배열 전체 바이트 / 행 1개 바이트(가로)
- sizeof(arr) / sizeof(arr[0]); --> 32 / sizeof(arr[0]) --> 32 / 16 --> 결론은 2. 세로 길이를 구했다!
- 참고로 sizeof(arr[0])은 1개 행의 가로 바이트를 구한다. 지금은 가로가 4니까 4*4 16이다.

함수의 이름
- 함수의 이름도 주소다.
- 배열과 마찬가지로 상수이다.

함수 포인터 변수
- 함수의 이름(함수의 주소)을 저장하는 포인터 변수
- int Test(int num, int num2) {...} --> int (*fp)(int, int) 이렇게 선언
- fp = Test 와 같이 대입 가능 

함수 포인터의 형
- 반환형 / 매개변수 << 이 2개로 결정
- int Test(int num) {....} << 함수 Test의 포인터 형은 반환형은 int, 매개변수는 int형 변수 1개이다.

함수 이름과 함수 포인터의 차이
- 함수 이름은 다른 함수를 가리킬 수 없음, 함수 포인터는 형만 맞다면 다른 함수를 가리킬 수 있음

함수 포인터 사용 목적
- 분기문을 제거할 수 있다.

void포인터란?
- 형이 존재하지 않는 포인터

void포인터의 장점
- 어떤 포인터든 담을 수 있다.

void 포인터의 단점
- 형이 없기때문에 연산을 할 수 없다.

void 포인터 사용처
- 주소값을 잠시 저장해두는 용도? 혹은 사용자에게 형을 맡기는 경우

스트림
- OS가 제공하는 입출력 소프트웨어. 다리.
- 한쪽 방향으로만 연결된다

표준 스트림(콘솔 스트림. 키보드와 모니터)
- printf는 출력 스트림 사용 / scanf는 입력 스트림 사용 (stdin / stdout) 
- 프로그램 시작 시 자동 생성 / 종료 시 자동 삭제

문자 입/출력함수 존재 이유
- printf / scanf는 무겁다. 때문에, 가벼운 함수 제공

문자 출력 함수 (문자열 아님)
- 문자를 출력 스트림으로 보내는 함수
- putchar  : 표준 스트림만 사용. 
- fputc : 스트림 선택 가능. 주로 파일 스트림 선택

문자 입력 함수 (문자열 아님)
- 입력 스트림으로 문자를 입력받음
- getchar : 표준 스트림만 사용. 
- fgetc : 스트림 선택 가능. 주로 파일 스트림 선택

엔터키도 입/출력 문자 중 하나

문자열 함수의 리턴값을 int로 받는 이유
- EOF 체크를 위해

EOF(End of File)
- 파일의 끝을 정의한 상수
- 파일 Read 시, 어디까지 읽어야할지 확인하기 위한 용도

파일이 아닌 표준 입출력에서 EOF가 리턴되는 경우
- 함수 호출 실패
- CTRL+Z키

문자열 출력 함수
- puts : 표준 스트림만 사용. 자동 개행
- fputs : 스트림 선택 가능. 자동 개행 아님

문자열 입력 함수
- \n을 만날 때 까지 데이터 입력 받음 (공백 아님)
- 공백 입력받기 가능 (scanf는 입력 못받음)
- 자동으로 널문자 추가
- gets : 표준 스트림만 사용 가능. 메모리 침범 가능성
- fgets : 스트림 선택. 메모리 침범 가능성 없음 (지정된 길이만큼 입력 받음)

fgets의 특징
- \n을 버리지 않고 하나의 문자로 받아들임 (gets는 \n 버림)

표준 입출력 버퍼
- printf / scanf / fgets / fputs 등 표준 입출력 함수는, OS가 제공하는 메모리 버퍼를 사용

표준 입출력의 메모리 버퍼
- 데이터를 임시로 저장해두는 공간 (버퍼링 공간)
- 출력버퍼에 데이터가 들어가는 시점 : 시스템마다 다르다.
- 입력버퍼에 데이터가 들어가는 시점 : 엔터키를 누르는 순간

출력버퍼가 비워진다는 것의 의미
- 출력 버퍼의 데이터가 목적지로 이동하는 것.

fflush
- 출력 버퍼의 데이터를 강제로 비우는 함수

입력 버퍼가 비워진다는 것의 의미
- 실제 데이터가 삭제된다.

입력버퍼 비우기
- 입력 버퍼로부터 읽어들이면 삭제된다.
- while (getchar() != '\n'); 와 같은 코드로 입력버퍼 비우기 가능

strlen
- 문자열 길이 반환
- 널문자 제외한 길이. \n은 길이로 포함시킨다!!

strcpy, strncpy
- 문자열 복사
- 널문자 채워주지 않음. 단순한 복사! 널문자는 직접 넣어야 한다.
- strncpy는 복사할 길이를 지정

strcat, strncat
- 문자열 덧붙이기
- 덧붙임 시작 위치는, 널문자 부터. (널문자 다음 아님)
- strcpy는 다르게, 널문자 채워줌!
- strncat은 복사할 길이를 지정

strcmp, strncmp
- 아스키값 기준 문자열 비교
- 둘이 같으면 0, 다르면 0이 아닌값 리턴
- strncmp는 비교할 문자 길이를 지정

구조체란?
- 연관있는 데이터를 묶어 정의된 자료형
- 사용자 정의 자료형

구조체 사용 이유
- 데이터 관리 용이 --> 합리적 코드 작성

구조체 초기화
- struct point pos = {10, 20}; 으로 가능
- 초기화하지 않은 값은 0으로 초기화
- 선언과 동시에 초기화 할 경우, strcpy 없이 문자열 복사 가능

구조체 변수의 주소값
- 구조체 변수 첫 멤버의 주소값과 동일
- 배열과 동일

typedef
- 기존에 존재하는 자료형의 이름에 새 이름을 부여
- 가장 마지막에 등장하는 단어를 중심으로. (typedef name1 name2 name3 이라면 'name1 name2' 자료형에 name3 자료형이 추가된 것)

구조체 연산
- 대입연산 / &연산 / sizeof연산 이정도만 가능
- 특히, 대입은 멤버대 멤버 복사.

구조체 중첩
- 구조체 안에 구조체 변수가 멤버로 존재하는 상황.

공용체
- struct 대신 union사용
- 내부 멤버변수 중 가장 큰 변수 1개만 할당되어 공유한다.

공용체 사용처
- 하나의 메모리에 둘 이상의 방식으로 접근

열거체
- enum 사용
- 저장 가능한 값을 정수의 형태로 결정
- 상수만 저장 가능

열거형 상수값 결정 방식
- 기본 0부터 시작
- 중간에 값이 바뀌면, 그 뒤는 바뀐값의 +1이 되면서 이어감.

열거체 사용 이유
- 연관있는 상수를 모아둠으로써 가독성 증가

fopen, fopen_s
- 파일 스트림 생성
- 파일 입출력 첫단계
- fopen_s는 fopen보다 안전버전이다.

fclose
- 파일 스트림 소멸
- 버퍼에 있는 데이터 이동

fclose 안할 시 발생 문제
- 논페이지드 메모리 증가 (커널 오브젝트임 파일도.)
- 다른 유저(혹은 스레드) 접근 불가

feof
- 파일의 끝에 도착했는지 확인. 도착했으면 0이 아닌 값 리턴
- 파일 입출력 함수의 EOF은 에러시에도 반환되기때문에 꼭 feof로 확인해야함

파일 개방 모드
- 뒤에 붙는 t나 b는 Text와 Binary를 의미
- 아무것도 안붙이면 기본 Text모드
- r : 읽기만 가능. 파일 없으면 에러
- w : 쓰기만 가능. 파일 없으면 생성
- a : 덧붙이여 쓰기 가능 . 파일 없으면 생성

파일 개방모드에 +가 있을 경우
- 기능 2개 제공
- r+ : 읽기/쓰기 가능. 파일 없으면 에러
- w+ : 읽기/쓰기 가능. 파일 없으면 생성
- a+ : 읽기/덧붙이기 가능. 파일 없으면 생성

텍스트 모드
- 개행을 자동으로 OS에 맞게 저장하고, 읽어올때도 자동으로 변환
- C는 \n. 윈도우 파일은 \r\n. C에서 저장 시 \r을 추가해야하지만 자동으로 해줌. 읽을때도 \r\n을 자동으로 \n으로 해줌
- 파일 개방 시 t를 붙이면 됨. 아무것도 안하면 자동으로 텍스트 모드로 열림

텍스트 모드 파일입출력 함수
- fgetc, fputc, fgets, fputs

바이너리 모드 파일 입출력 함수
- fread, fwrite

텍스트와 바이너리를 같이 읽고 쓰기
- 서식데이터 파일 입출력 사용 (fprintf / fscanf). 데이터 읽는순서는 저장순서와 일치해야 함
- 구조체 변수를 binary 모드로 읽고 쓰기 (fread, fwrite)

파일 지시자(파일 포인터)
- 파일의 위치 중, 현재 읽거나 쓸 위치를 가리킨다.

파일 지시자 이동법
- fseek 함수 호출
- 마지막 인자로 SEEK_SET(처음위치부터), SEEK_CUR(현재 위치부터), SEEK_END(마지막 위치부터) 선택 가능

SEEK_END
- 여기서 이야기하는 마지막 위치는 EOF이다. 
- EOF는, 파일의 끝 바로 뒤에 따로 존재한다. EOF 자체가 파일의 끝은 아니다.

파일 지시자의 현지 위치 알기
- ftell. 인덱스 기준으로 반환 (0부터 시작). 바이트 단위
- 보통, 파일의 현재 크기를 바이트단위로 구할때 사용

메모리 공간을 나눈 이유
- 관리 용이. 메모리 접근속도 증가

스택에 쌓이는 순서
- 함수 호출 시, 매개변수 -> 지역변수 순서로 쌓이게 된다.

힙의 특징
- 생성/소멸 시기가 지역변수나 전역변수와는 다른 유형.

힙의 메모리 소멸 시점
- 사용자가 명시적으로 소멸 함수 호출
- 프로그램 종료

malloc 함수
- 실패 시 null 반환
- new는 실패 시 bad_allocate라는 예외 던짐

malloc함수의 반환형이 void*인 이유
- 사용자는 malloc에게 할당할 바이트만 전달하기 때문에, 말록함수는 이게 int인지 char인지 뭔지 모른다.

malloc과 calloc의 차이
- calloc은 '4바이트 블록 30개를 할당하라'와 같은 형식
- 그리고 calloc은 모든 비트를 0으로 초기화

realloc
- 할당된 힙 영역 확장.
- 상황 1 : 뒤에 공간이 충분한 경우, memcpy 발생하지 않음
- 상황 2 : 뒤에 공간이 부족한 경우, 새로운 공간을 할당한 후 memcpy 발생

전처리기(선행처리기. preprocessor)
- 전처리문(#)을 단순 치환
- 뒤에 세미콜론 붙이지 않음

전처리기 구성
- 지시자 / 매크로 / 매크로 몸체 << 3개로 이루어짐
- 지시자 : #define
- 매크로 : PI
- 매크로 몸체 : 3.1415
- 매크로를 매크로 몸체로 치환하라!

매크로 확장
- 전처리기에 의해 치환되는 과정

매크로 상수
- #define을 이용해 구성하는 일반적인 전처리문
- #define PI 3.1415

매크로 함수
- 함수처럼 작동하는 매크로
- #define SQUARE(X) X*X
- 괄호로 잘 묶어야 함
- 매크로 몸체가 매크로 함수의 호출문장을 대체

매크로를 2줄로 정의
- \문자 사용

매크로 함수 장점
- 실행속도 빠름 (스택 메모리 할당/매개변수 인자 전달/리턴 값 반환 같은 절차 없음)
- 자료형에 상관없이 사용 가능

매크로 함수 단점
- 정의하기 까다롭다
- 디버깅하기 까다롭다.(대소문자 구분 등...)

매크로 함수를 사용하는 경우
- 작은 크기의 함수
- 호출 빈도수가 많은 함수

조건부 컴파일
- #if ~ #endif (이게 한 몸)
- #ifdef ~ #endif (ifdef 뒤에 오는 매크로가 정의되어 있다면)
- #ifndef ~ #endif (ifndef 뒤에 오는 매크로가 정의되어 있지 않다면). 주로 헤더파일 중복 포함 방지
- #elif : #if에만 적용. #else도 함께 사용 가능.

문자열 매크로 함수
- 문자열은 치환되지 않음 --> 매크로 확장이 발생하지 않음
- #define STR(ABC)  #ABC와 같이 #를 붙이면 된다.

문자열을 나란히 선언할 경우
- cha* str = "ABC" "DEF" 는 "ABCDEF"와 동일하다.

매크로 ## 연산자
- 전달 인자들을 단순히 이어주는 역활
- #defeine CON(UPP, LOW)	UPP ## 00 ## LOW
- CON(22,77)로 호출하면 --> 220077로 나온다.

헤더파일이란?
- 함수나 라이브러를 컴파일 할 때 필요한 인터페이스들이 정의되어 있는 파일

헤더파일 정의 이유
- 코드 관리 용이
- 컴파일러에게 컴파일 타임에 필요한 내용만 전달하기 위함.

헤더파일 중복 삽입 문제
- #ifndef ~ #endif 사용
- 구조체,클래스의 경우 2번 전달하면 문제 생김

컴파일러는 파일단위로 컴파일
- 헤더파일은 컴파일러에게 정보를 알리는 역활

#include <> 와 #include ""의 차이
- <>는 C표준 헤더파일에서 찾음
- ""는 현재 디렉토리 기준으로 찾음

매크로도 파일 단위로만 유효
- #define도 파일단위로만 유효하기 때문에, 헤더파일에 선언되어야 함.

extern
- 변수/함수가 외부에 정의되었음을 알린다.
- 함수는 생략 가능.

전역변수에 static일 붙일 경우
- 해당 파일에서만 사용한다는 의미. 다른 파일에서는 접근 불가능

static 전역 함수
- static 전역변수처럼, 해당 파일에서만 접근 가능

str시리즈와 _s 시리즈와 String 시리즈
- str : 메모리 침범 문제 등의 안전장치 없음
- _s : 사이즈 전달로 메모리 침범 문제를 1차적으로 방어. 하지만 사이즈를 잘못넣으면 그대로 진행되기 때문에 여전히 문제.
- String : 사이즈 이상 문자열 작업(복사 등)이 일어나면 에러 리턴. 자동으로 \n까지 채워줌

String의 특징
- 내부에서 실제 Byte단위 복사를 진행하며 매번 에러 체크하는 느낌.
- 안전한 영역까지 복사 후 \n까지 채워준 후 리턴.
- 예를 들어, 10바이트 버퍼에 15바이트를 복사할 경우, 9바이트만 복사된 후 마지막 널문자까지 넣은 후 에러 리턴.

가변인자
- va_list / va_start / va_args / va_end
- 중간에 va_args를 루프돌아야하지만, StringCcbVPrintf를 사용하면 루프 돌 필요 없음

워드 단위 복사
- 예를들어 워드가 8바이트일 경우 8바이트는 한 번에 복사된다.
- 하지만, 워드보다 크기가 크다면 바이트 단위 복사가 일어난다.

라이브러리란?
- 유용한 기능을 제공하는 코드 집합.
- Class나 Function으로 이루어짐