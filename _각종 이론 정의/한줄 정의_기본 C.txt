프로그래밍 언어란?
- 사람과 컴파일러가 이해할 수 있는 언어

컴파일러의 역활은?
- 프로그래밍 언어를 기계가 이해할 수 있는 기계어로 번역

C언어의 장점
- 절자지향적 -> 배우기 쉽다.
- 이식성이 좋다
- 성능이 좋다

C언어의 단점
- 주의깊게 사용해야 한다.

프로그램 완성 과정
- 코드작성 -> 컴파일 -> 실행파일 생성

함수란
- 반환형 / 함수 이름 / 매개변수 / 몸체로 이루어짐
- 프로그램의 핵심

표준함수
- 기본적으로 제공되는 함수

표준 라이브러리
- 표준함수들의 모임

헤더파일이란?
- 함수나 라이브러를 컴파일 할 때 필요한 인터페이스들이 정의되어 있는 파일

return의 의미
- 함수를 호출한 영역으로 값을 반환
- 함수 종료

메인함수에서 return에서 0을 반환하는 이유
- 메인함수를 호출한 주체는 운영체제이며, 0은 정상 리턴을 의미.

세미콜론의 역활
- 코드 문장의 끝을 표현

특수문자
- \r, \n같은 특수한 의미가 있는 문자.
- 모든 특수문자는 앞에 \이 붙는다.

\n은(Line Feed)?
- 다음줄로 개행

\r은(Carrige return)?
- 커서를 맨 왼쪽으로 이동

\"는?
- 큰따옴표 자체를 문자에 넣고싶을때 사용.

윈도우의 개행문자
- \r\n을 개행문자로 사용.

주석이 존재하는 이유
- 코드 분석을 용이하게 하기 위함.

주석 중첩
- 블록단위 주석은 중첩 불가능

서식문자란?(conversion specifier)
- 출력의 형태를 지정하는 문자
- 정수,소수,문자,문자열을 표시할 수 있다.
- %d : 10진수
- %u : 언사인 10진수
- %x : 16진수(%X로하면 대문자 출력)
- %p : 포인터의 주소값

변수
- 메모리 공간에 이름을 붙인 것.

변수 초기화란?
- 선언된 변수에 처음 값을 저장하는 것.
- 생성과 동시에 초기화 가능

초기화를 하지 않으면?
- 아무 의미없는 값이 저장되어 있다.

전역 변수를 초기화하지 않으면?
- 전역변수는 자동으로 0으로 초기화된다.

변수 선언 시 주의사항
- 중괄호 가장 앞부분에 위치해야 함(C언어의 경우)
- 공백 삽입 불가능
- 알파뱃/숫자/언더바(_)만 허용
- 숫자로 시작 불가능
- 대소문자 구분함
- 키워드를 변수이름으로 상용 불가

변수의 종류
- 정수형 변수, 실수형 변수

정수형/실수형 변수의 차이점
- 메모리에서 관리되는 방식

함수의 호출문에 연산식
- 함수 호출보다 연산식이 먼저 진행

이항 연산자
- 2개의 피연산자 존재
- 대입 / 산술 / 복합대입 / 비교연산 / 논리AND / 논리 OR

비교연산의 특징
- 조건 만족 시 true, 불만족시 false 반환
- 타 연산자들과 작동 방식이 조금 다름

부호 연산자
- 변수나 상수 앞에 붙는 부호
- + / -
- 복합대입과 햇갈리지 말자

단항 연산자
- 1개의 피연산자 존재
- 전위 증감 / 후위 증감 / 논리 NOT
- 전위 증/감 : 변수 증/감 후 로직 진행
- 후위 증/감 : 모든 로직 종료 후, 코드 다음줄로 이동시 변수 증/감

후위 증/감과 소괄호
- int num2 = (num--)+2;
- num--이 먼저 된 후 +2가 될 것 같지만 num+2 후, 코드 다음줄로 이동 시 num--이 진행

논리 연산자
- 논리 AND(&&) : 둘 다 참이면 true 반환
- 논리 OR(||) : 둘 중 하나라도 true면 true 반환
- 논리 NOT(!) : false를 true로 / true를 false로 변환해 반환

콤마 연산자
- 구분을 목적으로 하는 연산자

연산자 우선순위란?
- 동일한 코드에서 어떤 연산자를 우선 처리할지

결합 방향
- 우선순위가 동일한 연산자를, 어떠한 순서로 연산하는가

연산자 우선순위 외우기
- 표 외우기(사진)

scanf함수의 특징
- 공백을 기준으로 데이터 구분
- A B C를 입력하면 3개의 데이터, abc를 입력하면 1개의 데이터

2진수란?
- 2개의 기호를 이용해 데이터를 표현하는 방식
- 10진수는 10개 / 16진수는 16개 등..

2진수 덧셈
- 1+1 시 자기자신은 0이되며 1은 한칸 올린다.
- 0000 1111
  0000 0001
= 0001 0000 

16진수
- 대소문자 구분 없음
- 2진수 4개(4비트)는 16비트1개
- 1바이트를 16진수 2개로 표시

16진수 존재 이유
- 2진수로 표현하면 데이터가 너무 길어지기 때문이다.

비트란?
- 컴퓨터가 표현하는 데이터 최소단위

바이트란
- 비트가 8개 묶인 데이터 단위

진수 데이터 표현
- 0으로 시작하면 8진수
- 0x로 시작하면 16진수
- 특별한 선언 없으면 10진수

2진수를 10진수로 변환
- 2로 나눠서 1이 남을때까지 계산.
- 남은 값부터 각 계산값의 나머지를 이어붙이면 2진수

16진수를 10진수로 변환
- 16의 자리수 제곱 * 값 을 모두 다 더한다.
- 16진수 100
-> (16^0)*1 = 0
-> (16^1)*1 = 0
-> (16^2)*1 = (16*16)*1 = (256)*1 = 256
-> 0 + 0 + 256 = 256
-> 즉, [16진수 100 = 10진수 256]

컴퓨터의 정수 표현 방식
- 가장 앞에 부호비트(MSB. Most Significant Bit)를 표시. 0이면 양수 / 1이면 음수

양의 정수 표현 방법
- MSB가 0이면 양수

음의 정수 표현 방법
- MSB가 1이면 음수
- 2의 보수를 취한다.

2의 보수
- 컴퓨터의 음수 표현 방법
- [1의 보수 -> +1]
- 양->음, 음->양 시 사용

1의 보수
- 0을 1로 / 1을 0으로 변경

컴퓨터의 실수 표현 방식
- 표현 수식이 있음
- 우리가 표현하고자 하는 값의 근사치를 실수로 표시.

실수 표현 문제
- 근사치로 표시하기 때문에 오차가 있음 (부동소수점 오차)

비트연산자
- AND / OR / XOR / NOT / Left Shift / Right Shift
- AND : 2개의 비트가 모두 1이면, 1반환
- OR : 둘 중 하나의 비트면 1이면, 1반환
- XOR : 둘의 비트가 다르면, 1반환. 같으면 0 반ㅌ환
- NOT : 비트가 1이면 0, 0이면 1 반환.
- Left Shift : 비트를 <<로 이동
- RIght SHift : 비트를 >>로 이동

XOR의 특징
- 연속으로 2번 XOR하면 자기 자신이 나온다. (A ^ B = C / C ^ B = A)
- 주로 암호화에 사용

NOT의 특징
- MSB도 바뀐다.

Left Shift의 특징
- << 1칸 이동마다 값은 x2가 된다.
- 비는 값은 0으로 채운다.

Right Shift의 특징
- >> 1칸 이동마다 값은 /2가 된다.
- 비는 값은 양수일경우 0, 음수일 경우 1로 채운다 (MSB 고려)

논리 시프트
- 산술 시프트와 달리 MSB를 지키지 않으며, 빈 값은 무조건 0으로 채운다.

산술 시프트
- MSB를 지키기 때문에, 음수를 >> 연산하면 MSB로 1을 채운다.

자료형이란?
- 데이터를 표현하는 기준.
- 변수와 상수도 자료형에 근거

다양한 자료형 존재 이유
- 컴퓨터가 정수/실수를 표현하는 방법이 다르기 때문에
- 메모리의 효율적 사용을 위해

CPU 최적화 연산. int
- CPU는 정수형 연산 시 int형이 가장 빠르기 때문에, int로 형변환 시킨다.

실수 자료형 선택 시 주의점
- 정밀도 고려 (얼마나 오차가 나는지)

실수 입/출력 서식문자
- 출력 : %f
- 입력 : %lf

unsigned
- MSB조차 값 표현에 사용.
- 정수 자료형만 적용

컴퓨터의 문자 표현 방식
- 숫자와 문자를 맵핑해둔 아스키코드 사용
- 결국 문자도 숫자

문자를 char형에 저장하는 이유
- 아스키 코드가 128개로 이루어져 있기 때문에
- 메모리 효율적 사용

int연산이 CPU에 빠르면 문자도 int로 해야하지 않음?
- int 연산은 정수형 연산때만 빠른데, 문자는 정수형 연산을 할 일이 없음(가능은 함)

상수
- 변경 불가능한 데이터.
- 자료형을 근거로 표현
- 이름 있는 상수 / 이름 없는 상수로 구분

이름 없는 상수(리터럴 상수)
- 할당된 메모리에 이름이 없는 상수

리터럴 상수의 자료형
- 정수형 상수는 int형 / 실수형 상수는 double
- 문자형 상수('A')도 int형

상수형 접미사
- int/double 외 자료형으로 상수를 선언하는 방법
- 대소문자 구분 없음
- U : unsigned int
- L : long
- UL : unsigned long
- LL : long long
- ULL : unsigned long long
- F : float
- L : long double

이름 있는 상수 (심볼릭 함수. const 함수)
- 변수처럼 이름이 있는 상수
- const 키워드 사용 / 매크로 사용
- 값 변경 불가능

const를 이용한 상수
- 선언과 동시에 초기화

형변환
- 자료형 변경
- 자동 형변환 / 강제 형변환
- 딱히 연산은 없고 컴파일러에게 그렇게 알려주는 것

자동 형변환 발생 시점
- 대입 연산 : 대입하는 상황에 두 피연산자의 자료형이 다를 때, 왼편 피연산자 기준으로 자동형변환 (저장소 기준)
- 정수의 승격 : 4바이트 이하의 정수를 연산할 때. CPU가 처리하는데 적합한 자료형은 int. 이때 발생
- 자료형 불일치 : 두 피연산자의 자료형이 다를 때. int a = 1 + 1.5 일때 1 + 1.5에서 자료형 불일치 형변환 발생


정수를 실수로 형변환
- 정상

실수를 정수로 형변환
- 소수부의 손실

바이트가 큰 정수를 바이트가 작은 정수로 형변환
- 상위바이트 손실


소수부의 손실
- 실수형 데이터를 정수형 데이터로 형변환 시 발생
- int a = 3.1414 << 이 상황

상위바이트 손실
- 큰 바이트를 작은 바이트로 형변환 시 발생
- 부호가 바뀌는 상황도 발생한다.
- char ch = 129 << 이 상황
- 00000000 00000000 00000000 10000001(129)가 char에 저장되면 1바이트만 저장되기 때문에 10000001이 저장된다.
- 이는 2의 보수를 해보면 -127이 나온다. 부호가 바뀌었다.


자료형 불일치로 인한 형변환
- 데이터의 손실을 최소화 하는 방향으로 진행
- 정수보단 실수, 정수끼리는 바이트가 큰 것. 실수끼리도 바이트가 큰 것.


강제 형변환 발생 시점
- 프로그래머가 강제로 형변환 발생시킴.

연산 결과의 자료형
- 피 연산자의 자료형과 일치
- 3/4=0이 된다. 0.00... 얼마가 되지만 정수 나눗셈이기 때문에 0이 됨

C언어의 문자열 표현
- 가장 마지막에 null문자가 있는 곳 까지를 문자열로 본다. 이는 C언어의 특징이며 다른 언어는 다르게 표시될 수 있다.









워드 단위 복사
- 예를들어 워드가 8바이트일 경우 8바이트는 한 번에 복사된다.
- 하지만, 워드보다 크기가 크다면 바이트 단위 복사가 일어난다.

전역변수에 static일 붙일 경우
- 해당 파일에서만 사용한다는 의미. 다른 파일에서는 접근 불가능

라이브러리란?
- 유용한 기능을 제공하는 코드 집합.
- Class나 Function으로 이루어짐