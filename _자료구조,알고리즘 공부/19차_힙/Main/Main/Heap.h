#ifndef __HEAP_H__
#define __HEAP_H__

#define HEAP_LEN	100

template <typename T>
class Heap
{
	// 정렬용 함수 포인터 타입
	typedef int PriorityComp(T d1, T d2);

	T m_HeapArray[HEAP_LEN];
	int m_iSize;

	// 우선순위 체크 함수. 함수포인터
	// 첫 인자의 우선순위가 높을 시, 0보다 큰 값
	// 두 번째 인자의 우선순위가 높을 시, 0보다 작은 값.
	// 우선순위가 동일할 시 0
	PriorityComp* Comp;

private:
	// 부모의 인덱스
	int GetParentIDX(int idx)
	{	return idx / 2;	}

	// 왼쪽 자식의 인덱스
	int GetLeftChildIDX(int idx)
	{	return idx * 2; 	}

	// 오른쪽 자식의 인덱스
	int GetRightChildIDX(int idx)
	{	return idx * 2 + 1; 	}

	// 인자 2개의 우선순위 체크
	int  GetHiPriChildIDX(int idx);
	

public:
	// 초기화
	void Init(PriorityComp TComp)
	{  
		Comp = TComp;
		m_iSize = 0; 
	}

	// 삽입
	bool Insert(T data);

	// 삭제
	bool Delete(T* pData);

	// 사이즈 리턴
	int Size()
	{  return m_iSize;  }
};

// 인자 2개의 우선순위 체크
template <typename T>
int  Heap<T>::GetHiPriChildIDX(int idx)
{
	int LeftIdx = GetLeftChildIDX(idx);
	int RightIdx = GetRightChildIDX(idx);

	// 자식노드가 0명인 경우
	if (LeftIdx > m_iSize)
		return 0;

	// 자식 노드가 왼쪽 노드밖에 없는 경우
	else if (LeftIdx == m_iSize)
		return LeftIdx;

	// 자식노드가 둘 다 있는 경우
	else
	{
		// 오른쪽 자식의 우선순위가 높을 경우
		/*if (m_HeapArray[LeftIdx].m_iPr > m_HeapArray[RightIdx].m_iPr)
			return RightIdx;*/

		if (Comp(m_HeapArray[LeftIdx], m_HeapArray[RightIdx]) < 0)
			return RightIdx;

		// 왼쪽 자식의 우선순위가 높을 경우
		else
			return LeftIdx;
	}
}

// 삽입
template <typename T>
bool Heap<T>::Insert(T data)
{
	// 꽉찼으면 더 이상 못넣음
	if (m_iSize == HEAP_LEN)
		return false;

	// 임시로 가장 마지막에 들어갔다고 가정
	int NowIndex = m_iSize + 1;

	T Temp = data;

	// 현재 인덱스가 1이아니고 (즉 루트가 아니고)
	while (NowIndex != 1)
	{
		// 부모 인덱스 구함
		int ParnetIndex = GetParentIDX(NowIndex);

		// 부모의 우선순위가 나보다 낮다면 값 교체 (우선순위의 값이 작을수록 우선순위가 높다고 가정) 
		//if (Pr < m_HeapArray[ParnetIndex].m_iPr)
		if (Comp(data, m_HeapArray[ParnetIndex]) > 0)
		{
			// 부모를 내 위치로 이동(현재 내 위치는 비어있기 때문에 바로 이동시켜도 됨)
			m_HeapArray[NowIndex] = m_HeapArray[ParnetIndex];

			// 부모를 나로 취급
			NowIndex = ParnetIndex;

			// 부모 인덱스 다시 구함
			ParnetIndex = GetParentIDX(NowIndex);
		}

		else
			break;
	}

	// 찾은 위치에 나를 저장
	m_HeapArray[NowIndex] = Temp;
	m_iSize++;

	return true;
}

// 삭제
template <typename T>
bool Heap<T>::Delete(T* pData)
{
	// 데이터가 없으면 더 이상 못뺌
	if (m_iSize == 0)
		return false;

	// 리턴할 데이터 받아두기
	// 힙은 무조건 가장 앞의 데이터 리턴.
	*pData = m_HeapArray[1];

	// 가장 마지막 위치의 값을 받아옴
	T Temp = m_HeapArray[m_iSize];

	// Temp가 루트에 들어갔다고 가정. 자식으로 타고 내려가며 우선순위를 체크한다.
	int ParentIdx = 1;
	int ChildIdx;

	// 자식노드 존재여부 체크
	while (ChildIdx = GetHiPriChildIDX(ParentIdx))
	{
		// 마지막 노드의 우선순위가 높거나 같다면 break;
		//if (Temp.m_iPr <= m_HeapArray[ChildIdx].m_iPr)
		if (Comp(Temp, m_HeapArray[ChildIdx]) >= 0)
			break;

		// 찾아온 자식노드의 우선순위가 더 높다면, 값 교체
		m_HeapArray[ParentIdx] = m_HeapArray[ChildIdx];
		ParentIdx = ChildIdx;
	}

	// 찾은 위치에 Temp를 넣는다.
	m_HeapArray[ParentIdx] = Temp;
	m_iSize--;

	return true;
}


#endif // !__HEAP_H__
